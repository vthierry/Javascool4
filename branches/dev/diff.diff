Index: src/org/javascool/Core.java
===================================================================
--- src/org/javascool/Core.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/Core.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,93 @@
+/*******************************************************************************
+*           Philippe.Vienne, Copyright (C) 2011.  All rights reserved.         *
+*******************************************************************************/
+
+package org.javascool;
+
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import org.javascool.macros.Macros;
+import java.io.File;
+import java.net.URLDecoder;
+import java.nio.charset.Charset;
+import java.io.UnsupportedEncodingException;
+import org.javascool.gui.Desktop;
+import org.javascool.tools.ErrorCatcher;
+
+/** Lanceur de l'application "apprenant" qui permet de manipuler des «proglets».  *
+ *
+ * @see <a href="Core.java.html">source code</a>
+ * @serial exclude
+ */
+public class Core {
+  /** Aide de JVS */
+  public static final String help = "org/javascool/macros/memo-macros.htm";
+  /** Mets en place le système d'alerte en cas d'erreur non gérée. */
+  static void setUncaughtExceptionAlert() {
+    ErrorCatcher.setUncaughtExceptionAlert("<h1>Détection d'une anomalie liée à Java:</h1>\n" +
+                                           "Il y a un problème de compatibilité avec votre système, nous allons vous aider:<ul>\n" +
+                                           "  <li>Copier/Coller tous les éléments de cette fenêtre et</li>\n" +
+                                           "  <li>Envoyez les par mail à <b>javascool@googlegroups.com</b> avec toute information utile.</li>" +
+                                           " </ul>",
+                                           About.revision);
+  }
+  /** Retrouve le chemin du jar courant.
+   * @return Le chemin du jar
+   * @throws RuntimeException lorsque l'application n'a pas été démarré depuis un jar
+   */
+  public static String javascoolJar()  {
+    if (javascoolJar != null)
+      return javascoolJar;
+    String url = Macros.getResourceURL("org/javascool/Core.class").toString().replaceFirst("jar:file:([^!]*)!.*", "$1");
+    System.err.println("Notice: javascool url is " + url);   
+    if(url.endsWith(".jar")) {
+      try {
+	String jar = URLDecoder.decode(url, "UTF-8");
+	if (new File(jar).exists())
+	  return javascoolJar = jar;
+	// Ici on essaye tous les encodages possibles pour essayer de détecter javascool
+	{
+	  jar = URLDecoder.decode(url, Charset.defaultCharset().name());
+	  if (new File(jar).exists())
+	    return jar;
+	  for(String enc : Charset.availableCharsets().keySet()) {
+	    jar = URLDecoder.decode(url, enc);
+	    if (new File(jar).exists()) {
+	      System.err.println("Notice: javascool file " + jar + " correct decoding as "+enc);   
+	      return javascoolJar = jar;
+	    } else {
+	      System.err.println("Notice: javascool file " + jar + " wrong decoding as "+enc);   
+	    }
+	  }
+	  throw new RuntimeException("Il y a un bug d'encoding sur cette plate forme");
+	}
+      } catch (UnsupportedEncodingException ex) {
+	throw new RuntimeException("Spurious defaultCharset: this is a caveat");
+      }
+    } else
+      throw new RuntimeException("Java's cool n'a pas été démarré depuis un Jar");
+  }
+  private static String javascoolJar = null;
+  /** Lanceur de l'application.
+   * @param usage <tt>java -jar javascool.jar</tt>
+   */
+  public static void main(String[] usage) {
+    if((usage.length > 0) && (usage[0].equals("-h") || usage[0].equals("-help") || usage[0].equals("--help"))) {
+      System.out.println("Java's Cool Core - lance l'interface pour travailler avec les proglets");
+      System.out.println("Usage : java -jar javascool.jar");
+      System.exit(0);
+    }
+    // Empeche de pouvoir renommer itempestivement des folder
+    UIManager.put("FileChooser.readOnly", Boolean.TRUE);
+    System.err.println("" + About.title + " is starting ...");
+    ErrorCatcher.checkJavaVersion(6);
+    setUncaughtExceptionAlert();
+    SwingUtilities.invokeLater(new Runnable() {
+		
+		@Override
+		public void run() {
+		    Desktop.getInstance().getFrame();
+		}
+	});
+  }
+}
Index: src/org/javascool/Build.java
===================================================================
--- src/org/javascool/Build.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/Build.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,51 @@
+package org.javascool;
+
+import java.io.File;
+import java.io.IOException;
+import org.javascool.builder.ProgletsBuilder;
+import org.javascool.tools.ErrorCatcher;
+import org.javascool.tools.Pml;
+
+/** Lanceur de l'application "formateur" qui permet de construire des «proglets».
+ *
+ * @see <a href="Build.java.html">code source</a>
+ * @serial exclude
+ */
+public class Build {
+
+    /** Logo de l'application. */
+    public static final String logo = "org/javascool/widgets/icons/logo-builder.png";
+
+    /** Lanceur de la conversion Jvs en Java.
+     * @param usage <tt>java org.javascool.Build  [-q [targetDir]]</tt>
+     */
+    public static void main(String[] usage) {
+        Pml args = new Pml().reset(usage);
+        ErrorCatcher.checkJavaVersion(6);
+        Core.setUncaughtExceptionAlert();
+        ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
+        if (args.getBoolean("h") || args.getBoolean("help")) {
+            System.out.println("Java's Cool Builder - Construit un jar avec les proglets souhaitées");
+            System.out.println("Usage : java -jar javascool-builder.jar [-q] [-w] [-v] [-target target-dir] [-proglets proglet-list]");
+            System.out.println("Options : ");
+            System.out.println("\t-q\tPermet de lancer l'application en console sur toutes les proglets disponibles et sans interface graphique.");
+            System.out.println("\t-w\tPermet de lancer l'application en console et génère les fichiers javadoc et jars des proglets.");
+            System.out.println("\t-v\tPermet de lancer l'application en mode verbose, toute les étapes sont affiché.");
+            System.out.println("\t-target target-dir\tLe répertoire cible dans lequel la construction se fait (c'est le répertoire temporaire .build par défaut).");
+            System.out.println("\t-proglets proglet-dir\tLes proglets à prendre en compte (elle le sont toutes part défaut).");
+      } else if (!(args.getBoolean("q") || args.getBoolean("w"))) {
+	org.javascool.builder.DialogFrame.startFrame();
+      } else {
+       try {
+	if (args.isDefined("target") && new File(".").getCanonicalPath().equals(new File(args.getString("target")).getCanonicalPath()))
+	  throw new IllegalArgumentException("Le répertoire du sketchbook et celui du build ne peuvent pas être identiques !!!");
+          } catch(IOException e) {
+           throw new IllegalArgumentException("Le répertoire du build n'est pas utilisable.");
+          }
+	ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
+        String target = args.isDefined("target") ? args.getString("target") : null;
+        String names[] = args.isDefined("proglets") ? args.getString("proglets").trim().split("[, \t]+") : null;
+	System.exit(ProgletsBuilder.build(ProgletsBuilder.getProglets(names), target, args.getBoolean("w")) ? 0 : -1);
+      }
+    }
+}
Index: src/org/javascool/About.java
===================================================================
--- src/org/javascool/About.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/About.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,43 @@
+package org.javascool;
+
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import javax.swing.JLabel;
+import org.javascool.macros.Macros;
+
+/** Définit le panneau de "about" de javascool et son bouton d'ouverture.
+ */
+public class About {
+
+  /** Titre de l'application. */
+  public static final String title = "Java's Cool 4";
+  /** Logode l'application. */
+  public static final String logo = "org/javascool/widgets/icons/logo.png";
+
+  /** Numéro de révision de l'application.*/
+  public static final String revision = "4.0.973"; // @revision automatiquement mis à jour par ant -f work/build.xml classes
+
+
+  /** Affiche le message de "about". */
+  public static void showAboutMessage() {
+    Macros.message(title + " ("+revision+") est un logiciel conçu par : <br/><center>"
+                   + "Philippe VIENNE<br/>"
+                   + "Guillaume MATHERON<br/>"
+                   + " et Inria<br/>"
+                   + "</center>"
+		   + "en collaboration avec David Pichardie, Philippe Lucaud, etc.. et le conseil de Robert Cabane<br/><br/>"
+                   + "Il est distribué sous les conditions de la licence CeCILL et GNU GPL V3<br/>", true);
+  }
+
+  /** Renvoie une bouton (sous forme de logo) qui affiche le panneau de about lors de son clic. */
+  public static JLabel getAboutMessage()  {
+        JLabel logoLabel = new JLabel(Macros.getIcon(logo));
+        logoLabel.addMouseListener(new MouseAdapter() {
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                showAboutMessage();
+            }
+        });
+        return logoLabel;
+  }
+}
Index: src/org/javascool/package.html
===================================================================
--- src/org/javascool/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,15 @@
+<body>Bienvenue dans la liasse des fichiers sources de JavaS'Cool, version 4.
+
+ <p>Java's Cool (alias Javascool) est un logiciel conçu pour l'apprentissage des bases de la programmation.</p>
+
+ <p>Cette liasse se décompose en trois blocs: <ol>
+   <li>L'application "apprenant" qui permet de manipuler des «proglets» (<a href="Core.html">org.javascool.Core</a>): <ul>
+   <li>On peut directement lancer <a href="http://javascool.gforge.inria.fr/v4/javascool-proglets.jar">javascool-proglets.jar</a> pour en profiter.</li></ul></li>
+   <li>L'application "formateur" qui permet de construire des «proglets» (<a href="Builder.html">org.javascool.Builder</a>): <ul>
+   <li>On peut <i>télécharger</i> <a href="http://javascool.gforge.inria.fr/v4/javascool-builder.jar">javascool-builder.jar</a> et le lancer dans le répertoire oqui contient les dossiers avec les «proglets» afin de les compiler.</li></ul></li>
+   <li>Les fichiers sources du <a href="http://javascool.fr/v4">site web</a> qui sont générés et publiés à partir d'<a href="http://code.google.com/p/javascool/source/browse/web/package.txt">ici</a>.</li>
+ </ol></p>
+
+ <p>La <a href="http://code.google.com/p/javascool/source/browse">liasse des fichiers</a> est <a href="http://code.google.com/p/javascool/source/browse/package.txt">décrite ici</a>.</p>
+
+</body>
Index: src/org/javascool/macros/memo-macros.xml
===================================================================
--- src/org/javascool/macros/memo-macros.xml	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/memo-macros.xml	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,63 @@
+<div title="Memorandum des constructions et instructions">
+  <div class="margin">Dominique Larrieu, lycée Simone Veil, Valbonne</div>
+  <div title="Programme principal">Il se note <b><r>void main</r>{ }</b> avec les instructions définies entre <b>{ }</b>.</div>
+  <div title="Type de données utilisées"><div class="ul">
+    <div><r>String</r> Chaîne de caractères (ex: <b><r>String</r> nom = <v>Dupond</v>;</b>).</div>
+    <div><r>int</r> Entier positif ou négatif, de environ -2 à +2 milliards (ex: <b><r>int</r> n = <v>8</v>;</b>).</div>
+    <div><r>double</r> Nombre décimal, comme sur une calculette (ex:<b><r>double</r> pi = 3.1416;</b>).<div class="code">
+    <m>Les nombres décimaux se notent avec un "." point et non une virgule !</m>
+    <m>Les nombres en notation scientifique (par exemple 6.023 1023) se note avec un "e" (pour exposant) : ici <c>6.023e23</c></m>
+    </div></div>
+    <div><r>boolean</r> Valeur vraie ou fausse, utilisée dans les tests (ex:<b><r>boolean</r> b = x > 0;</b>).</div>
+  </div></div>
+  <div title="Quelques fonctions utilisées."><div class="ul">
+    <p><b>sleep(1000);</b> Arrête l'exécution du programme pendant 1000 milli-secondes.</p>
+    <p><b><r>double</r> x = random();</b> Renvoie dans la variable <b>x</b> un nombre aléatoire décimal compris entre 0 et 1.</p>
+    <p><b><r>int</r> n = random(1, 6);</b> Renvoie dans la variable <b>n</b> un nombre aléatoire entier entre 1 et 6.</p>
+    <p><b><r>boolean</r> y = equal("Dupond", "Dupont");</b> Compare les deux chaînes de caratères « Dupond » et « Dupont » et renvoie dans la variable <b>y</b> la valeur <b>false</b>.</p>
+    <p><b><r>double</r> z = pow(x, 2);</b> Renvoie dans la variable <b>y</b> le carré <b>x²</b>.</p>
+    <p><b><r>double</r> x = sqrt(x);</b> Renvoie dans la variable <b>x</b> la racine de <b>x</b>.</p>
+  </div></div>
+  <div title="Fonctions de lecture/écriture:"><div class="ul">
+    <p><b>clear();</b> Efface l’affichage.</p>
+    <p><b><r>String</r> prenom = readString();</b> Lit une chaîne de caratères dans la ligne d'entrée au clavier.</p>
+    <p><b><r>int</r> age = readInteger();</b> Lit un nombre entier dans la ligne d'entrée au clavier.</p>
+    <p><b><r>double</r> taille = readDouble();</b> Lit un nombre décimal dans la ligne d'entrée au clavier.</p>
+    <p><b>println("Oh");</b> Ecrit «Oh» dans la fenêtre de sortie.</p>
+    <p><b>println("Oh," + age + " ans , est un bel âge !");</b> Ecrit « Oh, 20 ans, est un bel âge ! » (quand age=20).</p>
+  </div></div>
+  <div title="Bloc de séquences d'instructions"> Un bloc se note entre <b>{ }</b> et englobe un ensemble de déclarations et d'instructions séparées par un <b>;</b>.</div>
+  <div title="Opérateurs"><div class="table">
+    <div><div><c>=</c></div><div>Affectation d'une valeur à une variable (ex: <b>x = 0;</b>)</div></div>
+    <div><div><c>||</c> <c>&amp;&amp;</c> <c>!</c></div><div>Opérateur logique OU, ET et NON</div></div>
+    <div><div><c>==</c> <c>!=</c> <c>&lt;=</c> <c>&lt;</c> <c>&gt;=</c> <c>&gt;</c> </div><div>Opérateur égalité, différence et comparaison numérique</div></div>
+    <div><div><c>+</c> <c>-</c> <c>*</c> <c>/</c> <c>%</c> </div><div>Addition, soustraction, multiplication, division, reste (appelé aussi modulo).</div></div>
+  </div></div>
+  <div title="Instruction conditionnelle">
+    <p><b><r>if</r> (expressionBooleenne) { BlocD'InstructionsSiVrai } <r>else</r> { BlocD'InstructionsSiFaux }</b></p>
+    <div title="Exemple:"><div class="code">
+    <p><r>if</r>(température &lt; 15) {</p>
+    <p><T/><r>println</r>(<v>allumer chauffage</v>);</p>
+    <p>} <r>else</r> {</p>
+    <p><T/><r>println</r>(<v>ne rien faire</v>);</p>
+    <p>}</p>
+  </div></div></div>
+  <div title="Boucle">
+    <p><b><r>while</r> (expressionBooléenne) { BlocD'Instructions }</b></p>
+    <div title="Exemple:"><div class="code">
+       <p><r>while</r>( n &lt; 10) {</p>
+       <p><T/><r>println</r>(<v>Hello World !</v>);</p>
+       <p><T/>n = n + 1;</p>
+       <p>}</p>
+   </div></div></div>
+   <div title="Déclaration de fonction">
+     <p><b>TypeDuResultat NomDeLaFonction (TypeParametre1 NomParametre1, ...) { BlocD'Instructions }</b></p> 
+     <div title="Exemple:"><div class="code">
+       <p><r>int</r> max(int x, int y) {</p>
+       <p><r>if</r> (x > y) {</p>
+       <p><T/><r>return</r> x;</p> 
+       <p>} <r>else</r> {</p>      
+       <p><T/><r>return</r> y;</p> 
+       <p>} }</p>
+   </div></div></div>
+</div>
Index: src/org/javascool/macros/package.html
===================================================================
--- src/org/javascool/macros/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les fonctions statiques qui servent de macros aux programmes Jvs.</body>
+
Index: src/org/javascool/macros/Stdout.java
===================================================================
--- src/org/javascool/macros/Stdout.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Stdout.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,142 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.macros;
+
+import org.javascool.gui.Desktop;
+import org.javascool.widgets.Console;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Stdout.java.html">code source</a>
+ * @serial exclude
+ */
+public class Stdout {
+  // @factory
+  private Stdout() {}
+
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
+   * - Cette fonction ne change pas le focus de javascool.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   * @see #println(String)
+   */
+  public static void echo(String string) {
+      Console.getInstance().print(string+"\n");
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(int string) {
+    echo("" + string);
+  } 
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(char string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(double string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(boolean string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(Object string) {
+    echo("" + string);
+  }
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
+   * - Cette fonction ramène le focus de javascool sur la console.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   * @see #echo(String)
+   */
+  public static void println(String string) {
+    Desktop.getInstance().focusOnConsolePanel();
+    System.err.println("printing : \""+string+"\"");
+      Console.getInstance().print(string+"\n");
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(int i) {
+    println("" + i);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(char i) {
+    println("" + i);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(double d) {
+    println("" + d);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(boolean b) {
+    println("" + b);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(Object o) {
+    println("" + o);
+  }
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console sans retour à la ligne.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   */
+  public static void print(String string) {
+    System.out.print(string);
+    System.out.flush();
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(int i) {
+    print("" + i);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(double d) {
+    print("" + d);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(boolean b) {
+    print("" + b);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(Object o) {
+    print("" + o);
+  }
+  /** Efface tout ce qui est écrit dans la console. */
+  public static void clear() {
+    Console.getInstance().clear();
+  }
+  /** Sauve ce qui est présentement écrit dans la console dans un fichier.
+   * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.
+   */
+  public static void saveConsoleOutput(String location) {
+    Console.getInstance().saveConsoleOutput(location);
+  }
+}
Index: src/org/javascool/macros/Stdin.java
===================================================================
--- src/org/javascool/macros/Stdin.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Stdin.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,289 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.macros;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import org.javascool.widgets.Dialog;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Stdin.java.html">code source</a>
+ * @serial exclude
+ */
+public class Stdin {
+  // @factory
+  private Stdin() {}
+
+  /** Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La chaîne lue.
+   */
+  public static String readString(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popString();
+    inputQuestion = question;
+    inputString = null;
+    inputDialog = new Dialog();
+    inputDialog.setTitle("Java's Cool read");
+    inputDialog.add(new JPanel() {
+                      {
+                        add(new JLabel(inputQuestion + " "));
+                        add(new JTextField(40) {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = ((JTextField) e.getSource()).getText();
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                      }
+                    }
+                    );
+    inputDialog.open(true);
+    return inputString == null ? "" : inputString;
+  }
+  private static Dialog inputDialog;
+  private static String inputQuestion, inputString;
+
+  /**
+   * @see #readString(String)
+   */
+  public static String readString() {
+    return readString("Entrez une chaîne :");
+  }
+  /** Lit un nombre entier dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static int readInteger(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popInteger();
+    String s = readString(question);
+    try {
+      return Integer.decode(s);
+    } catch(Exception e) {
+      if(!question.endsWith(" (Merci d'entrer un nombre entier)"))
+        question = question + " (Merci d'entrer un nombre entier)";
+      if(s.equals(""))
+        return 0;
+      return readInteger(question);
+    }
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInteger() {
+    return readInteger("Entrez un nombre entier : ");
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInt(String question) {
+    return readInteger(question);
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInt() {
+    return readInteger();
+  }
+  /** Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static double readDecimal(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popDecimal();
+    String s = readString(question);
+    try {
+      return Double.parseDouble(s);
+    } catch(Exception e) {
+      if(!question.endsWith(" (Merci d'entrer un nombre)"))
+        question = question + " (Merci d'entrer un nombre)";
+      if(s.equals(""))
+        return 0;
+      return readDecimal(question);
+    }
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDecimal() {
+    return readDecimal("Entrez un nombre décimal : ");
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDouble(String question) {
+    return readDecimal(question);
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDouble() {
+    return readDecimal();
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readFloat(String question) {
+    return readDecimal(question);
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readFloat() {
+    return readDecimal();
+  }
+  /** Lit une valeur booléenne dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static boolean readBoolean(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popBoolean();
+    inputQuestion = question;
+    inputString = null;
+    inputDialog = new Dialog();
+    inputDialog.setTitle("Java's Cool read");
+    inputDialog.add(new JPanel() {
+                      {
+                        add(new JLabel(inputQuestion + " "));
+                        add(new JButton("OUI") {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = "OUI";
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                        add(new JButton("NON") {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = "NON";
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                      }
+                    }
+                    );
+    inputDialog.open(true);
+    return "OUI".equals(inputString);
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static boolean readBoolean() {
+    return readBoolean("Entrez une valeur booléenne (oui/non) : ");
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static Boolean readBool(String question) {
+    return readBoolean(question);
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static Boolean readBool() {
+    return readBoolean();
+  }
+  /** Charge une chaine de caractère pour que son contenu serve d'entrée à la console.
+   * @param string La chaine de caractère à ajouter.
+   */
+  public static void addConsoleInput(String string) {
+    inputBuffer.add(string);
+  }
+  /** Charge le contenu d'un fichier pour que son contenu serve d'entrée à la console.
+   * @param location La localisation (chemin du fichier ou localisation internet) d'où charger le texte.
+   */
+  public static void loadConsoleInput(String location) {
+    addConsoleInput(org.javascool.tools.FileManager.load(location));
+  }
+  /** Définit une zone tampon qui permet de substituer un fichier aux lectures au clavier. */
+  private static class InputBuffer {
+    String inputs = new String();
+
+    /** Ajoute une chaîne en substitution d'une lecture au clavier.
+     * @param string Le texte à ajouter.
+     */
+    public void add(String string) {
+      inputs += string.trim() + "\n";
+    }
+    /** Teste si il y une chaîne disponible.
+     * @return La valeur true si il y une entrée disponible.
+     */
+    public boolean isPopable() {
+      return inputs.length() > 0;
+    }
+    /** Récupére une chaîne en substitution d'une lecture au clavier.
+     * @return Le texte suivant à considérer. Ou la chaîne vide si le tampon est vide.
+     */
+    public String popString() {
+      Macros.sleep(500);
+      int i = inputs.indexOf("\n");
+      if(i != -1) {
+        String input = inputs.substring(0, i);
+        inputs = inputs.substring(i + 1);
+        return input;
+      } else
+        return "";
+    }
+    /**
+     * @see #popString(String)
+     */
+    public int popInteger() {
+      try {
+        return Integer.decode(popString());
+      } catch(Exception e) {
+        return 0;
+      }
+    }
+    /**
+     * @see #popString(String)
+     */
+    public double popDecimal() {
+      try {
+        return Double.parseDouble(popString());
+      } catch(Exception e) {
+        return 0;
+      }
+    }
+    /**
+     * @see #popString(String)
+     */
+    public boolean popBoolean() {
+      // Renvoie vrai si [t]rue [y]es [v]rai [o]ui 1
+      return popString().toLowerCase().matches("[tyvo1].*");
+    }
+  }
+  private static InputBuffer inputBuffer = new InputBuffer();
+}
+
Index: src/org/javascool/macros/Macros.java
===================================================================
--- src/org/javascool/macros/Macros.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Macros.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,336 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.macros;
+
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.Desktop;
+import java.awt.Dimension;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.net.URISyntaxException;
+
+import java.util.Calendar;
+import javax.swing.ImageIcon;
+
+import org.javascool.tools.Sampler;
+import org.javascool.core.ProgletEngine;
+
+import java.net.URL;
+import java.io.File;
+import java.io.IOException;
+import javax.swing.JButton;
+import javax.swing.JEditorPane;
+import org.javascool.core.ProgletEngine;
+import org.javascool.widgets.Dialog;
+import javax.swing.SwingUtilities;
+import org.javascool.widgets.PanelApplet;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions plus facile d'utilisation que les appels Java usuels.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Macros.java.html">code source</a>
+ * @serial exclude
+ */
+public class Macros {
+    // @factory
+
+    private Macros() {
+    }
+
+    /** Renvoie un nombre entier aléatoire uniformément distribué entre deux valeurs (maximum inclus).
+     */
+    public static int random(int min, int max) {
+        return (int) Math.floor(min + (max - min) * Math.random());
+    }
+
+    /** Renvoie true si deux chaînes de caratères sont égales, faux sinon.
+     * @param string1 L'une des chaînes à comparer.
+     * @param string2 L'autre des chaînes à comparer.
+     */
+    public static boolean equal(String string1, String string2) {
+        return string1.equals(string2);
+    }
+
+    /** Renvoie le temps actuel en milli-secondes.
+     * @return Renvoie la différence, en millisecondes, entre le temps actuel et celui du 1 Janvier 2000, minuit, en utilisant le temps universel coordonné.
+     */
+    public static double now() {
+        return System.currentTimeMillis() - offset;
+    }
+    private static long offset;
+
+    static {
+        Calendar ref = Calendar.getInstance();
+        ref.set(2000, 0, 1, 0, 0, 0);
+        offset = ref.getTimeInMillis();
+    }
+
+    /** Temporise une durée fixée.
+     * Cela permet aussi de mettre à jour l'affichage.
+     * @param delay Durée d'attente en milli-secondes.
+     */
+    public static void sleep(int delay) {
+        try {
+            if (delay > 0) {
+                Thread.sleep(delay);
+            } else {
+                Thread.sleep(0, 10000);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException("Programme arrêté !");
+        }
+    }
+
+  /** Excécute une routine à un intervalle régulier.
+   * Exemple d'usage (impression de 10 messages à interval d'1 sec. puis arrêt):<pre>
+   * sample(1000, new Runnable() { public void run() {
+   *    if (count &lt; 10) {
+   *      println("Et de "+(++count)+" !");	
+   *    } else throw new RuntimeException("done!"); 
+   *  }
+   *  int count = 0;
+   * });</pre>
+   * <p> Noter que le runnable doit être interrompu par le jet d'une exception, sinon il tournera sans relâche jusqu'à la fermeture de javascool.
+   * @param delay Période d'échantillonage en milli-secondes.
+   * @param runnable Le code à exécuter à chaque appel.
+   */
+  public static void sample(int delay, Runnable runnable) {
+    Sampler sampler = new Sampler().setDelay(delay).setRunnable(runnable);
+    sampler.start();
+  }
+
+  /** Vérifie une assertion et arrête le code si elle est fausse.
+   * Le diagnoctic apparait sous la forme:
+   *<pre>Arrêt du programme :{
+   *  L'assertion(«<i>message</i>») est fausse.
+   *  Pile d'exécution: {
+   *   <i>fonctions appellées et ligne de code correspondant</i>
+   *  }
+   *  Objet en cause:{
+   *     class = «<i>type de l'objet</i>»
+   *     value = «<i>valeur de l'objet</i>»
+   *  }
+   *}</pre>
+   * @param condition Si la condition n'est pas vérifiée, le code JavaScool va s'arrêter.
+   * @param message Un message s'imprime sur la console pour signaler l'erreur.
+   * @param object Si l'objet n'est pas null, donne des renseignements sur l'objet
+   */
+  public static void assertion(boolean condition, String message, Object object) {
+    System.err.println("#" + condition + " : " + message +" ::"+object);
+    if (!condition) {
+      System.out.println("Arrêt du programme :{\n  L'assertion(«"+message+"») est fausse.\n  Pile d'exécution: {");
+      // Sortie de la pile,
+      // - moins les deux appels getStackTrace() et assertion() et
+      // - moins les trois appels run() du bas de pile qui ont lancés la proglet
+      {
+	StackTraceElement where[] = Thread.currentThread().getStackTrace();
+	for(int i = 2; i < where.length -3; i++)
+	  System.out.println("     "+where[i].toString().replaceAll("JvsToJavaTranslated[0-9]+\\.", "").replaceAll("java:([0-9]+)", "ligne : $1"));
+      }
+      System.out.println("  }");
+      if (object != null)
+	System.out.println("  Objet en cause:{\n    class = «"+object.getClass()+"»\n    value = «"+object+"»\n  }");
+      System.out.println("}");
+      org.javascool.core.ProgletEngine.getInstance().doStop();
+      Macros.sleep(500);
+    }
+  }
+    /**
+     * @see #assertion(boolean, String, Object)
+     */
+  public static void assertion(boolean condition, String message) {
+    assertion(condition, message, null);
+  }
+
+    /** Affiche un message dans une fenêtre présentée à l'utilisateur.
+     * <p>Le message s'affiche sous une forme "copiable" pour que l'utilisateur puisse le copier/coller.</p>
+     * @param text Le message à afficher.
+     * @param html Mettre à true si le texte est en HTML, false sinon (valeur par défaut)
+     */
+    public static void message(String text, boolean html) {
+        JEditorPane p = new JEditorPane();
+        p.setEditable(false);
+        p.setOpaque(false);
+        if (html)
+            p.setContentType("text/html; charset=utf-8");
+        p.setText(text);
+        p.setBackground(new java.awt.Color(200, 200, 200, 0));
+        messageDialog = new Dialog();
+        messageDialog.setTitle("Java's Cool message");
+	messageDialog.setMinimumSize(new Dimension(300, 100));
+        messageDialog.add(p);
+        messageDialog.add(new JButton("OK") {
+        {
+           addActionListener(new ActionListener() {
+                    @Override
+                    public void actionPerformed(ActionEvent e) {
+                        messageDialog.close();
+                    }
+                });
+            }
+        }, BorderLayout.SOUTH);
+        messageDialog.open(!SwingUtilities.isEventDispatchThread());
+    }
+    private static Dialog messageDialog;
+
+    /**
+     * @see #message(String, boolean)
+     */
+    public static void message(String text) {
+        message(text, false);
+    }
+
+    /** Renvoie une icone stockée dans le JAR de l'application.
+     * @param path Emplacement de l'icone, par exemple <tt>"org/javascool/widget/icons/play.png"</tt>
+     * @return L'icone chargée ou null si elle n'existe pas.
+     */
+    public static ImageIcon getIcon(String path) {
+      URL icon = getResourceURL(path); // Thread.currentThread().getContextClassLoader().getResource(path);
+        if (icon == null) {
+            System.err.println("Warning : getIcon(" + path + ") not found");
+        }
+        return icon == null ? null : new ImageIcon(icon);
+    }
+
+    /** Ouvre une URL (Universal Resource Location) dans un navigateur extérieur.
+     * @param location L'URL à afficher.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static void openURL(String location) {
+        try {
+          if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
+            Desktop.getDesktop().browse(new java.net.URI(location));
+            System.err.println("Note: Ouverture de " + location + " dans un navigateur externe");
+          } else {
+              openURL2(location);
+          }
+        } catch (Throwable th) {
+            openURL2(location);
+        }
+    }
+    // Procédure de secours pour ouvrir une URL
+    private static void openURL2(String location) {
+     System.err.println("Note: Ouverture de " + location + " dans un browser navigateur (methode de secours)");
+                String url = location;
+                String os = System.getProperty("os.name").toLowerCase();
+                Runtime rt = Runtime.getRuntime();
+                try {
+                    if (os.indexOf("win") >= 0) {
+                        rt.exec("rundll32 url.dll,FileProtocolHandler " + url);
+                    } else if (os.indexOf("mac") >= 0) {
+                        rt.exec("open " + url);
+                    } else if (os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0) {
+                        // Do a best guess on unix until we get a platform independent way
+                        // Build a list of browsers to try, in this order.
+                        String[] browsers = {"epiphany", "firefox", "mozilla", "konqueror",
+                            "netscape", "opera", "links", "lynx"};
+                        // Build a command string which looks like "browser1 "url" || browser2 "url" ||..."
+                        StringBuilder cmd = new StringBuilder();
+                        for (int i = 0; i < browsers.length; i++) {
+                            cmd.append(i == 0 ? "" : " || ").append(browsers[i]).append(" \"").append(url).append("\" ");
+                        }
+                        rt.exec(new String[]{"sh", "-c", cmd.toString()});
+                    } else {
+                        throw new RuntimeException("Erreur (pas d'OS détecté) à l'ouverture dans un navigateur de " + location);
+                    }
+            } catch (Exception e) {
+                throw new RuntimeException("Erreur (" + e + ") à l'ouverture dans un navigateur de " + location);
+            }
+    }
+    /** Renvoie une URL (Universal Resource Location) normalisée, dans le cas du système de fichier local ou d'une ressource.
+     * <p>La fonction recherche l'existence du fichier:
+     * (i) par rapport au répertoire de base qui est donné,
+     * (ii) par rapport au dossier de travaul "user.dir",
+     * (iii) par rapport à la racine des fichier "user.home",
+     * (iv) dans les ressources du CLASSPATH.</p>
+     * @param location L'URL à normaliser.
+     * @param base     Un répertoire de réference pour la normalisation. Par défaut null.
+     * @param reading  Précise si nous sommes en lecture (true) ou écriture (false). Par défaut en lecture.
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     */
+    public static URL getResourceURL(String location, String base, boolean reading) {
+        if (base != null) {
+            location = base + "/" + location;
+        }
+        try {
+            // @patch : ceci blinde un bug sur les URL jar
+            if (location.matches("jar:[^!]*!.*")) {
+                String res = location.replaceFirst("[^!]*!/", "");
+                URL url = Thread.currentThread().getContextClassLoader().getResource(res);
+                if (url != null) {
+                    return url;
+                } else {
+                    throw new IllegalArgumentException("Unable to find " + res + " from " + location + " as a classpath resource");
+                }
+            }
+            if (location.matches("(ftp|http|https|jar|mailto|stdout):.*")) {
+                return new URL(location).toURI().normalize().toURL();
+            }
+            if (location.startsWith("file:")) {
+                location = location.substring(5);
+            }
+            if (reading) {
+                File file = new File(location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                file = new File(System.getProperty("user.dir"), location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                file = new File(System.getProperty("user.home"), location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                URL url = Thread.currentThread().getContextClassLoader().getResource(location);
+                if (url != null) {
+                    return url;
+                }
+            }
+            return new URL("file:" + location);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+        }
+    }
+
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location, String base) {
+        return getResourceURL(location, base, true);
+    }
+
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location, boolean reading) {
+        return getResourceURL(location, null, reading);
+    }
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location) {
+        return getResourceURL(location, null, true);
+    }
+    /** Renvoie le panneau graphique de la proglet courante.
+     * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
+     */
+    public static < T extends Component> T getProgletPane() {
+        Component c = null;
+        try {
+            c = ProgletEngine.getInstance().getProglet().getProgletPane();
+        } catch (Throwable e) {
+            c = PanelApplet.getPane();
+        }
+        return (T) c;
+    }
+}
Index: src/org/javascool/macros/memo-macros.htm
===================================================================
--- src/org/javascool/macros/memo-macros.htm	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/memo-macros.htm	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,257 @@
+
+<!DOCTYPE html
+  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+   <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+   
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+      <title>Memorandum des constructions et instructions</title>
+   </head>
+   <body>
+      <h1>Memorandum des constructions et instructions.</h1>
+      
+      <div align="right" class="margin">Dominique Larrieu, lyc&eacute;e Simone Veil, Valbonne</div>
+        
+      <div>
+         <h2>Programme principal.</h2>Il se note <b><font color="#990000"><b>void main</b></font>{ }</b> avec les instructions d&eacute;finies entre <b>{ }</b>.
+      </div>
+        
+      <div>
+         <h2>Type de donn&eacute;es utilis&eacute;es.</h2>
+         <ul class="ul">
+                
+            <li><font color="#990000"><b>String</b></font> Cha&icirc;ne de caract&egrave;res (ex: <b><font color="#990000"><b>String</b></font> nom = <font color="#008000">"Dupond"</font>;</b>).
+            </li>
+                
+            <li><font color="#990000"><b>int</b></font> Entier positif ou n&eacute;gatif, de environ -2 &agrave; +2 milliards (ex: <b><font color="#990000"><b>int</b></font> n = <font color="#008000">"8"</font>;</b>).
+            </li>
+                
+            <li><font color="#990000"><b>double</b></font> Nombre d&eacute;cimal, comme sur une calculette (ex:<b><font color="#990000"><b>double</b></font> pi = 3.1416;</b>).
+               <div class="code">
+                  <table witdh="90%" border="1" align="center">
+                     <tr>
+                        <td>
+                           <div class="code">
+                                  
+                              <p><tt><font color="#202080"><big>//</big>&nbsp;Les nombres d&eacute;cimaux se notent avec un "." point et non une virgule !</font></tt></p>
+                                  
+                              <p><tt><font color="#202080"><big>//</big>&nbsp;Les nombres en notation scientifique (par exemple 6.023 1023) se note avec un "e" (pour exposant) : ici <tt>6.023e23</tt></font></tt></p>
+                                  
+                           </div>
+                        </td>
+                     </tr>
+                  </table>
+               </div>
+            </li>
+                
+            <li><font color="#990000"><b>boolean</b></font> Valeur vraie ou fausse, utilis&eacute;e dans les tests (ex:<b><font color="#990000"><b>boolean</b></font> b = x &gt; 0;</b>).
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Quelques fonctions utilis&eacute;es..</h2>
+         <ul class="ul">
+                
+            <li><b>sleep(1000);</b> Arr&ecirc;te l'ex&eacute;cution du programme pendant 1000 milli-secondes.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> x = random();</b> Renvoie dans la variable <b>x</b> un nombre al&eacute;atoire d&eacute;cimal compris entre 0 et 1.
+            </li>
+                
+            <li><b><font color="#990000"><b>int</b></font> n = random(1, 6);</b> Renvoie dans la variable <b>n</b> un nombre al&eacute;atoire entier entre 1 et 6.
+            </li>
+                
+            <li><b><font color="#990000"><b>boolean</b></font> y = equal("Dupond", "Dupont");</b> Compare les deux cha&icirc;nes de carat&egrave;res &laquo;&nbsp;Dupond&nbsp;&raquo; et &laquo;&nbsp;Dupont&nbsp;&raquo; et renvoie dans la variable <b>y</b> la valeur <b>false</b>.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> z = pow(x, 2);</b> Renvoie dans la variable <b>y</b> le carr&eacute; <b>x&sup2;</b>.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> x = sqrt(x);</b> Renvoie dans la variable <b>x</b> la racine de <b>x</b>.
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Fonctions de lecture/&eacute;criture:.</h2>
+         <ul class="ul">
+                
+            <li><b>clear();</b> Efface l&#8217;affichage.
+            </li>
+                
+            <li><b><font color="#990000"><b>String</b></font> prenom = readString();</b> Lit une cha&icirc;ne de carat&egrave;res dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b><font color="#990000"><b>int</b></font> age = readInteger();</b> Lit un nombre entier dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> taille = readDouble();</b> Lit un nombre d&eacute;cimal dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b>println("Oh");</b> Ecrit &laquo;Oh&raquo; dans la fen&ecirc;tre de sortie.
+            </li>
+                
+            <li><b>println("Oh," + age + " ans , est un bel &acirc;ge !");</b> Ecrit &laquo;&nbsp;Oh, 20 ans, est un bel &acirc;ge&nbsp;!&nbsp;&raquo; (quand age=20).
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Bloc de s&eacute;quences d'instructions.</h2> Un bloc se note entre <b>{ }</b> et englobe un ensemble de d&eacute;clarations et d'instructions s&eacute;par&eacute;es par un <b>;</b>.
+      </div>
+        
+      <div>
+         <h2>Op&eacute;rateurs.</h2>
+         <p>
+            <table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee" class="table">
+                   
+               <tr>
+                  <td valign="top"><tt>=</tt></td>
+                  <td valign="top">Affectation d'une valeur &agrave; une variable (ex: <b>x = 0;</b>)
+                  </td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>||</tt> <tt>&amp;&amp;</tt> <tt>!</tt></td>
+                  <td valign="top">Op&eacute;rateur logique OU, ET et NON</td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>==</tt> <tt>!=</tt> <tt>&lt;=</tt> <tt>&lt;</tt> <tt>&gt;=</tt> <tt>&gt;</tt> 
+                  </td>
+                  <td valign="top">Op&eacute;rateur &eacute;galit&eacute;, diff&eacute;rence et comparaison num&eacute;rique</td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>+</tt> <tt>-</tt> <tt>*</tt> <tt>/</tt> <tt>%</tt> 
+                  </td>
+                  <td valign="top">Addition, soustraction, multiplication, division, reste (appel&eacute; aussi modulo).</td>
+               </tr>
+                 
+            </table><br></p>
+      </div>
+        
+      <div>
+         <h2>Instruction conditionnelle.</h2>
+             
+         <div><b><font color="#990000"><b>if</b></font> (expressionBooleenne) { BlocD'InstructionsSiVrai } <font color="#990000"><b>else</b></font> { BlocD'InstructionsSiFaux }</b></div>
+             
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                               
+                           <div><font color="#990000"><b>if</b></font>(temp&eacute;rature&nbsp;&lt;&nbsp;15) {
+                           </div>
+                               
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"allumer chauffage"</font>);
+                           </div>
+                               
+                           <div>}&nbsp;<font color="#990000"><b>else</b></font>&nbsp;{
+                           </div>
+                               
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"ne rien faire"</font>);
+                           </div>
+                               
+                           <div>}</div>
+                             
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+        
+      <div>
+         <h2>Boucle.</h2>
+             
+         <div><b><font color="#990000"><b>while</b></font> (expressionBool&eacute;enne) { BlocD'Instructions }</b></div>
+             
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                            &nbsp;     
+                           <div><font color="#990000"><b>while</b></font>( n &lt; 10) {
+                           </div>
+                               &nbsp;&nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"Hello World !"</font>);
+                           </div>
+                               &nbsp;&nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              n = n + 1;
+                           </div>
+                           &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 
+                           <div>}</div>
+                              
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+         
+      <div>
+         <h2>D&eacute;claration de fonction.</h2>
+              
+         <div><b>TypeDuResultat NomDeLaFonction (TypeParametre1 NomParametre1, ...) { BlocD'Instructions }</b></div> 
+              
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                                  
+                           <div><font color="#990000"><b>int</b></font> max(int x, int y) {
+                           </div>
+                                  
+                           <div><font color="#990000"><b>if</b></font> (x &gt; y) {
+                           </div>
+                                &nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>return</b></font> x;
+                           </div> 
+                                  
+                           <div>}&nbsp;<font color="#990000"><b>else</b></font>&nbsp;{
+                           </div>     &nbsp;
+                                &nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>return</b></font> y;
+                           </div> 
+                                  
+                           <div>} }</div>
+                              
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+      
+   </body>
+</html>
\ No newline at end of file
Index: src/org/javascool/builder/LinkCheck.java
===================================================================
--- src/org/javascool/builder/LinkCheck.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/LinkCheck.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,151 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2005.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.builder;
+
+// Used in check the link
+import java.net.URI;
+import java.net.URL;
+
+// Used to cache the links
+import java.util.HashSet;
+import java.util.HashMap;
+
+// Used to patch href
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+import org.javascool.tools.FileManager;
+
+/** Permet de vérifier les liens cassés sur un site.
+ * @see <a href="LinkCheck.java.html">source code</a>
+ * @serial exclude
+ */
+public class LinkCheck {
+  private LinkCheck() {}
+
+  /** Lanceur du test des liens cassés.
+   * @param usage <tt>java org.javascool.tools.LinkCheck [-recursive] location</tt>
+   * <p>Teste les liens d'une adresse web, avec récursion à travers les sous-pages si besoin.</p>
+   */
+  public static void main(String usage[]) {
+    if(usage.length > 0)
+      check(usage[usage.length - 1], "-recursive".equals(usage[0]));
+  }
+  /** Teste les liens d'une adresse web et donne les liens cassés à la console.
+   * @param location L'adresse web à tester.
+   * @param recursive Si true, effectue récursion à travers les sous-pages.
+   *
+   * @throws IllegalArgumentException Si l'URL est mal formée.
+   */
+  public static void check(String location, boolean recursive) {
+    echoBroken("LINKCHECK: " + getRoot(location));
+    links = new HashSet<String>();
+    anchors = new HashMap<String, HashSet<String> >();
+    root = getRoot(location);
+    loop = recursive;
+    npages = nlinks = nbrokens = 0;
+    check(location);
+    echoBroken("  SCANNED PAGES: " + npages + " SCANNED LINKS: " + nlinks + " BROKENS LINKS: " + nbrokens);
+    links = null;
+    anchors = null;
+  }
+  private static HashSet<String> links;
+  private static HashMap<String, HashSet<String> > anchors;
+  private static String root;
+  private static boolean loop;
+  private static int npages, nlinks, nbrokens;
+  private static void check(String location) {
+    try {
+      String text = FileManager.load(location);
+      npages++;
+      for(String href : getLinks(text))
+        if(!href.matches("^(https|javascript|rtsp|mailto):.*$")) {
+          try {
+            href = new URL(new URL(location), href.replaceAll("%2e", ".")).toString();
+            if(!links.contains(href)) {
+              links.add(href);
+              nlinks++;
+              String anchor = null;
+              int i = href.indexOf("#");
+              if(i != -1) {
+                anchor = href.substring(i + 1);
+                href = href.substring(0, i);
+              }
+              if(!FileManager.exists(href))
+                echoBroken("BROKEN  Link in " + location + " -> " + href);
+              else {
+                if(loop && href.startsWith(root) && href.matches("^http:.*([?][^?]*|/|\\.(htm|html|shtml|php))$") && !href.matches("^.*\\.(xslt|java)"))
+                  check(href);
+                if(anchor != null) {
+                  if(!anchors.containsKey(href))
+                    anchors.put(href, getAnchorSet(FileManager.load(href)));
+                  if(!anchors.get(href).contains(anchor))
+                    echoBroken("BROKEN  Anchor in " + location + " -> " + href + " #" + anchor);
+                }
+              }
+            }
+          } catch(Exception e) {
+            echoBroken("SPURIOUS Link in " + location + " -> " + href + " (" + e + ") ");
+          }
+        }
+    } catch(Exception e) {
+      echoBroken("SPURIOUS   " + location + " (" + e + ") ");
+    }
+  }
+  private static String getRoot(String location) {
+    try { return new URI(location).normalize().toString();
+    } catch(Exception e) {
+      return location;
+    }
+  }
+  private static void echoBroken(String message) {
+    System.out.println(message);
+    nbrokens++;
+  }
+  /** Renvoie les ancres d'un texte HTML.
+   * <div> Ici les attributs  <tt>&lt;a href=..</tt> <tt>&lt;img src=..</tt> sont considérés comme des liens.</div>
+   */
+  public static String[] getLinks(String text) {
+    HashSet<String> h = new HashSet<String>();
+    for(int i = 0, l = text.length(); i < l;) {
+      Matcher matcher = linkPattern.matcher(text).region(i, l);
+      if(matcher.find()) {
+        int i1 = matcher.end(), i2 = nextQuote(text, i1);
+	String link = text.substring(i1, i2);
+	if (!link.startsWith("'"))
+	  h.add(link);
+        i = i2;
+      } else
+        break;
+    }
+    return h.toArray(new String[h.size()]);
+  }
+  /** Renvoie les ancres d'un texte HTML.
+   * <div> Ici les attributs <tt>&lt;a name=..</tt> et <tt>&lt; id=..</tt> sont considérés comme des ancres.</div>
+   */
+  public static String[] getAnchors(String text) {
+    HashSet<String> a = getAnchorSet(text);
+    return a.toArray(new String[a.size()]);
+  }
+  private static HashSet<String> getAnchorSet(String text) {
+    HashSet<String> a = new HashSet<String>();
+    for(int i = 0, l = text.length(); i < l;) {
+      Matcher matcher = anchorPattern.matcher(text).region(i, l);
+      if(matcher.find()) {
+        int i1 = matcher.end(), i2 = nextQuote(text, i1);
+        a.add(text.substring(i1, i2));
+        i = i2;
+      } else
+        break;
+    }
+    return a;
+  }
+  private static int nextQuote(String text, int i1) {
+    char c = text.charAt(i1 - 1);
+    int i2 = text.indexOf(c, i1);
+    return i2 == -1 ? text.length() : i2;
+  }
+  private static final Pattern linkPattern = Pattern.compile("(href|HREF|src|SRC)\\s*=\\s*[\"']");
+  private static final Pattern anchorPattern = Pattern.compile("<([aA]\\s+(name|NAME)|[^>]+(id|ID))\\s*=\\s*[\"']");
+}
Index: src/org/javascool/builder/hdoc2htm.xslt
===================================================================
--- src/org/javascool/builder/hdoc2htm.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/hdoc2htm.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,239 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sx="http://icl.com/saxon" extension-element-prefixes="sx">
+
+  <!-- This XSLT translates HML code to HTML 4 output -->
+
+<xsl:output 
+  method="html"
+  encoding="UTF-8"
+  doctype-public="-//W3C//DTD HTML 4.01//EN"
+  doctype-system="http://www.w3.org/TR/html4/strict.dtd"
+  indent="yes" />
+
+  <!-- This XSLT translates the proglet's HML documentation to HTML3.2 http://www.w3.org/TR/REC-html32-19970114) -->
+
+  <sx:function name="sx:jvs2htm" xmlns:jvs2htm="java:org.javascool.builder.Jvs2Html">
+    <xsl:param name="string"/>
+    <sx:return select="jvs2htm:run($string)"/>
+  </sx:function>
+  
+  <xsl:param name="output" select="'jvs'"/>
+
+<!-- These tags produce javasccool's doc specific constructs -->
+
+<xsl:template match="div|p">
+  <xsl:choose>
+    <xsl:when test="@class = 'sujet'">
+      <div align="right">
+        <xsl:if test ="count(intros) > 0">[<a href="#intros">introduction</a>]</xsl:if>
+        <xsl:if test ="count(works) > 0">[<a href="#works">travail proposé</a>]</xsl:if>
+        <xsl:if test ="count(notes) > 0">[<a href="#notes">remarques</a>]</xsl:if>
+      </div>
+      <xsl:call-template name="div"/>
+    </xsl:when>
+    <xsl:when test="@class = 'objectif'"><h2>Objectif.</h2><xsl:call-template name="div"/></xsl:when>
+    <xsl:when test="@class = 'intros' or @class = 'works' or @class = 'notes'">
+      <xsl:choose>
+        <xsl:when test="@class = 'intros'"><h2>Introduction.</h2></xsl:when>
+        <xsl:when test="@class = 'works'"><h2>Travail proposé.</h2></xsl:when>
+        <xsl:when test="@class = 'notes'"><h2>Remarques.</h2></xsl:when>
+      </xsl:choose>
+      <div id="{@class}"><ol><xsl:for-each select="*"><li><xsl:call-template name="div-2"/></li></xsl:for-each></ol></div>
+    </xsl:when>
+    <xsl:when test="@class = 'code'"><div class="code"><table witdh="90%" border="1" align="center"><tr><td><xsl:call-template name="div"/></td></tr></table></div></xsl:when>
+    <xsl:otherwise><xsl:call-template name="div"/></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template match="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'javascool'"><tt><a href="http://javascool.gforge.inria.fr" style="padding:0;margin:0;text-decoration:none">Java'sCool</a></tt></xsl:when>
+    <xsl:when test="@class = 'note'"><sup><a href="{concat('#', @link)}"><xsl:value-of select="@link"/></a></sup></xsl:when>
+    <xsl:when test="(@class = 'editor' or @class = 'newtab') and $output = 'jvs'"> 
+    <a href="{concat('http://',@class,'?', @link)}"><xsl:value-of select="@text"/></a>
+   </xsl:when>
+   <xsl:when test="@class = 'editor'"> 
+      <a class="{@class}" href="{concat(@link,'.html')}"><xsl:value-of select="@text"/></a>
+   </xsl:when>  
+   <xsl:otherwise><xsl:call-template name="l"/></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<!-- These tags performs the Jvs2Htm conversion -->
+
+<xsl:template match="code">
+  <div class="code"><table><tr><td>
+    <xsl:value-of disable-output-escaping="yes" select="sx:jvs2htm(.)"/>
+  </td></tr></table></div>
+</xsl:template>
+
+<!-- These tags allows to show pieces of code -->
+
+<xsl:template match="r">
+  <font color="#990000"><b><xsl:apply-templates/></b></font>
+</xsl:template>
+
+<xsl:template match="n">
+  <font color="#505000"><xsl:apply-templates/></font>
+</xsl:template>
+
+<xsl:template match="v">
+  <font color="#008000">&quot;<xsl:apply-templates/>&quot;</font>
+</xsl:template>
+
+<xsl:template match="m">
+  <p><tt><font color="#202080"><big>//</big>&#160;<xsl:apply-templates/></font></tt></p>
+</xsl:template>
+
+<xsl:template match="T">
+  &#160;&#160;&#160;
+</xsl:template>
+
+<!-- Here we manually include hml2htm.xslt to avoid file access -->
+
+<!-- 0 : Page production -->
+
+<xsl:template match="/*">
+  <html>
+    <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
+      <xsl:for-each select="@*"><xsl:choose>
+        <xsl:when test="name(.) = 'title'"><title><xsl:value-of select="."/></title></xsl:when>
+        <xsl:when test="name(.) = 'icon'"><link rel="shortcut icon" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'style'"><link rel="stylesheet" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'script'"><script type="text/javascript" src="{.}"/></xsl:when>
+        <xsl:otherwise><meta name="{name(.)}" content="{.}"/></xsl:otherwise> 
+        <!-- Possible improvement: take <meta http-equiv="$name" content="$value" /> or other <link rel="$name" href="$value" /> constructs into account !-->
+      </xsl:choose></xsl:for-each>
+    </head>
+    <body>
+      <xsl:if test="count(@title)=1"><h1><xsl:value-of select="@title"/>.</h1></xsl:if>
+      <xsl:apply-templates/>
+    </body>
+  </html>
+</xsl:template>
+
+<!-- 1 : Section production -->
+
+<xsl:template name="div">
+  <xsl:choose>
+    <xsl:when test="@class = 'table'">
+      <p><table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee"><xsl:call-template name="div-2"/></table><br/></p>
+    </xsl:when>
+    <xsl:when test="@class = 'ul' or @class = 'ol'">
+      <xsl:element name="{@class}"><xsl:call-template name="div-2"/></xsl:element>
+    </xsl:when>
+    <xsl:when test="../@class = 'ul' or ../@class = 'ol'"><li><xsl:call-template name="div-2"/></li></xsl:when>
+    <xsl:when test="../@class = 'table'"><tr><xsl:call-template name="div-2"/></tr></xsl:when>
+    <xsl:when test="../../@class = 'table'"><td valign="top"><xsl:call-template name="div-2"/></td></xsl:when>
+    <xsl:when test="@class = 'margin'"><div align="right"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'center'"><div align="center"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'tag'"><xsl:call-template name="tag"/></xsl:when>
+    <xsl:otherwise><div><xsl:call-template name="div-2"/></div></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+<xsl:template name="div-2">
+  <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@id)=1"><a name="{@id}"></a></xsl:if>
+  <xsl:if test="count(@title)=1"><xsl:choose>
+    <xsl:when test=".. = /"><h2><xsl:value-of select="@title"/>.</h2></xsl:when>
+    <xsl:when test="../.. = /"><h3><xsl:value-of select="@title"/>.</h3></xsl:when>
+    <xsl:when test="../../.. = /"><h4><xsl:value-of select="@title"/>.</h4></xsl:when>
+    <xsl:otherwise><b><xsl:value-of select="@title"/>.</b><xsl:text> </xsl:text></xsl:otherwise>
+  </xsl:choose></xsl:if>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- 1.1 : Pml construct description production -->
+
+<xsl:template name="tag"><table bgcolor="#eeeeee" width="90%">
+  <tr><td colspan="4"><b>{</b><xsl:text> </xsl:text><xsl:value-of select="@title"/></td></tr>
+  <tr><td align="center"><b>name</b></td><td align="center"><b>type</b></td><td align="center"><b>default value</b></td><td></td></tr>
+  <xsl:for-each select="param"><tr>
+     <td><font color="#505000"><xsl:value-of select="@name"/></font></td>
+     <td><font color="#990000"><xsl:value-of select="@type"/></font></td>
+     <td><xsl:choose>
+        <xsl:when test="count(@value)=1"><font color="#008000">"<xsl:value-of select="@value"/>"</font></xsl:when>
+        <xsl:otherwise><i>mandatory</i></xsl:otherwise>
+     </xsl:choose></td>
+     <td><xsl:apply-templates/></td>
+  </tr></xsl:for-each>
+  <tr><td colspan="4"><xsl:choose>
+    <xsl:when test="count(elements/@type) > 0">Structure: "<font color="#202080"><xsl:value-of select="elements/@type"/>"</font></xsl:when>
+    <xsl:otherwise><i>no element</i></xsl:otherwise>
+  </xsl:choose></td></tr>
+  <tr><td colspan="4"><hr/></td></tr>
+  <tr><td colspan="4">
+    <xsl:for-each select="*[name(.) != 'param' and name(.) != 'elements']"><xsl:apply-templates/></xsl:for-each>
+  </td></tr>
+  <tr><td colspan="4"><b>}</b></td></tr>
+</table></xsl:template>
+
+<!-- 2 : Span production -->
+
+<xsl:template match="s">
+  <span>
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </span>
+</xsl:template>
+<xsl:template match="b"><b><xsl:apply-templates/></b></xsl:template>
+<xsl:template match="i"><i><xsl:apply-templates/></i></xsl:template>
+<xsl:template match="c"><tt><xsl:apply-templates/></tt></xsl:template>
+<xsl:template match="S"><sup><xsl:apply-templates/></sup></xsl:template>
+<xsl:template match="I"><sub><xsl:apply-templates/></sub></xsl:template>
+
+<!-- 3 : Link production -->
+
+<xsl:template name="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'replace'"><script language="javascript">location.replace("<xsl:value-of select="@link"/>");</script></xsl:when>
+    <xsl:when test="@class = 'include'"><xsl:apply-templates select="document(@link)"/></xsl:when>
+    <xsl:when test="count(@link) = 1"><a href="{@link}"> 
+      <xsl:if test="count(@class)=1"><xsl:choose>
+        <xsl:when test="@class = 'newtab'"><xsl:attribute name="target">_blank</xsl:attribute></xsl:when>
+        <xsl:otherwise><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:otherwise>
+      </xsl:choose></xsl:if>
+      <xsl:if test="count(@icon) = 1"><img src="{@icon}" alt="{@text}"/></xsl:if>
+      <xsl:if test="count(@text)=1 and count(@icon)=1"><xsl:text> </xsl:text></xsl:if>
+      <xsl:if test="count(@text)=1"><xsl:value-of select="@text"/></xsl:if>
+      <xsl:if test="count(@text)=0 and count(@icon)=0">[.]</xsl:if>
+    </a></xsl:when>
+    <xsl:when test="count(@icon) = 1"><img src="{@icon}" alt="{@text}">
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    </img></xsl:when>
+    <xsl:when test="count(@text) = 1"><span>
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+      <xsl:value-of select="@text"/>
+    </span></xsl:when>
+  </xsl:choose>
+</xsl:template>
+
+<!--- 4: Code copy
+
+<xsl:template match="code">
+  <xsl:apply-templates mode ="code"/>
+</xsl:template>
+    
+<xsl:template match="*" mode="code"><xsl:text>
+</xsl:text>  
+  <xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+ -->
+ 
+<!--- 5: Spurious translation -->
+
+<xsl:template match="*"><xsl:text>
+</xsl:text>  
+<!--xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message-->
+<xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/package.html
===================================================================
--- src/org/javascool/builder/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1 @@
+<body>Ce package contient les mécanismes du moteur du JavaScool Builder.</body>
Index: src/org/javascool/builder/ProgletCreator.java
===================================================================
--- src/org/javascool/builder/ProgletCreator.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/ProgletCreator.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,153 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.builder;
+
+import java.io.File;
+import org.javascool.tools.FileManager;
+
+/** Cette factory contient les mécanismes de construction d'une nouvelle proglet.
+ * <h1>Ebauche non finalisée: ce mécanisme est au stade d'ébauche.</h1>
+ * @see <a href="ProgletCreator.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletCreator {
+  // @factory
+  private ProgletCreator() {}
+
+  /** Crée un répertoire et les fichiers de base de la proglet.
+   * @param location Emplacement de la proglet, le nom du répertoire correspond à celui de la proglet.
+   * @return La valeur true si la construction a pu se faire, false sinon.
+   *
+   * @throws IllegalArgumentException Si le nom de la proglet n'est pas un nom Java standard.
+   * @throws RuntimeException Si il y a eu une erreur d'entrée sortie lors de la création.
+   */
+  public static boolean mkdirProglet(String location) {
+    String name = new File(location).getName();
+    if(!name.matches("[a-z][a-zA-Z][a-zA-Z][a-zA-Z]+")) {
+      System.out.println("Le nom de la proglet «" + name + "» est bizarre: \n il ne doit contenir que des lettres, faire au moins quatre caractères, et démarrer par une minuscule.");
+      System.out.println("Impossible de créer une telle proglet");
+      return false;
+    }
+    if(new File(location).isDirectory())
+      System.out.println("Le répertoire «" + location + "» existe déjà, les fichiers existants seront renommés");
+    if((!new File(location).isDirectory()) && !new File(location).mkdirs()) {
+      String tail = new File(location).exists() ? "un fichier existe à cet emplacement" : "il doit être interdit de créer le répertoire ici";
+      System.out.println("Impossible de créer le répertoire «" + location + "» de la proglet, " + tail);
+    }
+    FileManager.save(location + File.separator + "proglet.pml", progletPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "help.xml", helpPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Panel.java", panelPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Functions.java", functionsPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "completion.xml", completionPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Translator.java", translatorPattern.replaceAll("@name", name), true);
+    System.out.println("La proglet «" + name + "» est crée dans " + location);
+    return true;
+  }
+  private static final String progletPattern =
+   "title=\"Exemple de «proglet»\"\n" +
+   "author=\"Prenom Nom<email@serveur.com>\"\n" +
+   "icon=\"sample.png\"\n";
+  private static final String helpPattern =
+    "<div title=\"La «proglet» @name\">\n" +
+    "  <div class=\"objectif\">\n" +
+    "  </div>\n" +
+    "  <div class=\"intros\">\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "  <div class=\"works\">\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "  <div class=\"notes\">\n" +
+    "   <!-- référencées par des tags de la forme <l class=\"note\" link=\"1\"/> -->\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "</div>\n";
+  private static final String panelPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "import static org.javascool.macros.Macros.*;\n" +
+    "import static org.javascool.proglets.@name.Functions.*;\n" +
+    "import javax.swing.JPanel;\n" +
+    "\n" +
+    "/** Définit le panneau graphique de la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Panel.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Panel extends JPanel /* ou tout autre Component pertinent. */ {\n" +
+    "\n" +
+    "  // @bean\n" +
+    " public Panel() {" +
+    "  // @"+"todo Définir ici la construction de l'objet graphique\n" +
+    "  }\n" +
+    "\n" +
+    "  /** Démo de la proglet. */\n" +
+    "  public void start() {\n" +
+    "  // @"+"todo Définir ici le code de démo de la proglet.\n" +
+    "  }\n" +
+    "\n" +
+    "}\n";
+  private static final String functionsPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "import static org.javascool.macros.Macros.*;\n" +
+    "\n" +
+    "/** Définit les fonctions pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Functions.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Functions {\n" +
+    "  private static final long serialVersionUID = 1L;\n" +
+    "  // @factory\n" +
+    "  private Functions() {}\n" +
+    "  /** Renvoie l'instance de la proglet pour accéder à ses éléments.\n" +
+    "   * <p> Utilisé dans une construction de type <tt>getPane().appelDeMethode(..)</tt>.</p>\n" +
+    "   */\n" +
+    "  private static Panel getPane() {\n" +
+    "     return getProgletPane();\n" +
+    "  }\n" +
+    "\n" +
+    "  //@"+"todo Définir ici les fonctions <tt>public static</tt>\n" +
+    "\n" +
+    "}\n";
+
+  private static final String completionPattern =
+    "<keywords>\n" +
+    "  <keyword \n" +
+    "    name=\"nom de la complétion\" \n" +
+    "    title=\"description en ligne\">\n" +
+    "    <code>texte source de la complétion</code>\n" +
+    "    <doc>Texte qui documente la fonction de l'on complète</doc>\n" +
+    "  </keyword>\n" +
+    "  <!-- autres keyword -->\n" +
+    "</keywords>\n";
+
+
+  private static final String translatorPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "\n" +
+    "/** Définit la traduction d'un code Jvs en code Java  pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Translator.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Translator extends org.javascool.core.Translator {\n" +
+    "    @Override\n" +
+    "     public String getImports() {\n" +
+    "    return \"\";\n" +
+    "  }\n" +
+    "    @Override\n" +
+    "  public String translate(String code) {\n" +
+    "    return code;\n" +
+    "  }\n" +
+    "}\n";
+}
Index: src/org/javascool/builder/ProgletsBuilder.java
===================================================================
--- src/org/javascool/builder/ProgletsBuilder.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/ProgletsBuilder.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,488 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.builder;
+
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Xml2Xml;
+import org.javascool.tools.Pml;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+import java.util.ArrayList;
+import java.util.Date;
+import org.javascool.Core;
+import org.javascool.About;
+
+/** Cette factory contient les mécanismes de construction d'une application Java's Cool avec des proglets.
+ *
+ * @see <a href="ProgletsBuilder.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletsBuilder {
+    /** Définit le file separator dans une expression régulière. */
+    private static final String fileRegexSeparator = File.separator.equals("\\") ? "\\\\" : File.separator;
+
+    // @factory
+    private ProgletsBuilder() {
+    }
+
+    /** Définit si la construction se fait avec tous les messages intermédiaires. */
+    public static void setVerbose(boolean v) {
+        verbose = v;
+    }
+    static boolean verbose = false;
+    /** Teste si cette version de Java'sCool a la capacité de créer des jar.  */
+    public static boolean canBuildProglets() {
+        try {
+            Class.forName("com.icl.saxon.TransformerFactoryImpl");
+            return true;
+        } catch (Throwable e) {
+            return false;
+        }
+    }
+
+    /** Renvoie les proglets à construire. 
+     * @param names Noms ou suffixes des proglets à sélectionner.
+     * @return La liste des noms absolus des répertoires des proglets trouvées
+     */
+    public static String[] getProglets(String[] names) {
+        ArrayList<String> proglets = new ArrayList<String>();
+         for (String dir : FileManager.list(System.getProperty("user.dir"))) {
+            if (FileManager.exists(dir + File.separator + "proglet.pml")) {
+	      boolean found = names == null;
+	      if (names != null)
+		for(String name : names) 
+		  found |= dir.endsWith(name);
+	      if (found)
+                proglets.add(dir);
+            }
+            }
+        return proglets.toArray(new String[proglets.size()]);
+    }
+   /**
+    * @see #getProglets(String[])
+    */
+    public static String[] getProglets() {
+      return getProglets(null);
+    }
+    /** Construit une nouvelle archive avec les proglets proposées.
+     * @param proglets Les proglets sélectionnées. Par défaut toutes les proglets disponibles.
+     * @param targetDir Le répertoire cible dans lequel la construction se fait. Si null utilise un répertoire temporaire.
+     * @param webdoc Si true compile la javadoc et les jars de chaque proglet (false par défaut).
+     * @return La valeur true si la construction est sans erreur, false sinon.
+     */
+    public static boolean build(String[] proglets, String targetDir, boolean webdoc) {
+        if (!canBuildProglets()) {
+            throw new IllegalArgumentException("Mauvaise configuration du builder, il faut utiliser le bon jar !");
+        }
+        try {
+            if (proglets.length == 0) {
+                throw new IllegalArgumentException("Aucune proglet à construire");
+            }
+            // Définition de la jarre cible.
+            String targetJar = System.getProperty("user.dir") + File.separator + "javascool-proglets.jar";
+            new File(targetJar).delete();
+            log("Scan des proglets à partir du répertoire: " + System.getProperty("user.dir"));
+            // Installation du répertoire de travail.
+            File buildDir;
+            String jarDir, progletsDir;
+            // Création des répertoires cible.
+            {
+                if (targetDir == null) {
+                    buildDir = new File(".build");
+                } else {
+                    buildDir = new File(targetDir);
+                    if (new File(".").equals(buildDir.getCanonicalFile())) {
+                        throw new IllegalArgumentException("Le répertoire des proglets et celui du build ne peuvent pas être identiques");
+                    }
+                }
+		JarManager.rmDir(buildDir);
+		buildDir.mkdirs();
+                jarDir = buildDir + File.separator + "jar";
+                progletsDir = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "proglets";
+                new File(progletsDir).mkdirs();
+            }
+            DialogFrame.setUpdate("Installation 1/2", 10);
+            // Expansion des classes javascool et des proglets existantes dans les jars
+            {
+                log("Extraction des Jars du sketchbook", true);
+                // Expansion des jars du sketchbook
+                for (String jar : FileManager.list(System.getProperty("user.dir"), ".*\\.jar")) {
+                    if (!jar.matches(".*" + fileRegexSeparator + "javascool-(builder|proglets).jar")) {
+                        JarManager.jarExtract(jar, jarDir);
+                    }
+                }
+                // Expansion des jars des proglets
+                for (String proglet : proglets) {
+                    for (String jar : FileManager.list(proglet, ".*\\.jar", 2)) {
+                        JarManager.jarExtract(jar, jarDir);
+                    }
+                }
+                // Expansion des jars de javascool
+                String javascoolJar = Core.javascoolJar();
+                log("Extraction de Java's cool", true);
+                String libs[] = {"org/javascool", "org/fife", "com/sun/tools/javac", "sun/tools/java", "com/sun/source/tree", "com/sun/source/util"};
+                for(String lib : libs)
+                  JarManager.jarExtract(javascoolJar, jarDir,lib);
+            }
+            DialogFrame.setUpdate("Installation 2/2", 20);
+            Integer level = 20;
+            int up = (10 / proglets.length == 0 ? 1 : 10 / proglets.length);
+            // Construction des proglets
+            for (String proglet : proglets) {
+                ProgletBuild build = new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir);
+                String name = new File(proglet).getName();
+                log("Compilation de " + name + " ...");
+                    DialogFrame.setUpdate("Construction de " + name + " 1/4", level += up);
+                    build.copyFiles();
+                    DialogFrame.setUpdate("Construction de " + name + " 2/4", level += up);
+                    build.checkProglet();
+                    DialogFrame.setUpdate("Construction de " + name + " 3/4", level += up);
+                    build.convertHdocs(false);
+                if (!build.isprocessing) {
+                    DialogFrame.setUpdate("Construction de " + name + " 4/4", level += up);
+                    build.createHtmlApplet();
+                    if (webdoc)
+                        build.javadoc(jarDir);
+                }
+            }
+            // Lancement de la compilation de tous les java des proglets
+            {
+                log("Compilation des fichiers java");
+                String[] javaFiles = FileManager.list(progletsDir, ".*\\.java", 2);
+                if (javaFiles.length > 0)
+		  javac(jarDir, javaFiles);
+            }
+            DialogFrame.setUpdate("Finalisation 1/2", 90);
+            System.out.println("Compilation des jarres .. ");
+            // Création des jarres avec le manifest
+            {
+                String version = "Java'sCool v4 on \"" + new Date() + "\" Revision #" + About.revision;
+                Pml manifest = new Pml().set("Main-Class", "org.javascool.Core").
+                        set("Manifest-version", version).
+                        set("Created-By", "inria.fr (javascool.gforge.inria.fr) ©INRIA: CeCILL V2 + CreativeCommons BY-NC-ND V2").
+                        set("Implementation-URL", "http://javascool.gforge.inria.fr").
+                        set("Implementation-Vendor", "javascool@googlegroups.com, ou=javascool.gforge.inria.fr, o=inria.fr, c=fr").
+                        set("Implementation-Version", version).
+                        save(buildDir + "/manifest.jmf");
+                // Création des archives pour chaque proglet
+                if (webdoc) {
+                    for (String proglet : proglets) {
+                        String name = new File(proglet).getName();
+                        String javascoolPrefix = "org" + File.separator + "javascool" + File.separator;
+                        String jarEntries[] = {
+                            javascoolPrefix + "Core", javascoolPrefix + "About", "org" + File.separator + "fife",
+                            javascoolPrefix + "builder", javascoolPrefix + "core", javascoolPrefix + "gui", javascoolPrefix + "macros", javascoolPrefix + "tools", javascoolPrefix + "widgets",
+                            javascoolPrefix + "proglets" + File.separator + name};
+                        String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
+                        JarManager.jarCreate(tmpJar, buildDir + "/manifest.jmf", jarDir, jarEntries);
+			// Reconstruction des pages webs en mode web
+			new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir).convertHdocs(true);
+                    }
+                }
+                // Création de l'archive principale
+                JarManager.jarCreate(targetJar, buildDir + "/manifest.jmf", jarDir);
+                // Signature et déplacement des "javascool-proglet-"+name+".jar" dans les répetoires des proglets
+                if (webdoc) {
+                    System.out.print("Signature des jarres: ");
+                    System.out.flush();
+                    for (String proglet : proglets) {
+                        String name = new File(proglet).getName();
+                        String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
+                        String signedJar = progletsDir + File.separator + name + File.separator + "javascool-proglet-" + name + ".jar";
+                        if (new File(signedJar).getParentFile().exists()) {
+                            System.out.print(name + " .. ");
+                            String keystore = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "builder" + File.separator + "javascool.key";
+                            String args = "-storepass\tjavascool\t-keypass\tmer,d,azof\t-keystore\t" + keystore + "\t-signedjar\t" + signedJar + "\t" + tmpJar + "\tjavascool";
+                            sun.security.tools.JarSigner.main(args.split("\t"));
+
+                        }
+                    }
+                    System.out.println("ok.");
+                }
+                DialogFrame.setUpdate("Finalisation 2/2", 100);
+            }
+            if (targetDir == null) {
+	      // JarManager.rmDir(buildDir);
+            }
+            System.out.println("Construction achevée avec succès: «" + targetJar + "» a été créé");
+            System.out.println("\tIl faut lancer «" + targetJar + "» pour tester/utiliser les proglets.");
+            return true;
+        } catch (Exception e) {
+            e.printStackTrace(System.err);
+            System.out.println("Erreur inopinée lors de la construction (" + e.getMessage() + "): corriger l'erreur et relancer la construction");
+            return false;
+        }
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets, String targetDir) {
+        return build(proglets, targetDir, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets, boolean webdoc) {
+        return build(proglets, null, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String targetDir, boolean webdoc) {
+        return build(getProglets(), targetDir, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets) {
+        return build(proglets, null, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String targetDir) {
+        return build(getProglets(), targetDir, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(boolean webdoc) {
+        return build(getProglets(), null, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build() {
+        return build(getProglets(), null, false);
+    }
+
+    /** Lance la compilation java sur un groupe de fichiers. */
+  private static void javac(String classPath, String[] javaFiles) {
+    // if (!Java2Class.compile(javaFiles, true)) throw new IllegalArgumentException("Erreur de compilation java");
+    try {
+      // Appel au compilateur en spécifiant le classpath
+      String args[] = new String[javaFiles.length + 3];
+      args[0] = "-cp";
+      args[1] = classPath;
+      args[2] = "-Xlint";
+      System.arraycopy(javaFiles, 0, args, 3, javaFiles.length);
+      	 StringWriter out = new StringWriter();
+	 Class.forName("com.sun.tools.javac.Main").
+	   getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter")).
+	   invoke(null, (Object) args, new PrintWriter(out));
+         String sout = out.toString().trim();
+         if (sout.length() > 0) {
+           System.out.println("Erreur de compilation java:\n" + sout);
+	   throw new IllegalArgumentException("Erreur de compilation java");
+        }
+    } catch(Throwable e) {
+      System.err.println("Echec de compilation :"+ e);
+	throw new IllegalArgumentException("Erreur de compilation java");
+    }
+  }
+
+    /** Construction de javadoc avec sources en java2html. */
+    private static void javadoc(String name, String classPath, String srcDir, String apiDir) throws IOException {
+        apiDir = new File(apiDir).getCanonicalPath();
+        new File(apiDir).mkdirs();
+        String files[] = FileManager.list(srcDir, ".*\\.java$");
+        if (files.length > 0) {
+            {
+                // Construit l'appel à javadoc
+                String argv = "-quiet\t-classpath\t" + classPath + "\t-d\t" + apiDir
+		  + "\t-link\thttp://download.oracle.com/javase/6/docs/api"
+		  + "\t-public\t-author\t-windowtitle\tJava's Cool v4\t-doctitle\tJava's Cool v4\t-version\t-nodeprecated\t-nohelp\t-nonavbar\t-notree\t-charset\tutf-8";
+                for (String f : files) {
+                    argv += "\t" + f;
+                }
+                // Lance javadoc
+                try {
+                    com.sun.tools.javadoc.Main.execute(argv.split("\t"));
+                } catch (Throwable e) {
+                    throw new IOException(e);
+                }
+            }
+            // Construit les sources en HTML à partir de java2html
+            {
+                // Lance java2html
+                Jvs2Html.runDirectory(srcDir, apiDir + File.separator + "org" +  File.separator + "javascool" +  File.separator + "proglets"  +  File.separator + name);
+            }
+        }
+    }
+
+    /** Envoie un message de log dans la console.
+     * @param text Le message
+     * @param onlyVerbose Ne s'affiche que si l'option -v est activé
+     */
+    public static void log(String text, boolean onlyVerbose) {
+        if (onlyVerbose) {
+            if (verbose) {
+                System.out.println(text);
+            }
+        } else {
+            System.out.println(text);
+        }
+    }
+
+    /** Imprime un message dans la console
+     * @see ProgletsBuilder#log(java.lang.String, boolean) 
+     */
+    public static void log(String text) {
+        log(text, false);
+    }
+
+    /** Contôleur pour la compilation d'une proglet. */
+    private static class ProgletBuild {
+
+        /** Le nom de la proglet */
+        private String name;
+        /** Le répertoire de la proglet à compiler */
+        private String progletSrc;
+        /** Le répertoire de la proglet compilée */
+        private String progletDir;
+        /** Le fichier Pml d'information de la proglet */
+        private Pml pml;
+        /** Le dossier du jar final */
+        private String jarDest;
+        /** Vrai si la proglet est processing */
+        private boolean isprocessing;
+
+        /** Crée un nouveau contôleur pour la compilation d'une proglet.
+         * @param name Le nom de la proglet
+         * @param progletDir Le répertoire de la proglet à compiler
+         * @param pml Le fichier Pml d'information de la proglet
+         * @param jarDest Le dossier du jar final
+         */
+        public ProgletBuild(String name, String progletDir, Pml pml, String jarDest) {
+            this.name = name = name != null ? new File(name).getName() : "?";
+            this.pml = pml = pml != null ? pml : new Pml().load(progletDir + File.separator + "proglet.pml");
+            try {
+	      this.progletSrc = progletDir != null ? new File(progletDir).getAbsolutePath() : "";
+            } catch (Exception e) {
+                throw new RuntimeException("Le dossier source de " + name + " n'existe pas");
+            }
+            this.jarDest = jarDest = jarDest != null ? new File(jarDest).getAbsolutePath() : "";
+            this.progletDir = jarDest + "/org/javascool/proglets/".replace("/", File.separator) + name;
+            this.isprocessing = pml.getBoolean("processing");
+	}
+
+        /** Lit automatiquement le fichier Pml
+         * @see ProgletBuild#ProgletBuild(java.lang.String, java.lang.String, org.javascool.tools.Pml, java.lang.String) 
+         */
+        public ProgletBuild(String name, String progletDir, String jarDest) {
+            this(name, progletDir, null, jarDest);
+        }
+
+        /** Copie les fichiers de la proglet de la source à la destination. */
+        public void copyFiles() {
+            log("Copie des fichiers de " + name, true);
+            try {
+                new File(progletDir).mkdirs();
+                JarManager.copyFiles(progletSrc, progletDir);
+            } catch (IOException ex) {
+                throw new RuntimeException("Erreur lors de la copie des fichiers de " + name, ex);
+            }
+            // Efface les répertoires applet et les jar dans la cible
+            {
+                JarManager.rmDir(new File(progletDir, "applet"));
+                for (String jar : FileManager.list(progletDir, ".*\\.jar"))
+                    new File(jar).delete();
+            }
+        }
+        /** Vérifie si la proglet respect les specifications */
+        public void checkProglet() {
+            log("Vérification de la proglet " + name, true);
+            boolean error = false;
+            if (!(name.matches("[a-zA-Z][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+") && name.length() <= 20)) {
+                System.out.println("Le nom de la proglet «" + name + "» est bizarre:"+
+				   " il ne doit contenir que des lettres faire au moins quatre caractères et au plus seize et démarrer par une lettre minuscule");
+                error = true;
+            }
+            if (!FileManager.exists(progletDir + File.separator + "help.xml")) {
+                System.out.println("Pas de fichier d'aide pour " + name + ", la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (FileManager.exists(progletDir + File.separator + "completion.xml")) {
+                String err = Xml2Xml.run(FileManager.load(progletDir + File.separator + "completion.xml"),
+                        FileManager.load(jarDest + "/org/javascool/builder/completionok.xslt".replace("/", File.separator))).trim();
+                if (err.length() > 0) {
+                    System.out.println("Il y a une erreur dans le fichier completion.xml : «" + err.replaceAll("\\s+", " ") + "», la proglet ne sera pas construite.");
+                    error = true;
+                }
+            }
+            if (!pml.isDefined("author")) {
+                System.out.println("Le champ «author» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (!pml.isDefined("title")) {
+                System.out.println("Le champ «title» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (isprocessing && !(pml.isDefined("width") && pml.isDefined("height"))) {
+                System.out.println("Les champ «width» et «height» ne sont pas définis dans " + name + "/proglet.pml, la proglet processing ne sera pas construite.");
+                error = true;
+            }
+            pml.save(progletDir + File.separator + "proglet.php");
+            if (error) {
+                throw new IllegalArgumentException("La proglet ne respecte pas les spécifications");
+            }
+        }
+
+        /** Convertit les XML en HTM, sauf le completion.xml. */
+        public void convertHdocs(boolean webdoc) {
+            log("Convertion des HDocs pour " + name, true);
+            for (String doc : FileManager.list(progletDir, ".*\\.xml"))
+	      if (!new File(doc).getName().equals("completion.xml")) {
+		try {
+		  log("Convertion de " + new File(doc).getName(), true);
+		  // Conversion des pages hdoc pour le web
+		  FileManager.save(doc.replaceFirst("\\.xml", "\\.htm"),
+				   Xml2Xml.run(FileManager.load(doc, true),
+					       FileManager.load(jarDest + "/org/javascool/builder/hdoc2htm.xslt".replace("/", File.separator)),
+					       "output", webdoc ? "web" : "jvs"), false, true);
+		} catch (IllegalArgumentException e) {		  throw new IllegalArgumentException("dans " + new File(doc).getName() + " : " + e.getMessage());
+		}
+                }
+            // Construit les sources exemples en HTML à partir de java2html
+            {
+                // Lance java2html
+                Jvs2Html.runDirectory(progletDir, progletDir);
+            }
+        }
+
+        /** Crée la page html de l'applet de la proglet */
+        public void createHtmlApplet() {
+            log("Création de l'applet HTML pour " + name, true);
+            FileManager.save(progletDir + File.separator + "applet-tag.htm",
+                    "<applet width='560' height='620' code='org.javascool.widget"
+                    + "s.PanelApplet' archive='./proglets/" + name + "/javascool"
+                    + "-proglet-" + name + ".jar'><param name='panel' value='org"
+                    + ".javascool.proglets." + name + ".Panel'/><pre>Impossible "
+                    + "de lancer " + name + ": Java n'est pas installé ou mal co"
+                    + "nfiguré</pre></applet>\n");
+        }
+
+        /** Génère la javadoc de la proglet */
+        public void javadoc(String classPath) {
+            try {
+                log("Création de la javadoc pour " + name, true);
+                ProgletsBuilder.javadoc(name, classPath, progletDir, progletDir + File.separator + "api");
+            } catch (IOException ex) {                throw new RuntimeException("Erreur lors de la génération de la javadoc");
+            }
+        }
+    }
+}
Index: src/org/javascool/builder/completionok.xslt
===================================================================
--- src/org/javascool/builder/completionok.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/completionok.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sx="http://icl.com/saxon" extension-element-prefixes="sx">
+
+<xsl:output 
+  method="text"
+  encoding="UTF-8"/>
+
+<!-- A la racine: il faut le tag keywords -->
+
+<xsl:template match="/">
+  <xsl:apply-templates select="*[not (name(.) = 'keywords')]" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- keywords : ne doit contenir que (0 à n) keyword -->
+
+<xsl:template match="keywords">
+  <xsl:apply-templates select="@*|*[not (name(.) = 'keyword')]|text()" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- keyword doit contenir les attributs name et title et les elements code et doc (optionel) -->
+
+<xsl:template match="keyword">
+  <xsl:if test="count(@name) = 0"><xsl:call-template name="no-attribute"><xsl:with-param name="name" select="'name'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(@title) = 0"><xsl:call-template name="no-attribute"><xsl:with-param name="name" select="'title'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(code) = 0"><xsl:call-template name="no-element"><xsl:with-param name="name" select="'code'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(doc) = 0"><xsl:call-template name="no-element"><xsl:with-param name="name" select="'doc'"/></xsl:call-template></xsl:if>
+  <xsl:apply-templates select="@*[not (name(.) = 'name' or name(.) = 'title')]" mode="error"/>
+  <xsl:apply-templates select="*[not (name(.) = 'doc' or name(.) = 'code')]|text()" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- doc|code ne doivent contenir que du texte -->
+
+<xsl:template match="code|doc">
+  <xsl:apply-templates select="@*|*" mode="error"/>
+</xsl:template>
+
+<!-- Skip des espaces et affichage des erreurs -->
+
+<xsl:template match="text()"/>
+
+<xsl:template name="no-attribute">
+  <xsl:param name="name"/>
+  [Missing attribute: <xsl:value-of select="$name"/>]
+</xsl:template>
+
+<xsl:template name="no-element">
+  <xsl:param name="name"/>
+  [Missing element: <xsl:value-of select="$name"/>]
+</xsl:template>
+
+<xsl:template match="*" mode="error">
+  [Unexpected tag: <xsl:value-of select="name(.)"/>]
+</xsl:template>
+
+<xsl:template match="text()" mode="error">
+  <xsl:if test="not (normalize-space(.) = '')">
+    [Unexpected text: "<xsl:value-of select="."/>"]
+  </xsl:if>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/Htm2Hml.java
===================================================================
--- src/org/javascool/builder/Htm2Hml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/Htm2Hml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,57 @@
+package org.javascool.builder;
+
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import javax.swing.JToolBar;
+import javax.swing.Box;
+import javax.swing.JLabel;
+import javax.swing.JButton;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+import java.awt.Color;
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Xml2Xml;
+
+/** Calculette de conversion de HTML en HML. */
+public class Htm2Hml extends JPanel {
+  private JTextArea htm, hml;
+  public Htm2Hml() {
+    setLayout(new BorderLayout());
+    JToolBar b = new JToolBar();
+    b.setFloatable(false);
+    b.add(new JLabel("Traduction de [X]HTML en HML (coller le HTML à gauche et copié le HML à droite)"));
+    b.add(Box.createHorizontalGlue());
+    b.add(new JButton("[Traduire]") {
+	{
+	  addActionListener(new ActionListener() {
+	      private static final long serialVersionUID = 1L;
+	      @Override
+		public void actionPerformed(ActionEvent e) {
+		translate();
+	      }});
+	}});
+    add(b, BorderLayout.NORTH);
+    JPanel c = new JPanel();
+    c.add(new JScrollPane(htm = new JTextArea(40, 64)));
+    c.add(new JScrollPane(hml = new JTextArea(40, 64) {
+	private static final long serialVersionUID = 1L;
+	{
+	  setBackground(new Color(200, 200, 200));
+	  setEditable(false);
+	}
+      }));
+    add(c, BorderLayout.CENTER);
+    // Just to test
+    htm.setText("<div>\n<div><img src='ok.png'></div>\n<hr>\n</div>");
+  }
+  private void translate() {
+    hml.setText(Xml2Xml.html2xhtml(htm.getText()));
+    try {
+      hml.setText(Xml2Xml.run(hml.getText(), FileManager.load("org/javascool/builder/htm2hml.xslt")));
+    } catch(Exception e) {
+      System.out.println("Impossible de traduire le HTML en HML: "+e);
+    }
+  }
+}
Index: src/org/javascool/builder/Jvs2Html.java
===================================================================
--- src/org/javascool/builder/Jvs2Html.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/Jvs2Html.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,80 @@
+package org.javascool.builder;
+
+import de.java2html.converter.JavaSource2HTMLConverter;
+import de.java2html.javasource.JavaSource;
+import de.java2html.javasource.JavaSourceParser;
+import de.java2html.javasource.JavaSourceType;
+import de.java2html.options.JavaSourceConversionOptions;
+import de.java2html.options.JavaSourceStyleEntry;
+import de.java2html.util.RGB;
+import java.io.File;  
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import org.javascool.tools.FileManager;
+
+/** Convertit une portion de source Java ou Jvs en Html colorisé.
+ * <p>Note: utilise une version patchée de <a href="http://www.java2html.de">java2html</a>, disponible dans <a href="http://code.google.com/p/javascool/source/browse/work/lib/jvs2html.jar">jvs2html.jar</a>, qui doit être dans le CLASSPATH.</p></p>
+ *
+ * @see <a href="Jvs2Html.java.html">code source</a>
+ * @serial exclude
+ */
+public class Jvs2Html {
+    // @factory
+
+    private Jvs2Html() {
+    }
+
+    /** Convertit une portion de source Java ou JVs en Html colorisé..
+     * @param code Le code Java ou Jvs.
+     * @return Le code Html généré.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'éxecution.
+     */
+    public static String run(String code) {
+        try {
+            StringReader stringReader = new StringReader(code);
+            JavaSource source = new JavaSourceParser().parse(stringReader);
+            JavaSource2HTMLConverter converter = new JavaSource2HTMLConverter();
+            JavaSourceConversionOptions options = JavaSourceConversionOptions.getDefault();
+            options.getStyleTable().put(JavaSourceType.KEYWORD, new JavaSourceStyleEntry(RGB.ORANGE, true, false));
+            StringWriter writer = new StringWriter();
+            converter.convert(source, options, writer);
+            return "<pre>"+writer.toString().replace("\n", "").replace("<br/>", "\n").replace("&#160;&#160;&#160;&#160;", "\t") +"</pre>";
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when converting: «" + code + "»");
+        }
+    }
+
+    /** Convertit un répertoire de source Java vers un autre répertoire en source HTML Colorisé.
+     * @param srcDir Le répertoire source
+     * @param destDir Le répertoire de destination
+     * @return true si la convertion a réussit
+     * @throws RuntimeException si il y a une erreur durant la convertion
+     */
+    public static boolean runDirectory(String srcDir, String destDir) {
+        try {
+            File src = new File(srcDir);
+            File dest = new File(destDir);
+            String[] fileList = FileManager.list(srcDir);
+            for (String file : fileList) {
+                if (file.endsWith(".java") || file.endsWith(".jvs") ) {
+                    FileManager.save(dest.getCanonicalPath() + File.separator + new File(file).getName() + ".html", Jvs2Html.run(FileManager.load(file)));
+                }
+            }
+            return true;
+        } catch (Exception e) {
+            throw new RuntimeException(e + " when converting: «" + srcDir + "»");
+        }
+    }
+
+    /** Lanceur de la conversion d'une portion de source Java ou Jvs en Html colorisé.
+     * @param usage <tt>java org.javascool.builder.Jvs2Html input-file [output-file]</tt>
+     */
+    public static void main(String[] usage) {
+        // @main
+        if (usage.length > 0) {
+            FileManager.save(usage.length > 1 ? usage[1] : "stdout:", run(FileManager.load(usage[0])));
+        }
+    }
+}
Index: src/org/javascool/builder/DialogFrame.java
===================================================================
--- src/org/javascool/builder/DialogFrame.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/DialogFrame.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,175 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.builder;
+
+import org.javascool.widgets.MainFrame;
+import javax.swing.JPopupMenu;
+import javax.swing.JLabel;
+import javax.swing.JCheckBox;
+import javax.swing.JMenuItem;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.File;
+import org.javascool.widgets.Console;
+import javax.swing.JProgressBar;
+import java.util.ArrayList;
+import javax.swing.JButton;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import org.javascool.About;
+import org.javascool.Build;
+
+/** Définit l'interface graphique pour la construction de proglets.
+ *
+ * @see <a href="DialogFrame.java.html">code source</a>
+ * @serial exclude
+ */
+public class DialogFrame {
+
+    /** Ouvre une console indépendante pour lancer la construction de proglets. */
+    public static void startFrame() {
+
+        jCreatorButton=Console.getInstance().getToolBar().addTool("Créer une nouvelle proglet", "org/javascool/widgets/icons/new.png",
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        startProgletCreatorMenu();
+                    }
+                });
+        jBuilderButton=Console.getInstance().getToolBar().addTool("Lancement du builder", "org/javascool/widgets/icons/compile.png",
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        startProgletBuilderMenu();
+                    }
+                });
+        Console.getInstance().getToolBar().addTool("Progress Bar", jProgressBar = new JProgressBar());
+        jProgressBar.setSize(new Dimension(100, 25));
+        Console.getInstance().getToolBar().addTool("Status Bar", jLabel = new JLabel());
+        Console.getInstance().getToolBar().addRightTool("Convertisseur HML",  new Runnable() {
+
+                    @Override
+                    public void run() {
+		      startConvertisseurHML();
+                    }
+                });
+        Console.getInstance().getToolBar().addRightTool(About.getAboutMessage());
+        setUpdate("", 0);
+        new MainFrame().reset("Java's Cool 4 Proglet Buidler", Build.logo, Console.getInstance());
+    }
+
+    /** Met à jour la progression de la construction.
+     * @param statut Statut sur l'opération en cours. Un message de 64 caractères max.
+     * @param percent Pourcentage de complétion entre 0 et 100.
+     */
+    public static void setUpdate(String statut, int percent) {
+        while (statut.length() < 64) {
+            statut += " ";
+        }
+        if (jLabel != null) {
+            jLabel.setText(statut);
+        }
+        if (jProgressBar != null) {
+            jProgressBar.setValue(percent);
+        }
+    }
+    private static JButton jBuilderButton = null;
+    private static JButton jCreatorButton = null;
+    private static JLabel jLabel = null;
+    private static JProgressBar jProgressBar = null;
+    // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
+    private static void startProgletCreatorMenu() {
+        JPopupMenu jCreatorMenu = new JPopupMenu();
+        jCreatorMenu.add(new JLabel("Entrer le nom de la proglet à construire:", JLabel.LEFT));
+        jCreatorMenuDir = new JTextField();
+        jCreatorMenuDir.setText(System.getProperty("user.dir") + File.separator);
+        jCreatorMenuDir.setEditable(false);
+        jCreatorMenu.add(new JPanel() {
+
+            {
+                add(jCreatorMenuDir);
+                add(jCreatorMenuName = new JTextField(20));
+            }
+        });
+        JMenuItem menuitem = new JMenuItem("Créer le répertoire et les fichiers exemples");
+        jCreatorMenu.add(menuitem);
+        menuitem.addActionListener(new ActionListener() {
+
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                new Thread(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        String name = jCreatorMenuName.getText();
+                        if (name != null && name.length() > 0) {
+                            ProgletCreator.mkdirProglet(jCreatorMenuDir.getText() + name);
+                        }
+                    }
+                }).start();
+            }
+        });
+        Component parent = Console.getInstance().getToolBar();
+        jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());
+    }
+    private static JTextField jCreatorMenuDir, jCreatorMenuName;
+    // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
+
+    private static void startProgletBuilderMenu() {
+        boolean reload = false;
+        if ((jBuilderMenu == null) || reload) {
+            jBuilderMenu = new JPopupMenu();
+            if (ProgletsBuilder.getProglets().length > 0) {
+                jBuilderMenu.add(new JLabel("Sélectionner les proglets à construire:"));
+                for (String proglet : ProgletsBuilder.getProglets()) {
+                    JCheckBox check = new JCheckBox(proglet);
+                    check.setSelected(true);
+                    jBuilderMenu.add(check);
+                }
+                jBuilderMenu.addSeparator();
+                JMenuItem menuitem = new JMenuItem("Construire le jar");
+                menuitem.addActionListener(new ActionListener() {
+
+                    @Override
+                    public void actionPerformed(ActionEvent e) {
+                        new Thread(new Runnable() {
+
+                            @Override
+                            public void run() {
+                                ArrayList<String> proglets = new ArrayList<String>();
+                                for (Component c : jBuilderMenu.getComponents()) {
+                                    if (c instanceof JCheckBox && ((JCheckBox) c).isSelected()) {
+                                        proglets.add(((JCheckBox) c).getText());
+                                    }
+                                }
+                                Console.getInstance().clear();
+                                ProgletsBuilder.build(proglets.toArray(new String[proglets.size()]));
+                            }
+                        }).start();
+                    }
+                });
+                jBuilderMenu.add(menuitem);
+            } else {
+                jBuilderMenu.add(new JLabel("Aucune proglet à construire dans ce répertoire"));
+            }
+        }
+        Component parent = Console.getInstance().getToolBar();
+        jBuilderMenu.show(jBuilderButton, 0, parent.getHeight());
+    }
+    // @ inner-class-variable
+    private static JPopupMenu jBuilderMenu = null;
+
+    private static void startConvertisseurHML() {
+        JPopupMenu jCreatorMenu = new JPopupMenu();
+        jCreatorMenu.add(new Htm2Hml());
+        Component parent = Console.getInstance().getToolBar();
+        jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());
+    }
+}
Index: src/org/javascool/builder/hml2htm.xslt
===================================================================
--- src/org/javascool/builder/hml2htm.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/hml2htm.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+  <!-- This XSLT translates HML code to HTML 4 output -->
+
+<xsl:output 
+  method="html"
+  encoding="UTF-8"
+  doctype-public="-//W3C//DTD HTML 4.01//EN"
+  doctype-system="http://www.w3.org/TR/html4/strict.dtd"
+  indent="yes" />
+
+<!-- 0 : Page production -->
+
+<xsl:template match="/*">
+  <html>
+    <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
+      <xsl:for-each select="@*"><xsl:choose>
+        <xsl:when test="name(.) = 'title'"><title><xsl:value-of select="."/></title></xsl:when>
+        <xsl:when test="name(.) = 'icon'"><link rel="shortcut icon" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'style'"><link rel="stylesheet" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'script'"><script type="text/javascript" src="{.}"/></xsl:when>
+        <xsl:otherwise><meta name="{name(.)}" content="{.}"/></xsl:otherwise> 
+        <!-- Possible improvement: take <meta http-equiv="$name" content="$value" /> or other <link rel="$name" href="$value" /> constructs into account !-->
+      </xsl:choose></xsl:for-each>
+    </head>
+    <body>
+      <xsl:if test="count(@title)=1"><h1><xsl:value-of select="@title"/>.</h1></xsl:if>
+      <xsl:apply-templates/>
+    </body>
+  </html>
+</xsl:template>
+
+<!-- 1 : Section production -->
+
+<xsl:template match="div|p"><xsl:call-template name="div"/></xsl:template>
+<xsl:template name="div">
+  <xsl:choose>
+    <xsl:when test="@class = 'table'">
+      <p><table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee"><xsl:call-template name="div-2"/></table><br/></p>
+    </xsl:when>
+    <xsl:when test="@class = 'ul' or @class = 'ol'">
+      <xsl:element name="{@class}"><xsl:call-template name="div-2"/></xsl:element>
+    </xsl:when>
+    <xsl:when test="../@class = 'ul' or ../@class = 'ol'"><li><xsl:call-template name="div-2"/></li></xsl:when>
+    <xsl:when test="../@class = 'table'"><tr><xsl:call-template name="div-2"/></tr></xsl:when>
+    <xsl:when test="../../@class = 'table'"><td valign="top"><xsl:call-template name="div-2"/></td></xsl:when>
+    <xsl:when test="@class = 'margin'"><div align="right"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'center'"><div align="center"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'tag'"><xsl:call-template name="tag"/></xsl:when>
+    <xsl:otherwise><div><xsl:call-template name="div-2"/></div></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+<xsl:template name="div-2">
+  <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@id)=1"><a name="{@id}"></a></xsl:if>
+  <xsl:if test="count(@title)=1"><xsl:choose>
+    <xsl:when test=".. = /"><h2><xsl:value-of select="@title"/>.</h2></xsl:when>
+    <xsl:when test="../.. = /"><h3><xsl:value-of select="@title"/>.</h3></xsl:when>
+    <xsl:when test="../../.. = /"><h4><xsl:value-of select="@title"/>.</h4></xsl:when>
+    <xsl:otherwise><b><xsl:value-of select="@title"/>.</b><xsl:text> </xsl:text></xsl:otherwise>
+  </xsl:choose></xsl:if>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- 1.1 : Pml construct description production -->
+
+<xsl:template name="tag"><table bgcolor="#eeeeee" width="90%">
+  <tr><td colspan="4"><b>{</b><xsl:text> </xsl:text><xsl:value-of select="@title"/></td></tr>
+  <tr><td align="center"><b>name</b></td><td align="center"><b>type</b></td><td align="center"><b>default value</b></td><td></td></tr>
+  <xsl:for-each select="param"><tr>
+     <td><font color="#505000"><xsl:value-of select="@name"/></font></td>
+     <td><font color="#990000"><xsl:value-of select="@type"/></font></td>
+     <td><xsl:choose>
+        <xsl:when test="count(@value)=1"><font color="#008000">"<xsl:value-of select="@value"/>"</font></xsl:when>
+        <xsl:otherwise><i>mandatory</i></xsl:otherwise>
+     </xsl:choose></td>
+     <td><xsl:apply-templates/></td>
+  </tr></xsl:for-each>
+  <tr><td colspan="4"><xsl:choose>
+    <xsl:when test="count(elements/@type) > 0">Structure: "<font color="#202080"><xsl:value-of select="elements/@type"/>"</font></xsl:when>
+    <xsl:otherwise><i>no element</i></xsl:otherwise>
+  </xsl:choose></td></tr>
+  <tr><td colspan="4"><hr/></td></tr>
+  <tr><td colspan="4">
+    <xsl:for-each select="*[name(.) != 'param' and name(.) != 'elements']"><xsl:apply-templates/></xsl:for-each>
+  </td></tr>
+  <tr><td colspan="4"><b>}</b></td></tr>
+</table></xsl:template>
+
+<!-- 2 : Span production -->
+
+<xsl:template match="s">
+  <span>
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </span>
+</xsl:template>
+<xsl:template match="b"><b><xsl:apply-templates/></b></xsl:template>
+<xsl:template match="i"><i><xsl:apply-templates/></i></xsl:template>
+<xsl:template match="c"><tt><xsl:apply-templates/></tt></xsl:template>
+<xsl:template match="S"><sup><xsl:apply-templates/></sup></xsl:template>
+<xsl:template match="I"><sub><xsl:apply-templates/></sub></xsl:template>
+
+<!-- 3 : Link production -->
+
+<xsl:template match="l"><xsl:call-template name="l"/></xsl:template>
+<xsl:template name="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'replace'"><script language="javascript">location.replace("<xsl:value-of select="@link"/>");</script></xsl:when>
+    <xsl:when test="@class = 'include'"><xsl:apply-templates select="document(@link,.)"/></xsl:when>
+    <xsl:when test="count(@link) = 1"><a href="{@link}"> 
+      <xsl:if test="count(@class)=1"><xsl:choose>
+        <xsl:when test="@class = 'newtab'"><xsl:attribute name="target">_blank</xsl:attribute></xsl:when>
+        <xsl:otherwise><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:otherwise>
+      </xsl:choose></xsl:if>
+      <xsl:if test="count(@icon) = 1"><img src="{@icon}" alt="{@text}"/></xsl:if>
+      <xsl:if test="count(@text)=1 and count(@icon)=1"><xsl:text> </xsl:text></xsl:if>
+      <xsl:if test="count(@text)=1"><xsl:value-of select="@text"/></xsl:if>
+      <xsl:if test="count(@text)=0 and count(@icon)=0">[.]</xsl:if>
+    </a></xsl:when>
+    <xsl:when test="count(@icon) = 1"><img src="{@icon}" alt="{@text}">
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    </img></xsl:when>
+    <xsl:when test="count(@text) = 1"><span>
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+      <xsl:value-of select="@text"/>
+    </span></xsl:when>
+  </xsl:choose>
+</xsl:template>
+
+<!--- 4: Code copy
+
+<xsl:template match="code">
+  <xsl:apply-templates mode ="code"/>
+</xsl:template>
+    
+<xsl:template match="*" mode="code"><xsl:text>
+</xsl:text>  
+  <xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+ -->
+ 
+<!--- 5: Spurious translation -->
+
+<xsl:template match="*"><xsl:text>
+</xsl:text>  
+<!--xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message-->
+<xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/htm2hml.xslt
===================================================================
--- src/org/javascool/builder/htm2hml.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/htm2hml.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+  <!-- This XSLT translates HTNML to HML constructs -->
+
+<xsl:output method="xml" encoding="utf-8" omit-xml-declaration="yes"/>
+
+<!--- 1: Division translation -->
+
+<xsl:template match="ul|ol|table">
+  <div class="{name(.)}"> 
+    <xsl:apply-templates/>
+  </div>
+</xsl:template>
+
+<xsl:template match="div|p|li|tr|td">
+  <div>
+    <xsl:if test="count(@title)=1"><xsl:attribute name="title"><xsl:value-of select="@title"/></xsl:attribute></xsl:if>
+    <xsl:choose>
+      <xsl:when test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:when>
+      <xsl:when test="count(@align)=1"><xsl:attribute name="class"><xsl:value-of select="@align"/></xsl:attribute></xsl:when>
+      <xsl:when test="count(@valign)=1"><xsl:attribute name="class"><xsl:value-of select="@valign"/></xsl:attribute></xsl:when>
+    </xsl:choose>
+    <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </div>
+</xsl:template>
+
+<!--- 2: Span translation -->
+
+<xsl:template match="span">
+  <s>    
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </s>
+</xsl:template>
+<xsl:template match="b|i|u">
+  <xsl:element name="{name(.)}"><xsl:apply-templates/></xsl:element>
+</xsl:template>
+<xsl:template match="tt"><c><xsl:apply-templates/></c></xsl:template>
+<xsl:template match="sup"><S><xsl:apply-templates/></S></xsl:template>
+<xsl:template match="sub"><I><xsl:apply-templates/></I></xsl:template>
+
+<!--- 3: Link translation -->
+
+<xsl:template match="a">
+  <l>    
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="class"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(@href)=1"><xsl:attribute name="link"><xsl:value-of select="@href"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(img/@src)=1"><xsl:attribute name="icon"><xsl:value-of select="img/@src"/></xsl:attribute></xsl:if>
+    <xsl:attribute name="text"><xsl:value-of select="text()"/></xsl:attribute>
+  </l>
+</xsl:template>
+
+<xsl:template match="img">
+  <l class="icon">    
+    <xsl:if test="count(@src)=1"><xsl:attribute name="icon"><xsl:value-of select="@src"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(@alt)=1"><xsl:attribute name="text"><xsl:value-of select="@alt"/></xsl:attribute></xsl:if>
+  </l>
+</xsl:template>
+
+<!--- 4: Spurious translation 
+
+<xsl:template match="br|hr|form|input|select|option">
+  <xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message>
+</xsl:template>
+
+<xsl:template match="*">
+  <xsl:message>Undefined tag: <xsl:value-of select="name(.)"/> !!</xsl:message>
+</xsl:template> -->
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/javascool.key
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/builder/javascool.key
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/builder/JarManager.java
===================================================================
--- src/org/javascool/builder/JarManager.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/JarManager.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,168 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.builder;
+
+import org.javascool.tools.FileManager;
+
+import java.io.File;
+import java.io.OutputStream;
+import java.io.InputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+
+import java.util.Enumeration;
+import java.util.jar.Attributes;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+
+/** Met à disposition des fonctions de gestion de jar et répertoires de déploiement. */
+public class JarManager {
+  // @factory
+  private JarManager() {}
+
+  /** Extrait une arborescence d'un jar.
+   * @param jarFile Jarre dont on extrait les fichiers.
+   * @param destDir Dossier où on déploie les fichiers.
+   * @param jarEntry Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
+   */
+  public static void jarExtract(String jarFile, String destDir, String jarEntry) {
+    try {
+      ProgletsBuilder.log("Extract files from " + jarFile + " to " + destDir + ((!jarEntry.isEmpty()) ? " which start with " + jarEntry : ""),true);
+      JarFile jf = new JarFile(jarFile);
+      JarInputStream jip=new JarInputStream(new FileInputStream(jarFile));
+      Enumeration<JarEntry> entries = jf.entries();
+      JarEntry je;
+      while((je = jip.getNextJarEntry())!=null) {
+        if((jarEntry.isEmpty()?true:je.getName().startsWith(jarEntry)) && !je.isDirectory()&&!je.getName().contains("META-INF")) {
+          File dest = new File(destDir + File.separator + je.getName());
+          dest.getParentFile().mkdirs();
+          copyStream(jip, new FileOutputStream(dest));
+        }
+      }
+      jip.close();
+      
+    } catch(Exception ex) { throw new IllegalStateException(ex);
+    }
+  }
+  /**
+   * @see #jarExtract(String, String, String)
+   */
+  public static void jarExtract(String jarFile, String destDir) {
+    jarExtract(jarFile, destDir, "");
+  }
+  /** Crée un jar à partir d'une arborescence.
+   * @param jarFile Jar à construire. Elle est détruite avant d'être crée.
+   * @param mfFile Fichier de manifeste (obligatoire).
+   * @param srcDir Dossier source avec les fichiers à mettre en jarre.
+   * @param jarEntries Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
+   */
+  public static void jarCreate(String jarFile, String mfFile, String srcDir, String[] jarEntries) {
+    try {
+        ProgletsBuilder.log("Création du jar "+jarFile,true);
+     File parent = new File(jarFile).getParentFile();
+     if (parent != null) parent.mkdirs();
+      new File(jarFile).delete();
+      srcDir = new File(srcDir).getCanonicalPath();
+      Manifest manifest = new Manifest(new FileInputStream(mfFile));
+      manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
+      JarOutputStream target = new JarOutputStream(new FileOutputStream(jarFile), manifest);
+      copyFileToJar(new File(srcDir), target, new File(srcDir), jarEntries);
+      target.close();
+    } catch(Exception ex) { ex.printStackTrace(); throw new RuntimeException(ex);
+    }
+  }  
+  /**
+   * @see #jarCreate(String, String, String, String[])
+   */
+  public static void jarCreate(String jarFile, String mfFile, String srcDir) {
+    jarCreate(jarFile, mfFile, srcDir, null);
+  }
+  /** Copie un répertoire/fichier dans un autre en oubliant les svn.
+   * @param srcDir Dossier source.
+   * @param dstDir Dossier cible.
+   */
+  public static void copyFiles(String srcDir, String dstDir) throws IOException {
+    if(new File(srcDir).isDirectory()) {
+      if(!new File(srcDir).getName().equals(".svn"))
+        for(String s : FileManager.list(srcDir)) {
+          String d = dstDir + File.separator + new File(s).getAbsoluteFile().getName();
+          copyFiles(s, d);
+        }
+    } else {
+      new File(dstDir).getParentFile().mkdirs();
+      copyStream(new FileInputStream(srcDir), new FileOutputStream(dstDir));
+    }
+  }
+  // Ajoute un stream a un jar
+  private static void copyFileToJar(File source, JarOutputStream target, File root, String[] jarEntries) throws IOException {
+    // Teste si la source est dans les fichier à extraire
+    if (jarEntries != null) {
+      boolean skip = true;
+      for(String jarEntry : jarEntries) {
+	String entry = root.toString() + File.separator + jarEntry;
+	skip &= !(entry.startsWith(source.toString()) | source.toString().startsWith(entry));
+      }
+      if (skip)
+	return;
+    }
+    BufferedInputStream in = null;
+    try {
+      if(source.isDirectory()) {
+        String name = source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/");
+        if(!name.isEmpty() && (!source.equals(root))) {
+          if(!name.endsWith("/"))
+            name += "/";
+          JarEntry entry = new JarEntry(name);
+          entry.setTime(source.lastModified());
+          target.putNextEntry(entry);
+          target.closeEntry();
+        }
+        for(File nestedFile : source.listFiles())
+          copyFileToJar(nestedFile, target, root, jarEntries);
+      } else {
+	JarEntry entry = new JarEntry(source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/"));
+	entry.setTime(source.lastModified());
+	target.putNextEntry(entry);
+	copyStream(new BufferedInputStream(new FileInputStream(source)), target);
+      }
+    } catch(Throwable e) {
+      e.printStackTrace(System.out); throw new IllegalStateException(e);
+    }
+  }
+  // Copy un stream dans un autre
+  private static void copyStream(InputStream in, OutputStream out) throws IOException {
+    InputStream i = in instanceof JarInputStream?in :new BufferedInputStream(in, 2048);
+    OutputStream o = out instanceof JarOutputStream ? out : new BufferedOutputStream(out, 2048);
+    byte data[] = new byte[2048];
+    for(int c; (c = i.read(data, 0, 2048)) != -1;)
+      o.write(data, 0, c);
+    if(o instanceof JarOutputStream)
+      ((JarOutputStream) o).closeEntry();
+    else
+      o.close();
+    if(i instanceof JarInputStream){
+        ((JarInputStream)i).closeEntry();
+    } else {
+        i.close();
+    }
+  }
+  /** Détruit récursivement un fichier ou répertoire.
+   * * <p>Irréversible: à utiliser avec la plus grande prudence.</p>
+   */
+  public static void rmDir(File dir) {
+    if (dir.isDirectory())
+      for(File f : dir.listFiles())
+	rmDir(f);
+    dir.delete();
+  }
+}
Index: src/org/javascool/gui/JVSPanel.java
===================================================================
--- src/org/javascool/gui/JVSPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,281 @@
+package org.javascool.gui;
+
+import java.awt.BorderLayout;
+import java.io.Console;
+import java.io.File;
+
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+
+import org.javascool.core.ProgletEngine;
+import org.javascool.gui.editor.FileKit;
+import org.javascool.gui.editor.FileReference;
+import org.javascool.gui.editor.JVSEditorsPane;
+import org.javascool.tools.UserConfig;
+
+/**
+ * The main panel for Java's cool This class wich is very static contain all
+ * that we need to run Java's cool like save and open file command. This class
+ * can only be called by JVSPanel on instance otherwise it can throw very big
+ * errors
+ * 
+ * @author Philippe Vienne
+ */
+class JVSPanel extends JPanel {
+
+	private static final long serialVersionUID = -913356947524067017L;
+
+	/** Access to the unique instance of the JVSPanel object. */
+	public static JVSPanel getInstance() {
+		if (desktop == null) {
+			desktop = new JVSPanel();
+		}
+		return desktop;
+	}
+
+	private static JVSPanel desktop = null;
+
+	private JVSPanel() {
+		setVisible(true);
+		setLayout(new BorderLayout());
+		add(JVSStartPanel.getInstance());
+		this.revalidate();
+	}
+
+	/** Get the current EditorTabs.
+	 * 
+	 * @return An EditorTabs
+	 * @throws IllegalStateException if no EditorTabs opened in the left part
+	 */
+	public FileKit getEditorTabs() throws IllegalStateException {
+		if(JVSCenterPanel.getInstance().getLeftComponent() instanceof FileKit)
+			return (FileKit) JVSCenterPanel.getInstance().getLeftComponent();
+		throw new IllegalStateException("Left component is not an EditorTabs");
+	}
+
+	/** Close the current proglet.
+	 * 
+	 */
+	public void closeProglet() {
+		if (closeAllFiles()) {
+			this.removeAll();
+			this.setOpaque(true);
+			this.repaint();
+			this.validate();
+			this.repaint();
+			add(JVSStartPanel.getInstance());
+			this.repaint();
+			this.revalidate();
+			this.repaint();
+			if (ProgletEngine.getInstance().getProglet() != null)
+				ProgletEngine.getInstance().getProglet().stop();
+		}
+	}
+
+	/**
+	 * Open a new file in the editor
+	 * 
+	 * @see JVSEditorsPane
+	 */
+	public void newFile() {
+		getEditorTabs().openFile(new FileReference());
+	}
+
+	/** Contain the current CompileAction. */
+	private CompileAction ca = new CompileAction();
+
+	/** Compile edited file in the editor.
+	 */
+	public void compileFile() {
+		ca.actionPerformed(null);
+	}
+
+	/** Open a file. 
+	 * Start a file chooser and open selected file to the current EditorTabs
+	 * @see JFileChooser
+	 * @see JVSEditorsPane
+	 */
+	public void openFile() {
+		JFileChooser fc = new JFileChooser();
+		if (UserConfig.getInstance("javascool").getProperty("dir") != null)
+			fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool")
+					.getProperty("dir")));
+		else if (System.getProperty("os.name").toLowerCase().contains("nix")
+				|| System.getProperty("os.name").toLowerCase().contains("nux"))
+			fc.setCurrentDirectory(new File(System.getProperty("user.dir")));
+		else if (System.getProperty("home.dir") != null)
+			fc.setCurrentDirectory(new File(System.getProperty("home.dir")));
+		if (fc.showOpenDialog(Desktop.getInstance().getFrame()) == JFileChooser.APPROVE_OPTION) {
+			if (!fc.getSelectedFile().exists()) {
+				JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+						"Le fichier indiqué n'existe pas !!!", "Erreur", JOptionPane.ERROR_MESSAGE);
+				return;
+			}
+			UserConfig.getInstance("javascool").setProperty("dir",
+					fc.getSelectedFile().getParentFile().getAbsolutePath());
+			openFile(new FileReference(fc.getSelectedFile()));
+		}
+	}
+
+	/** Open a specified file. */
+	public void openFile(FileReference jvsFileReference) {
+		getEditorTabs().openFile(jvsFileReference);
+	}
+
+	/** Save the current file.
+	 * Ask to the user where save the file if is tmp or simple save
+	 * @see JVSFile
+	 * @return true on success or false if the file could not be saved
+	 */
+	public boolean saveFile() {
+		if (getEditorTabs().saveCurrentFile()) {
+			return true;
+		}
+		return false;
+	}
+	
+	/**
+	 * @see saveFile()
+	 */
+	public boolean saveAsFile() {
+		if (getEditorTabs().saveAsCurrentFile()) {
+			return true;
+		}
+		return false;
+	}
+	
+	public void closeFile() {
+		getEditorTabs().closeCurrentFile();
+	}
+
+	/** Throw to the user a compile error.
+	 * Show a compile error for an human Open a dialog with compile error
+	 * explains and hightlight the error line
+	 * 
+	 * @param line
+	 *            The line error
+	 * @param explication
+	 *            Human explain for that error
+	 * @see Console
+	 */
+	public void reportCompileError(int line, String explication) {
+		org.javascool.widgets.Console.getInstance().clear();
+		JVSWidgetPanel.getInstance().focusOnConsolePanel();
+		if (ca.getCompiledEditor() != null) {
+			ca.getCompiledEditor().signalLine(line);
+		}
+	}
+
+	/**
+	 * Handle the close application task Check if all files are saved and if the
+	 * user want to close the application
+	 * 
+	 * @return True mean that app can be close and false that app can NOT be
+	 *         closed
+	 */
+	public boolean close() {
+		return closeAllFiles("Voulez vous vraiment quitter Java's cool ?");
+	}
+
+	/** Ask to user if he want to continue and save files
+	 * Check if all files are saved and if the user wants to continue
+	 * 
+	 * @return True mean that you can continue and false not
+	 */
+	public boolean closeAllFiles() {
+		return closeAllFiles("Voulez vous vraiment continuer ?");
+	}
+
+	/** Ask to user if he want to save files
+	 * Check if all files are saved and if the user wants to continue
+	 * @param messageIfAllFilesAreSaved Message to ask to the user
+	 * @return True mean that you can continue and false not
+	 */
+	public boolean closeAllFiles(String messageIfAllFilesAreSaved) {
+		if (getEditorTabs().isAllFilesSaved()) {
+			int n = JOptionPane.showConfirmDialog(Desktop.getInstance()
+					.getFrame(), messageIfAllFilesAreSaved, "Confirmation",
+					JOptionPane.YES_NO_OPTION);
+			if (n == JOptionPane.YES_OPTION)
+				return true;
+			else
+				return false;
+		}
+		return getEditorTabs().saveAllFiles();
+	}
+
+	/**
+	 * Charge une nouvelle proglet dans l'interface utilisateur.
+	 * 
+	 * @param name
+	 *            Le nom de code de la proglet (ex:abcdAlgos)
+	 * @see org.javascool.core.ProgletEngine
+	 */
+	public void loadProglet(String name) {
+		System.gc();
+		this.removeAll();
+		try {
+			JVSToolBar.getInstance().disableDemoButton();
+			this.revalidate();
+			this.add(JVSToolBar.getInstance(), BorderLayout.NORTH);
+			this.add(JVSCenterPanel.getInstance(), BorderLayout.CENTER);
+			this.revalidate();
+			JVSCenterPanel.getInstance().revalidate();
+			JVSCenterPanel.getInstance().setDividerLocation(getWidth() / 2);
+			JVSCenterPanel.getInstance().revalidate();
+			JVSWidgetPanel.getInstance().setProglet(name);
+			if (ProgletEngine.getInstance().getProglet().hasDemo()) {
+				JVSToolBar.getInstance().enableDemoButton();
+			} else {
+				JVSToolBar.getInstance().disableDemoButton();
+			}
+			Desktop.getInstance().openNewFile();
+		} catch (Exception e) {
+			throw new RuntimeException("Unable to load proglet " + name, e);
+		}
+	}
+
+	/** Report a runtime bug to user.
+	 * Report a bug to the user without ErrorCatcher. It is used by a proglet to report a bug while execute the user code.
+	 * @param ex The bug to report
+	 */
+	public void reportRuntimeBug(String ex) {
+		StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+		int line = 0;
+		for (StackTraceElement elem : stack) {
+			if (elem.getFileName().startsWith("JvsToJavaTranslated")) {
+				line = elem.getLineNumber();
+			} else {
+				System.err.println(elem.getClassName());
+			}
+		}
+		if (ca.getCompiledEditor() != null) {
+			ca.getCompiledEditor().signalLine(line);
+		}
+		ProgletEngine.getInstance().doStop();
+		JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+				ex, "Erreur du logiciel à la ligne " + line, JOptionPane.ERROR_MESSAGE);
+	}
+
+	@Deprecated
+	public void reportApplicationBug(String ex) {
+		Dialog.error("Erreur dans Java's Cool", ex);
+	}
+
+	@Deprecated
+	public static class Dialog {
+
+		/** Show a success dialog */
+		public static void success(String title, String message) {
+			JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+					message, title, JOptionPane.INFORMATION_MESSAGE);
+		}
+
+		/** Show an error dialog */
+		public static void error(String title, String message) {
+			JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+					message, title, JOptionPane.ERROR_MESSAGE);
+		}
+	}
+}
Index: src/org/javascool/gui/package.html
===================================================================
--- src/org/javascool/gui/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les mécanismes de compilation d'une nouvelle proglet.</body>
+
Index: src/org/javascool/gui/Desktop.java
===================================================================
--- src/org/javascool/gui/Desktop.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/Desktop.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,211 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.gui;
+
+import java.io.File;
+import java.net.URL;
+
+import javax.swing.JFrame;
+
+import org.javascool.About;
+import org.javascool.core.ProgletEngine;
+import org.javascool.gui.editor.FileReference;
+import org.javascool.macros.Macros;
+import org.javascool.tools.FileManager;
+import org.javascool.widgets.MainFrame;
+import org.javascool.widgets.ToolBar;
+
+// Used to define the frame
+/** Définit les functions d'interaction avec l'interface graphique de JavaScool.
+ *
+ * @see <a href="Desktop.java.html">code source</a>
+ * @serial exclude
+ */
+public class Desktop {
+    // @static-instance
+
+    /** Crée et/ou renvoie l'unique instance du desktop.
+     * <p>Une application ne peut définir qu'un seul desktop.</p>
+     */
+    public static Desktop getInstance() {
+        if (desktop == null) {
+            desktop = new Desktop();
+        }
+        return desktop;
+    }
+    private static Desktop desktop = null;
+
+    private Desktop() {
+    }
+
+    /** Renvoie la fenêtre racine de l'interface graphique. */
+    public JFrame getFrame() {
+        if (frame == null) {
+            frame = (new MainFrame() {
+
+				private static final long serialVersionUID = 1727893520791296658L;
+
+				@Override
+                public boolean isClosable() {
+                    return org.javascool.gui.Desktop.getInstance().isClosable();
+                }
+            }).reset(About.title, About.logo, JVSPanel.getInstance());
+        }
+        return frame;
+    }
+    private MainFrame frame;
+
+    /** Retourne la bare d'outils de Java's cool */
+    public ToolBar getToolBar() {
+        return JVSToolBar.getInstance();
+    }
+
+    /** Demande la fermeture du desktop à la fin du programme.
+     * @return La valeur true si le desktop peut être fermé sans dommage pour l'utilisateur, sinon la valeur fausse.
+     */
+    public boolean isClosable() {
+        boolean close = JVSPanel.getInstance().close();
+            if (close && ProgletEngine.getInstance().getProglet() != null)
+                ProgletEngine.getInstance().getProglet().stop();
+        return close;
+    }
+
+    /** Crée un nouveau fichier.
+     * @return  La valeur true si le fichier est bien créé.
+     */
+    public boolean openNewFile() {
+        try {
+            JVSPanel.getInstance().newFile();
+            return true;
+        } catch (Throwable th) {
+	  System.out.println("Aie impossible de créer un nouveau fichier "+th);
+	  return false;
+        }
+    }
+
+    /** Ouvre un fichier
+     * Demande à l'utilisateur de choisir un fichier et l'ouvre
+     * @param file Le fichier à ouvrir. 
+     * <p>-Avec la valeur null une boîte de dialogue le demandera à l'utilisateur.</p>
+     * <p>- Si le fichier est une URL, une copie locale du fichier (avec sauvegarde du fichier existant) est effectuée avant ouverture.</p>
+     */
+    public boolean openFile(File file) {
+        try {
+            if (file == null) {
+                JVSPanel.getInstance().openFile();
+            } else {
+                JVSPanel.getInstance().openFile(new FileReference(file));
+            }
+            return true;
+        } catch (Throwable th) {
+        	System.out.println("Aie impossible d'ouvrir le fichier "+th);
+            return false;
+        }
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile(URL url) {
+        try{
+            System.err.println(url.getProtocol());
+            if(url.getProtocol().equals("jar")){
+            	FileReference tmpFile=new FileReference();
+            	tmpFile.setContent(FileManager.load(url.toExternalForm()));
+                JVSPanel.getInstance().openFile(tmpFile);
+                return true;
+            }
+            return openFile(new File(url.toURI()));
+        }catch(Exception ex){
+        	System.out.println("Aie impossible d'ouvrir le fichier "+ex);
+            System.err.println("Error : ");
+            ex.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile(String file) {
+        return openFile(Macros.getResourceURL(file));
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile() {
+        return openFile((File) null);
+    }
+
+    /** Demande à l'utilisateur de sauvegarder le fichier courant.
+     * @return La valeur true si le fichier est bien sauvegardé.
+     */
+    public boolean saveCurrentFile() {
+        return JVSPanel.getInstance().saveFile();
+    }
+    
+    /** Demande à l'utilisateur de sauvegarder le fichier courant.
+     * @return La valeur true si le fichier est bien sauvegardé.
+     */
+    public boolean saveAsCurrentFile() {
+        return JVSPanel.getInstance().saveAsFile();
+    }
+
+    /** Ferme le fichier en cours d'édition. */
+    public void closeFile() {
+        JVSPanel.getInstance().closeFile();
+    }
+
+    /** Compile le fichier en cours d'édition. */
+    public void compileFile() {
+        JVSPanel.getInstance().compileFile();
+    }
+
+    /** Ferme la proglet en cours d'édition. */
+    public void closeProglet() {
+        JVSPanel.getInstance().closeProglet();
+    }
+
+    /** Ouvre une proglet
+     * @param proglet Le nom de code de la Proglet
+     * @return True si tous les fichier ont été sauvegardé et la proglet sauvegardé
+     */
+    public boolean openProglet(String proglet) {
+        if (JVSPanel.getInstance().closeAllFiles()) {
+            JVSPanel.getInstance().loadProglet(proglet);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /** Ouvre un nouvel onglet de navigation
+     * Ouvre un onglet HTML3 dans le JVSWidgetPanel, cet onglet peut être fermé
+     * @param url L'adresse à ouvrir sous forme de chaîne de caractères ou d'URL.
+     * @param name Le titre du nouvel onglet
+     */
+    public void openBrowserTab(URL url, String name) {
+        openBrowserTab(url.toString(), name);
+    }
+
+    /**
+     * @see #openBrowserTab(URL, String)
+     */
+    public void openBrowserTab(String url, String name) {
+        JVSWidgetPanel.getInstance().openWebTab(url, name);
+    }
+
+    /** Affiche la console. */
+    public void focusOnConsolePanel() {
+      JVSWidgetPanel.getInstance().focusOnConsolePanel();
+    }
+
+    /** Affiche la console. */
+    public void focusOnProgletPanel() {
+       JVSWidgetPanel.getInstance().focusOnProgletPanel();
+    }
+}
Index: src/org/javascool/gui/CompileAction.java
===================================================================
--- src/org/javascool/gui/CompileAction.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/CompileAction.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,69 @@
+package org.javascool.gui;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+
+import org.javascool.core.ProgletEngine;
+import org.javascool.gui.editor.EditorKit;
+import org.javascool.gui.editor.FileKit;
+import org.javascool.gui.editor.JVSEditorsPane;
+import org.javascool.widgets.Console;
+
+/** Compile Action for all JVSFileReferance. */
+public class CompileAction extends AbstractAction {
+
+	private static final long serialVersionUID = -6432472821088070514L;
+	
+	private FileKit tabs;
+	private boolean success;
+	private EditorKit compiledEditor;
+	
+	public CompileAction(){
+		//this.tabs=JVSEditorsPane.getInstance();
+	}
+
+	@Override
+	public void actionPerformed(ActionEvent e) {
+		try {
+			this.tabs=JVSPanel.getInstance().getEditorTabs();
+			if(tabs.saveCurrentFile()==false){
+				setSuccess(false);
+				return;
+			}
+			JVSWidgetPanel.getInstance().focusOnConsolePanel();
+			setCompiledEditor(tabs.getCurrentEditor());
+			if (ProgletEngine.getInstance().doCompile(tabs.getCurrentEditor().getText())) {
+			    Console.getInstance().clear();
+			    System.out.println("Compilation réussie !");
+			    setSuccess(true);
+			} else {
+			    setSuccess(false);
+			}
+			if(isSuccess()){
+				JVSToolBar.getInstance().enableStartStopButton();
+			} else {
+				JVSToolBar.getInstance().disableStartStopButton();
+			}
+		} catch (Exception e1) {
+			e1.printStackTrace();
+		}
+	}
+
+	public boolean isSuccess() {
+		return success;
+	}
+
+	public void setSuccess(boolean success) {
+		this.success = success;
+	}
+
+	public EditorKit getCompiledEditor() {
+		return compiledEditor;
+	}
+
+	public void setCompiledEditor(EditorKit compiledEditor) {
+		this.compiledEditor = compiledEditor;
+	}
+
+}
Index: src/org/javascool/gui/JVSStartPanel.java
===================================================================
--- src/org/javascool/gui/JVSStartPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSStartPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,119 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.javascool.gui;
+
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.GridLayout;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import javax.swing.Box;
+import javax.swing.BoxLayout;
+import javax.swing.ImageIcon;
+import javax.swing.JButton;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.ScrollPaneConstants;
+import javax.swing.SwingConstants;
+import javax.swing.ToolTipManager;
+import org.javascool.core.ProgletEngine;
+import org.javascool.macros.Macros;
+
+/** Ecran d'accueil de Java's cool
+ * Il présente toutes les activités présentes dans le jar sous la forme d'un
+ * panneau d'icones avec le nom des proglets respectives.
+ * @see org.javascool.core.ProgletEngine
+ */
+class JVSStartPanel extends JScrollPane {
+
+    private static final long serialVersionUID = 1L;
+    private static JVSStartPanel jvssp;
+
+    public static JVSStartPanel getInstance() {
+        if (jvssp == null) {
+            jvssp = new JVSStartPanel(JVSStartPanel.shortcutPanel());
+        }
+        return jvssp;
+    }
+
+    private JVSStartPanel(JPanel panel) {
+        super(panel, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
+        ToolTipManager.sharedInstance().setInitialDelay(75);
+    }
+
+    /** Dessine le JPanel en listant les proglets
+     * @see ProgletEngine
+     * @return Le JPanel dessiné
+     */
+    private static JPanel shortcutPanel() {
+        JPanel shortcuts = new JPanel();
+        int i=0;
+        for (@SuppressWarnings("unused") ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets()) {
+            i++;
+        }
+        shortcuts.setLayout(new GridLayout(0, (i/3)==0?1:(i/3)));
+        for (ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets()) {
+            shortcuts.add(JVSStartPanel.createShortcut(Macros.getIcon(proglet.getIcon()), proglet.getName(), proglet.getTitle(), new ProgletLoader(proglet.getName())));
+        }
+        return shortcuts;
+    }
+
+    /** Cette classe permet de lançer une Proglet */
+    private static
+            class ProgletLoader implements Runnable {
+
+        private String proglet;
+
+        ProgletLoader(String proglet) {
+            this.proglet = proglet;
+        }
+
+        @Override
+        public void run() {
+            JVSPanel.getInstance().loadProglet(proglet);
+        }
+    }
+
+    /** Créer un pannel avec un bouton capâble de lançer la Proglet */
+    private static JPanel createShortcut(ImageIcon icon, String name, String title, final Runnable start) {
+        JPanel panel = new JPanel();
+        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
+        panel.add(Box.createVerticalGlue());
+        JButton label = new JButton(name, icon);
+        // Affichage du titre dans le charset de l'ordinateur
+        label.setToolTipText(title);
+        label.setPreferredSize(new Dimension(160, 160));
+        label.setVerticalTextPosition(SwingConstants.BOTTOM);
+        label.setHorizontalTextPosition(SwingConstants.CENTER);
+        label.setAlignmentX(Component.CENTER_ALIGNMENT);
+        label.setAlignmentY(Component.CENTER_ALIGNMENT);
+        panel.add(label);
+        panel.add(Box.createVerticalGlue());
+        label.addMouseListener(new MouseListener() {
+
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                start.run();
+            }
+
+            @Override
+            public void mousePressed(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseReleased(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseEntered(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseExited(MouseEvent e) {
+            }
+        });
+        return panel;
+    }
+}
\ No newline at end of file
Index: src/org/javascool/gui/JVSWidgetPanel.java
===================================================================
--- src/org/javascool/gui/JVSWidgetPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSWidgetPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,88 @@
+package org.javascool.gui;
+
+import org.javascool.Core;
+import org.javascool.core.ProgletEngine;
+import org.javascool.core.ProgletEngine.Proglet;
+import org.javascool.macros.Macros;
+import org.javascool.widgets.Console;
+import org.javascool.widgets.HtmlDisplay;
+import org.javascool.widgets.TabbedPane;
+
+/** Le panneau contenant les widgets
+ * Les widgets de Java's cool sont disposés dans des onglets. Certain onglets de
+ * navigation web peuvent être fermés par une croix.
+ * @see org.javascool.widgets.Console
+ * @see org.javascool.widgets.HtmlDisplay
+ * @see org.javascool.widgets
+ */
+public class JVSWidgetPanel extends TabbedPane {
+
+	private static final long serialVersionUID = 1L;
+	private String progletTabId;
+	/** Instance du JVSWidgetPanel */
+	private static JVSWidgetPanel jwp;
+
+	public static JVSWidgetPanel getInstance() {
+		if (jwp == null) {
+			jwp = new JVSWidgetPanel();
+		}
+		return jwp;
+	}
+
+	private JVSWidgetPanel() {
+		super();
+		this.add("Console", "", Console.getInstance());
+	}
+
+	/** Charge les tabs de la proglet
+	 * Charge le tab de la proglet (Panel) et l'HTMLDisplay avec le fichier d'aide.
+	 * @param name Le nom du package de la proglet
+	 */
+	public void setProglet(String name) {
+		this.removeAll();
+		this.add("Console", "", Console.getInstance());
+		Proglet proglet = ProgletEngine.getInstance().setProglet(name);
+		if (proglet.getPane() != null) {
+			this.progletTabId = this.add("Proglet " + name, "", proglet.getPane());
+		}
+		if (proglet.getHelp() != null) {
+			this.add("Aide de la proglet", "", new HtmlDisplay().setPage(Macros.getResourceURL(proglet.getHelp())));
+			this.switchToTab("Aide de la proglet");
+		}
+		HtmlDisplay memo = new HtmlDisplay();
+		memo.setPage(ClassLoader.getSystemResource(Core.help));
+		this.add("Mémo", "", memo);
+	}
+
+	/** Affiche l'onglet de la Proglet si il existe */
+	public void focusOnProgletPanel() {
+		if (progletTabId != null) {
+			this.switchToTab(progletTabId);
+		}
+	}
+
+	/** Affiche la console */
+	public void focusOnConsolePanel() {
+		this.setSelectedIndex(this.indexOfTab("Console"));
+	}
+
+	/** Ouvre un nouvel onglet web
+	 * Ouvre un nouveau HTMLDisplay dans un onglet. Cet onglet peut être fermer à
+	 * l'aide de la croix qui se situe à droite du titre de l'onglet.
+	 * @param url L'url de la page à charger
+	 * @param tabName Le titre du tab à ouvrir
+	 * @see org.javascool.widgets.HtmlDisplay
+	 * @see String
+	 */
+	public void openWebTab(String url, String tabName) {
+		if(this.indexOfTab(tabName)>=0){
+			this.switchToTab(tabName);
+			return;
+		}
+		HtmlDisplay memo = new HtmlDisplay();
+		memo.setPage(url);
+		memo.putClientProperty("CLOSABLE", true);
+		this.add(tabName, "", memo);
+		this.setSelectedComponent(memo);
+	}
+}
Index: src/org/javascool/gui/JVSCenterPanel.java
===================================================================
--- src/org/javascool/gui/JVSCenterPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSCenterPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,32 @@
+package org.javascool.gui;
+
+import javax.swing.JSplitPane;
+
+import org.javascool.gui.editor.JVSEditorsPane;
+
+/** Le double pannau central de Java's cool
+ * Le JVSCenterPanel est utilisé pour plaçer correctemment le JVSWidgetPanel à
+ * droite et le JVSFileTabs à gauche
+ * @see org.javascool.gui.JVSEditorsPane
+ * @see org.javascool.gui.JVSWidgetPanel
+ */
+class JVSCenterPanel extends JSplitPane {
+  private static final long serialVersionUID = 1L;
+  /** L'instance en cour de cette classe */
+  private static JVSCenterPanel jvssplitpane;
+
+  /** Retourne l'instance actuelle de la classe */
+  public static JVSCenterPanel getInstance() {
+    if(jvssplitpane == null)
+      jvssplitpane = new JVSCenterPanel();
+    return jvssplitpane;
+  }
+  /** Constructeur de la classe */
+  private JVSCenterPanel() {
+    super(JSplitPane.HORIZONTAL_SPLIT);
+    this.setLeftComponent(JVSEditorsPane.getInstance());
+    this.setRightComponent(JVSWidgetPanel.getInstance());
+    this.setVisible(true);
+    this.validate();
+  }
+}
Index: src/org/javascool/gui/JVSToolBar.java
===================================================================
--- src/org/javascool/gui/JVSToolBar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSToolBar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,168 @@
+package org.javascool.gui;
+
+import javax.swing.JButton;
+
+import org.javascool.About;
+import org.javascool.builder.DialogFrame;
+import org.javascool.builder.ProgletsBuilder;
+import org.javascool.core.ProgletEngine;
+import org.javascool.widgets.StartStopButton;
+import org.javascool.widgets.ToolBar;
+
+/** La barre d'outils de Java's cool
+ * Elle est placée en haut de l'interface. Elle contient les boutons de gestion
+ * des fichiers, de compilation et d'éxecution.
+ * @see org.javascool.widgets.StartStopButton
+ * @see org.javascool.gui.JVSPanel
+ */
+public class JVSToolBar extends ToolBar {
+
+    private static final long serialVersionUID = 1L;
+    /** Boutons de l'interface. */
+    private JButton compileButton;
+    private JButton demoButton;
+    private StartStopButton runButton;
+    /** Instance de la classe */
+    private static JVSToolBar jvstb;
+
+    public static JVSToolBar getInstance() {
+        if (jvstb == null) {
+            jvstb = new JVSToolBar();
+        }
+        return jvstb;
+    }
+
+    private JVSToolBar() {
+        setName("Java's cool ToolBar");
+        init();
+    }
+
+    /** Initialize la barre d'outils en créant les bouttons */
+    private void init() {
+    	setOpaque(false);
+    	setBorder(null);
+        addTool("Nouvelle activité", "org/javascool/widgets/icons/new.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().closeProglet();
+            }
+        });
+        addTool("Nouveau fichier", "org/javascool/widgets/icons/new.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().openNewFile();
+            }
+        });
+        addTool("Ouvrir un fichier", "org/javascool/widgets/icons/open.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().openFile();
+            }
+        });
+        addTool("Sauver", "org/javascool/widgets/icons/save.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().saveCurrentFile();
+            }
+        });
+        addTool("Sauver sous", "org/javascool/widgets/icons/saveas.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().saveAsCurrentFile();
+            }
+        });
+
+        compileButton = addTool("Compiler", "org/javascool/widgets/icons/compile.png", new Runnable() {
+
+            @Override
+            public void run() {
+                Desktop.getInstance().compileFile();
+            }
+        });
+
+        addTool("Executer", runButton = new StartStopButton() {
+
+            private static final long serialVersionUID = 1L;
+
+            @Override
+            public void start() {
+                JVSWidgetPanel.getInstance().focusOnProgletPanel();
+                ProgletEngine.getInstance().doRun();
+            }
+
+            @Override
+            public void stop() {
+                ProgletEngine.getInstance().doStop();
+            }
+
+            @Override
+            public boolean isRunning() {
+                return ProgletEngine.getInstance().isRunning();
+            }
+        });
+        runButton.setVisible(false);
+        this.demoButton=addTool("Demo", "org/javascool/widgets/icons/play.png", new Runnable() {
+
+                @Override
+                public void run() {
+                    JVSWidgetPanel.getInstance().focusOnProgletPanel();
+                    ProgletEngine.getInstance().getProglet().doDemo();
+                }
+            });
+        demoButton.setVisible(false);
+        // Crée le menu de construction de proglets si pertinent
+        if (ProgletsBuilder.canBuildProglets()) {
+            pbutton = addRightTool("Proglet Builder", new Runnable() {
+
+                @Override
+                public void run() {
+                    DialogFrame.startFrame();
+                }
+            });
+        }
+       // @todo ici on a mit un platrage car sous Windows XP un java.lang.NoClassDefFoundError: org/javascool/About incomprehensible apparait !!!
+       try {
+          this.add(About.getAboutMessage(), 0);
+       } catch(Exception e) {
+          System.err.println("Dysfonctionnement bizarre:" + e);
+       }
+    }
+    // @ inner-class-variable
+    @SuppressWarnings("unused")
+	private JButton pbutton;
+
+    public void enableCompileButton() {
+        compileButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableCompileButton() {
+        compileButton.setVisible(false);
+        revalidate();
+    }
+    
+    public void enableDemoButton() {
+        demoButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableDemoButton() {
+        demoButton.setVisible(false);
+        revalidate();
+    }
+
+    public void enableStartStopButton() {
+        runButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableStartStopButton() {
+        runButton.setVisible(false);
+        revalidate();
+    }
+}
Index: src/org/javascool/gui/editor/FileReference.java
===================================================================
--- src/org/javascool/gui/editor/FileReference.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/FileReference.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,131 @@
+package org.javascool.gui.editor;
+
+import java.awt.event.ActionListener;
+import java.io.File;
+import java.util.ArrayList;
+
+import org.javascool.tools.FileManager;
+
+public class FileReference {
+
+	public static final String SOURCE_EXTENTION = ".jvs";
+	public static final String DEFAULT_SOURCE = "void main(){\n\t\n}";
+	/** The referenced file */
+	private File file;
+	/** Say if file is temporary */
+	private Boolean tmp;
+	/** It's the content of file */
+	private String content;
+	/** Original content.
+	 *  Used to compare with the content string to check 
+	 *  difference and deduce if we have to save
+	 */
+	private String originalContent;
+	/** It's the name of the file */
+	private String name;
+	
+	public FileReference(){
+		this.tmp=true;
+		this.content=DEFAULT_SOURCE;
+		this.originalContent=this.content;
+		this.file=null;
+		this.name="";
+	}
+	
+	public FileReference(File file){
+		this();
+		setFile(file);
+	}
+	
+	public String getContent() {
+		return content;
+	}
+	
+	public File getFile() {
+		return file;
+	}
+	
+	public String getName() {
+		return name;
+	}
+	
+	public Boolean hasToSave(){
+		return (!content.equals(originalContent));
+	}
+	
+	public Boolean isTmp(){
+		return this.tmp;
+	}
+	
+	public Boolean save(){
+		if(file==null||isTmp()){
+			throw new IllegalStateException("Can not save an tmp file" +
+					", please give a location");
+		}
+		try {
+			FileManager.save(file.getAbsolutePath(), this.getContent(), false,
+					true);
+			originalContent=this.getContent();
+			return true;
+		} catch (Throwable e) {
+			return false;
+		}
+	}
+	
+	public void setContent(String content) {
+		this.content = content;
+	}
+	
+	public void setFile(File file) {
+		if(!file.exists()||file.isDirectory()){
+			throw new IllegalArgumentException("File "+file+" doesn't" +
+					" exist or is a dirctory");
+		}
+		this.file=file;
+		this.setContent(FileManager.load(file.getAbsolutePath(), true));
+		this.setName(this.file.getName());
+		this.originalContent=this.getContent();
+		this.tmp=false;
+	}
+	
+	private void setName(String name){
+		setName(name,false);
+	}
+	
+	private void setName(String name, boolean rename) {
+		this.name = name;
+		if(file!=null&&rename){
+			File newFile=new File(file.getParentFile(),name);
+			file.renameTo(newFile);
+			setFile(file);
+		}
+	}
+	
+	@Override
+	public boolean equals(Object o){
+		if(o instanceof FileReference){
+			if(((FileReference) o).isTmp()||this.isTmp()){
+				return false;
+			}
+			if(((FileReference) o).getFile().getAbsolutePath().equals(this.getFile().getAbsolutePath())){
+				return true;
+			} else {
+				return false;
+			}
+		} else {
+			return false;
+		}
+	}
+	
+	private ArrayList<ActionListener> als;
+	
+	public void addChangeListener(ActionListener al){
+		if(!als.contains(al))
+			als.add(al);
+	}
+	
+	public void removeChangeListener(ActionListener al){
+		if(als.contains(al))
+			als.remove(al);
+	}
+}
Index: src/org/javascool/gui/editor/completion-macros.xml
===================================================================
--- src/org/javascool/gui/editor/completion-macros.xml	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/completion-macros.xml	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<keywords>
+    <!-- 
+#####################
+    Stdin 
+#####################
+    -->
+    <!-- ReadString -->
+    <keyword name="readString" title="Stocke une chaîne de caractères dans une variable">
+        <doc>Crée une variable s qui va contenir une chaîne de caractères demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>String s = readString("question");</code>
+    </keyword>
+    <keyword name="readString" title="Demande à l'utilisateur une chaîne de caractères">
+        <doc>Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
+        </doc>
+        <code>readString()</code>
+    </keyword>
+    <!-- ReadInteger -->
+    <keyword name="readInteger" title="Stocke un entier dans une variable">
+        <doc>Crée une variable n qui va contenir un int demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>int n = readInteger("question");</code>
+    </keyword>
+    <keyword name="readInteger" title="Demande un nombre entier à l'utilisateur">
+        <doc>Lit un nombre entier dans une fenêtre présentée à l'utilisateur.</doc>
+        <code>readInteger()</code>
+    </keyword>
+    <!-- ReadDecimal -->
+    <keyword name="readDecimal" title="Stocke un nombre décimal dans une variable">
+        <doc>Crée une variable x qui va contenir un double demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>double x = readDecimal("question");</code>
+    </keyword>
+    <keyword name="readDecimal" title="Demande un nombre décimal à l'utilisateur">
+        <doc>Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.</doc>
+        <code>readDecimal()</code>
+    </keyword>
+    <!-- ReadBoolean -->
+    <keyword name="readBoolean" title="Stocke un booléen dans une variable">
+        <doc>Crée une variable b qui va contenir un booléen demandé à l'utilisateur, dans une fenêtre 'oui' ou 'non'.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>boolean b = readBoolean("question");</code>
+    </keyword>
+    <keyword name="readBoolean" title="Demande un booléen à l'utilisateur">
+        <doc>Lit une valeur booléenne dans une fenêtre 'oui''ou 'non' présentée à l'utilisateur.</doc>
+        <code>readBoolean()</code>
+    </keyword>
+    <!-- 
+#####################
+    Stdin 
+#####################
+    -->
+    <keyword name="println" title="Affiche du texte dans la console">
+        <doc>Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un o'jet sur la console avec un retour à la ligne.</doc>
+        <code>println("");</code>
+    </keyword>
+    <keyword name="print" title="Affiche du texte dans la console">
+        <doc>Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console sans retour à la ligne.</doc>
+        <code>print("");</code>
+    </keyword>
+    <!-- 
+#####################
+    Macros
+#####################
+    -->
+    <keyword name="random" title="Génère un entier aléatoirement">
+        <doc>Renvoie un nombre entier aléatoire uniformément distribué entre deux valeurs entières (maximum inclus).
+        Ici: entre 0 et 100.</doc>
+        <code>random(0, 100);</code>
+    </keyword>
+    <keyword name="equal" title="Vérifie si deux Strings sont égales">
+        <doc>Renvoie true si deux chaînes de caratères sont égales, faux sinon.</doc>
+        <code>equal("","")</code>
+    </keyword>
+    <keyword name="sleep" title="Fait faire une pause au programme">
+        <doc>Temporise une durée fixée. Il prend un paramètre optionnel qui est la durée de pause en milli-secondes.
+        Ici: 1000 milli-secondes, docn 1 seconde.</doc>
+        <code>sleep(1000);</code>
+    </keyword>
+    <keyword name="assertion" title="Assert l'execution de Java's cool">
+        <doc>Vérifie une assertion et arrête le code si elle est fausse. Il prend un paramètre booléen obligatoire qui est la condition.
+Si elle est fausse, le programme s'arrête.</doc>
+        <code>assertion(true);</code>
+    </keyword>
+    <keyword name="getIcon" title="Charge une image">
+        <doc>Renvoie une icone stockée dans le JAR de l'application. Il prend un paramètre obligatoire qui est l'emplacement de l'icone.
+        Ici: une des icônes de JavaScool.</doc>
+        <code>getIcon("org/javascool/widget/icons/play.png");</code>
+    </keyword>
+    <keyword name="openUrl" title="Ouvre le navigateur du système">
+        <doc>Ouvre une URL (Universal Resource Location) dans un navigateur extérieur. Il prend un paramètre obligatoire qui est L'URL à afficher.</doc>
+        <code>openUrl("http://www.google.fr");</code>
+    </keyword>
+    <!-- 
+#####################
+    Java
+#####################
+    -->
+    <keyword name="if" title="Instruction conditionnelle">
+        <doc>Vérifie la condition et si elle est vraie, exécute le bloc d'instructions.</doc>
+        <code>  if(true) {
+    // CodeSiOui
+  }</code>
+    </keyword>
+    <keyword name="if/else" title="Instruction conditionnelle avec alternative">
+        <doc>Vérifie la condition et si elle est vraie, exécute le 1er bloc d'instructions. Si elle est fause, exécute le 2ème bloc</doc>
+        <code>  if(true) {
+    // CodeSiOui
+  } else {
+    // CodeSiNon
+  }</code>
+    </keyword>
+    <keyword name="while" title="Boucle sur un bloc d'instruction, selon une condition">
+        <doc>Tant que la condition est vraie, exécute le bloc d'instructions.</doc>
+        <code>  while(/*condition*/) {
+    // Code
+  }</code>
+    </keyword>
+    <keyword name="for" title="Boucle sur un bloc d'instruction, avec un compteur">
+        <doc>Tant que la valeur de i est plus petite que la valeur de n, exécute le bloc d'instructions. Le code s'exécute donc n fois.</doc>
+        <code><![CDATA[  for(int i = 0; i < n; i++) {
+    // Code
+  }]]></code>
+    </keyword>
+</keywords>
Index: src/org/javascool/gui/editor/JVSXMLCompletion.java
===================================================================
--- src/org/javascool/gui/editor/JVSXMLCompletion.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/JVSXMLCompletion.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,231 @@
+/*
+ *  Edited from JvsXMLCompletion.java - Parses XML representing code completion for a
+ * C-like language.
+ * Copyright (C) 2010 Robert Futrell
+ * robert_futrell at users.sourceforge.net
+ * http://fifesoft.com/rsyntaxtextarea
+ */
+package org.javascool.gui.editor;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import org.fife.ui.autocomplete.BasicCompletion;
+import org.fife.ui.autocomplete.Completion;
+import org.fife.ui.autocomplete.CompletionProvider;
+import org.fife.ui.autocomplete.DefaultCompletionProvider;
+import org.fife.ui.autocomplete.ShorthandCompletion;
+import org.javascool.macros.Macros;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+/**
+ * Parser for an XML file describing a procedural language such as JVS.<p>
+ *
+ * @version 1.0
+ */
+class JVSXMLCompletion extends DefaultHandler {
+
+    /**
+     * The completions found after parsing the XML.
+     */
+    private List<Completion> completions;
+    /**
+     * The provider we're getting completions for.
+     */
+    private CompletionProvider provider;
+    /**
+     * The completion provider to use when loading classes, such as custom
+     * {@link FunctionCompletion}s.
+     */
+    private ClassLoader completionCL;
+    private String name;
+    private StringBuffer desc;
+    private String shortDesc;
+    private StringBuffer code;
+    private boolean doingKeywords;
+    private boolean inKeyword;
+    private boolean gettingDoc;
+    private boolean gettingCode;
+    private boolean inCompletionTypes;
+    /**
+     * The class loader to use to load custom completion classes, such as
+     * the one defined by {@link #funcCompletionType}.  If this is
+     * <code>null</code>, then a default class loader is used.  This field
+     * will usually be <code>null</code>.
+     */
+    private static ClassLoader DEFAULT_COMPLETION_CLASS_LOADER;
+
+    /**
+     * Constructor.
+     *
+     * @param provider The provider to get completions for.
+     * @see #reset(CompletionProvider)
+     */
+    public JVSXMLCompletion(CompletionProvider provider) {
+        this(provider, null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param provider The provider to get completions for.
+     * @param cl The class loader to use, if necessary, when loading classes
+     *        from the XML  (custom {@link FunctionCompletion}s, for example).
+     *        This may be <code>null</code> if the default is to be used, or
+     *        if the XML does not define specific classes for completion types.
+     * @see #reset(CompletionProvider)
+     */
+    public JVSXMLCompletion(CompletionProvider provider, ClassLoader cl) {
+        this.provider = provider;
+        this.completionCL = cl;
+        if (completionCL == null) {
+            // May also be null, but that's okay.
+            completionCL = DEFAULT_COMPLETION_CLASS_LOADER;
+        }
+        completions = new ArrayList<Completion>();
+        desc = new StringBuffer();
+        code = new StringBuffer();
+    }
+
+    /**
+     * Called when character data inside an element is found.
+     */
+    @Override
+    public void characters(char[] ch, int start, int length) {
+        if (gettingDoc) {
+            desc.append(ch, start, length);
+        }
+        if (gettingCode) {
+            code.append(ch, start, length);
+        }
+    }
+
+    private BasicCompletion createCompletion() {
+        BasicCompletion bc = new BasicCompletion(provider, name);
+        if (code.length() > 0) {
+            bc = new ShorthandCompletion(provider, name, code.toString());
+            code = new StringBuffer();
+        }
+        if (desc.length() > 0) {
+            bc.setSummary(desc.toString());
+            desc = new StringBuffer();
+        }
+        if (shortDesc.length() > 0) {
+            bc.setShortDescription(shortDesc.toString());
+            shortDesc = "";
+        }
+        return bc;
+    }
+
+    /**
+     * Called when an element is closed.
+     */
+    @Override
+    public void endElement(String uri, String localName, String qName) {
+
+        if ("keywords".equals(qName)) {
+            doingKeywords = false;
+        } else if (doingKeywords) {
+
+            if ("keyword".equals(qName)) {
+                Completion c = null;
+                c = this.createCompletion();
+                completions.add(c);
+                inKeyword = false;
+            } else if (inKeyword) {
+                if ("doc".equals(qName)) {
+                    gettingDoc = false;
+                }
+                if ("code".equals(qName)) {
+                    gettingCode = false;
+                }
+            }
+
+        } else if (inCompletionTypes) {
+            if ("completionTypes".equals(qName)) {
+                inCompletionTypes = false;
+            }
+        }
+
+    }
+
+    /**
+     * Resets this parser to grab more completions.
+     *
+     * @param provider The new provider to get completions for.
+     */
+    public void reset(CompletionProvider provider) {
+        this.provider = provider;
+        completions.clear();
+        doingKeywords = inKeyword = gettingDoc = false;
+        desc = new StringBuffer();
+        code = new StringBuffer();
+    }
+
+    /**
+     * Sets the class loader to use when loading custom classes to use for
+     * various {@link Completion} types, such as {@link FunctionCompletion}s,
+     * from XML.<p>
+     *
+     * Users should very rarely have a need to use this method.
+     *
+     * @param cl The class loader to use.  If this is <code>null</code>, then
+     *        a default is used.
+     */
+    public static void setDefaultCompletionClassLoader(ClassLoader cl) {
+        DEFAULT_COMPLETION_CLASS_LOADER = cl;
+    }
+
+    /**
+     * Called when an element starts.
+     */
+    @Override
+    public void startElement(String uri, String localName, String qName,
+            Attributes attrs) {
+        if ("keywords".equals(qName)) {
+            doingKeywords = true;
+        } else if (doingKeywords) {
+            if ("keyword".equals(qName)) {
+                name = attrs.getValue("name");
+                shortDesc = attrs.getIndex("title") > -1 ? attrs.getValue("title") : "";
+                inKeyword = true;
+            } else if (inKeyword) {
+                if ("doc".equals(qName)) {
+                    gettingDoc = true;
+                }
+                if ("code".equals(qName)) {
+                    gettingCode = true;
+                }
+            }
+        }
+    }
+
+    public List<Completion> getCompletions() {
+        return this.completions;
+    }
+    
+    public static DefaultCompletionProvider readCompletionToProvider(String file,DefaultCompletionProvider cp){
+        SAXParserFactory factory = SAXParserFactory.newInstance();
+        JVSXMLCompletion handler = new JVSXMLCompletion(cp, ClassLoader.getSystemClassLoader());
+        BufferedInputStream bin = new BufferedInputStream(ClassLoader.getSystemClassLoader().getResourceAsStream(file));
+        try {
+            SAXParser saxParser = factory.newSAXParser();
+            saxParser.parse(bin, handler);
+            List<Completion> completions = handler.getCompletions();
+            cp.addCompletions(completions);
+        } catch (Exception ex) {
+            Macros.message("Erreur lors de la lecture de la librairie de<br/>complétion vérifier si le fichier xml<br/>est correctement écrit.<hr><i>Erreur : "+ex.getMessage()+"</i>", true);
+        } finally {
+            try {
+                bin.close();
+            } catch (IOException ex) {
+                throw new RuntimeException(ex.toString());
+            }
+        }
+        return cp;
+    }
+}
\ No newline at end of file
Index: src/org/javascool/gui/editor/FileKit.java
===================================================================
--- src/org/javascool/gui/editor/FileKit.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/FileKit.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,62 @@
+package org.javascool.gui.editor;
+
+import java.util.ArrayList;
+
+/** Ce Kit définit les fonctions de base du système d'onglet.
+ * 
+ */
+public interface FileKit {
+
+	/** Retourne l'éditeur ouvert pour le fichier donné.
+	 * @param file La référance au fichier
+	 * @return L'EditorKit qui y correspond ou null si le fichier n'est pas ouvert.
+	 */
+	public abstract EditorKit getEditorForFile(FileReference file);
+
+	/** Retourne la liste de tous les fichiers ouverts.
+	 * @return Les fichiers ouverts
+	 */
+	public abstract ArrayList<FileReference> getOpenedFiles();
+
+	/** Ouvre un fichier.
+	 * @param file La référence à ouvrir
+	 * @return true en cas de succès, sinon false.
+	 */
+	public abstract boolean openFile(FileReference file);
+
+	/** Demande à l'utilisateur la sauvegarde des fichiers.
+	 * @return true si tous les fichiers sont sauvgardé, sinon false.
+	 */
+	public abstract boolean saveAllFiles();
+
+	/** Dit si tous les fichiers sont enregistrés.
+	 * @return true, pour oui, false, pour non
+	 */
+	public abstract boolean isAllFilesSaved();
+
+	/** Ferme le fichier en cours d'édition sans enregistrer.
+	 * @return true en cas de succès, sinon false.
+	 */
+	public abstract boolean closeCurrentFile();
+
+	/** Enregistre le fichier en cours d'édition.
+	 * @return  true en cas de succès, sinon false.
+	 */
+	public abstract boolean saveCurrentFile();
+
+	/** Enregistre sous le fichier en cours d'édition
+	 * @return  true en cas de succès, sinon false.
+	 */
+	public abstract boolean saveAsCurrentFile();
+	
+	/** Enregistre le fichier à un index donné.
+	 * @param index L'index du fichier
+	 * @return  true en cas de succès, sinon false.
+	 */
+	public abstract boolean saveFileAtIndex(int index);
+
+	/** Retourne l'éditeur affiché à l'écran.
+	 */
+	public abstract EditorKit getCurrentEditor();
+
+}
\ No newline at end of file
Index: src/org/javascool/gui/editor/FormatCodeAction.java
===================================================================
--- src/org/javascool/gui/editor/FormatCodeAction.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/FormatCodeAction.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,27 @@
+package org.javascool.gui.editor;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+import javax.swing.JTextArea;
+
+import org.javascool.core.JvsBeautifier;
+
+public class FormatCodeAction extends AbstractAction{
+
+	private static final long serialVersionUID = -1107044277364712002L;
+	
+	private JTextArea textArea;
+
+	public FormatCodeAction(JTextArea jta){
+		super();
+		this.putValue(NAME, "Formater le code");
+		textArea=jta;
+	}
+	
+	@Override
+	public void actionPerformed(ActionEvent e) {
+		textArea.setText(JvsBeautifier.run(textArea.getText()));
+	}
+
+}
Index: src/org/javascool/gui/editor/EditorKit.java
===================================================================
--- src/org/javascool/gui/editor/EditorKit.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/EditorKit.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,74 @@
+package org.javascool.gui.editor;
+
+/** Ce kit définit les fonctions de base d'un Editeur de Code.
+ * Les fonctions de EditorKit sont définit de sorte a donner une base à
+ * un editeur de code qui serais créé pour Java's cool
+ */
+public interface EditorKit {
+
+	/** Donne la référence du fichier en cours d'édition.
+	 * @return La référence du fichier, ne peut pas être nul.
+	 */
+	public abstract FileReference getFile();
+
+	/** Donne le nom à afficher pour l'éditeur en cours.
+	 * Ce nom est utilisé par exemple dans le titre de l'onglet
+	 * @return Le nom de l'éditeur
+	 */
+	public abstract String getName();
+
+	/** Modifie le fichier en cours d'édition.
+	 * Assigne une nouvelle référance à l'éditeur, le contenu de ce dernier
+	 * doit alors changer
+	 * @param file Le fichier à assigner
+	 */
+	public abstract void setFile(FileReference file);
+
+	/** Retourne le texte de l'éditeur
+	 * @return Le code de l'éditeur
+	 */
+	public abstract String getText();
+
+	/** Dit si l'éditeur doit être sauvegarder.
+	 * Cette fonction est utilisé par Java's Cool lors de sa fermeture afin
+	 * d'être sûr que les fichiers ont été sauvegardé
+	 * @return true si il doit être sauvegarder, false dans le cas contraire
+	 */
+	public abstract Boolean hasToSave();
+
+	/** Supprime toute les lignes mises en évidence dans l'éditeur.
+	 * @see signalLine(int line)
+	 */
+	public abstract void removeLineSignals();
+
+	/** Sauvegarde le contenu en cours d'édition dans le fichier.
+	 * Si ce fichier est temporaire, la fonction demande à l'utilisateur
+	 * le sauvegarder
+	 * @return true si le fichier est sauvegardé, sinon, false
+	 */
+	public abstract Boolean save();
+
+	/** Demande la sauvegarde du fichier avant la fermeture
+	 * Cette fonction doit demander à l'utilisateur si il veut enregistrer
+	 * @return true si l'utilisateur a refusé l'enregistrement ou que le fichier a été sauvegardé, sinon, false
+	 */
+	public abstract boolean saveBeforeClose();
+
+	/** Assigne un texte à l'éditeur
+	 * @param text Le text à assigner
+	 */
+	public abstract void setText(String text);
+
+	/** Met en évidence une ligne de l'éditeur
+	 * @param line La ligne à mettre en évidence
+	 */
+	public abstract void signalLine(int line);
+
+	/** Sauvegarde une copie du fichier
+	 * Agit comme save() et en considérent le fichier comme temporaire même
+	 * si il ne l'est pas.
+	 * @return true si le fichier est sauvegardé, sinon, false
+	 */
+	public abstract boolean saveAs();
+
+}
\ No newline at end of file
Index: src/org/javascool/gui/editor/JVSEditorsPane.java
===================================================================
--- src/org/javascool/gui/editor/JVSEditorsPane.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/JVSEditorsPane.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,158 @@
+package org.javascool.gui.editor;
+
+import java.awt.Component;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.util.ArrayList;
+
+import org.javascool.widgets.TabbedPane;
+
+/** The JVSFileTabs
+ * A powerful JVSTabs to manage a multi-file editing. It only support JVSFile.
+ */
+public class JVSEditorsPane extends TabbedPane implements PropertyChangeListener, FileKit {
+
+	private static final long serialVersionUID = -9098509565334829901L;
+
+	private static JVSEditorsPane instance;
+
+	public static JVSEditorsPane getInstance(){
+		if(instance==null){
+			instance=new JVSEditorsPane();
+		}
+		return instance;
+	}
+
+	protected JVSEditorsPane(){
+		super();
+	}
+
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#getEditorForFile(org.javascool.gui.editor.JVSFileReferance)
+	 */
+	@Override
+	public JVSEditor getEditorForFile(FileReference file){
+		for(int i=0;i<this.getTabCount();i++)
+			if(this.getComponentAt(i) instanceof JVSEditor)
+				if(file.equals(((EditorKit) this.getComponentAt(i)).getFile()))
+					return ((JVSEditor) this.getComponentAt(i));
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#getOpenedFiles()
+	 */
+	@Override
+	public ArrayList<FileReference> getOpenedFiles(){
+		ArrayList<FileReference> al=new ArrayList<FileReference>();
+		for(int i=0;i<this.getTabCount();i++){
+			Component co=this.getComponentAt(i);
+			if(co instanceof JVSEditor)
+				al.add(((EditorKit) co).getFile());
+		}
+		return al;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#openFile(org.javascool.gui.editor.JVSFileReferance)
+	 */
+	@Override
+	public boolean openFile(FileReference file){
+		if(getOpenedFiles().contains(file)){
+			setSelectedComponent(getEditorForFile(file));
+			return false;
+		}
+		JVSEditor editor=new JVSEditor(file);
+		((JVSEditor)add(editor)).addPropertyChangeListener("name", this);
+		revalidate();
+		repaint();
+		return true;
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#saveAllFiles()
+	 */
+	@Override
+	public boolean saveAllFiles(){
+		boolean r=true;
+		for(int i=0;i<this.getTabCount()&&r;i++){
+			Component co=this.getComponentAt(i);
+			if(co instanceof JVSEditor)
+				r=r&&((EditorKit)co).saveBeforeClose();
+			if(r)
+				this.removeTabAt(i);
+		}
+		return r;
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#isAllFilesSaved()
+	 */
+	@Override
+	public boolean isAllFilesSaved(){
+		for(int i=0;i<this.getTabCount();i++){
+			Component co=this.getComponentAt(i);
+			if(co instanceof JVSEditor)
+				if(((EditorKit)co).hasToSave())
+					return false;
+		}
+		return true;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#saveCurrentFile()
+	 */
+	@Override
+	public boolean saveCurrentFile() {
+		if(getCurrentEditor().save())
+			return true;
+		return false;
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.javascool.gui.editor.EditorTabs#getCurrentEditor()
+	 */
+	@Override
+	public EditorKit getCurrentEditor(){
+		if(getComponentAt(getSelectedIndex()) instanceof JVSEditor)
+			return ((EditorKit)getComponentAt(getSelectedIndex()));
+		return null;
+	}
+
+	@Override
+	public void propertyChange(PropertyChangeEvent pce) {
+		if(pce.getSource() instanceof JVSEditor&&pce.getPropertyName().equals("name")){
+			setTitleAt(this.indexOfComponent((JVSEditor)pce.getSource()), ((EditorKit)pce.getSource()).getName());
+		}
+	}
+
+	@Override
+	public boolean saveFileAtIndex(int index) {
+		Component co=this.getComponentAt(index);
+		if(co instanceof JVSEditor)
+			return ((EditorKit)co).saveBeforeClose();
+		return true;
+	}
+	
+	public boolean isTabClosable(int tabIndex) {
+		if(getTabCount()<2)
+			return false;
+		return saveFileAtIndex(tabIndex);
+	}
+
+	@Override
+	public boolean saveAsCurrentFile() {
+		if(getCurrentEditor().saveAs())
+			return true;
+		return false;
+	}
+
+	@Override
+	public boolean closeCurrentFile() {
+		if(getCurrentEditor()!=null&&getTabCount()>1){
+			removeTabAt(indexOfComponent((Component) getCurrentEditor()));
+			return true;
+		}
+		return false;
+	}
+}
Index: src/org/javascool/gui/editor/JVSTabs.java
===================================================================
--- src/org/javascool/gui/editor/JVSTabs.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/JVSTabs.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,246 @@
+package org.javascool.gui.editor;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Cursor;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.ImageIcon;
+import javax.swing.JComponent;
+import javax.swing.JPanel;
+import javax.swing.JTabbedPane;
+
+import org.javascool.macros.Macros;
+
+/** Create a JTabbedPane with closable Tabs
+ * Add components which implements ClosableComponent and they will have a cross to be closed.
+ */
+public class JVSTabs extends JTabbedPane{
+ 
+	private static final long serialVersionUID = 2304963236664505495L;
+
+	public static final String TAB_CLOSABLE="tab_closable";
+
+	private TabCloseUI closeUI = new TabCloseUI(this);
+
+	private static boolean isComponentClosable(Component component){
+		if(component instanceof JComponent)
+			if(((JComponent) component).getClientProperty(TAB_CLOSABLE)==Boolean.TRUE)
+				return true;
+		return false;
+	}
+
+	public static void setComponentClosable(JComponent component){
+		component.putClientProperty(TAB_CLOSABLE,Boolean.TRUE);
+	}
+
+	public void paint(Graphics g){
+		super.paint(g);
+		closeUI.paint(g);
+	}
+
+	public void addTab(String title, Component component) {
+		if(isComponentClosable(component))
+			super.addTab(title+"    ", component);
+		else
+			super.addTab(title, component);
+	}
+
+	public void setTitleAt(int index, String title){
+		if(isComponentClosable(getComponentAt(index))&&getTabCount()>1)
+			title=title+"    ";
+		super.setTitleAt(index, title);
+	}
+
+
+	public String getTabTitleAt(int index) {
+		return super.getTitleAt(index).trim();
+	}
+
+	private class TabCloseUI implements MouseListener, MouseMotionListener {
+		private JVSTabs  tabbedPane;
+		private int closeX = 2 ,closeY = 2, meX = 0, meY = 0;
+		private int selectedTab;
+		private final int  width = 7, height = 7;
+		private Rectangle rectangle = new Rectangle(0,0,width, height);
+		public TabCloseUI(JVSTabs pane) {
+
+			tabbedPane = pane;
+			tabbedPane.addMouseMotionListener(this);
+			tabbedPane.addMouseListener(this);
+		}
+		public void mouseEntered(MouseEvent me) {}
+		public void mouseExited(MouseEvent me) {}
+		public void mousePressed(MouseEvent me) {}
+		public void mouseClicked(MouseEvent me) {}
+		public void mouseDragged(MouseEvent me) {}
+
+
+
+		public void mouseReleased(MouseEvent me) {
+			if(closeUnderMouse(me.getX(), me.getY())){
+				boolean isToCloseTab = isTabClosable(selectedTab);
+				if (isToCloseTab && selectedTab > -1){			
+					tabbedPane.removeTabAt(selectedTab);
+				}
+				selectedTab = tabbedPane.getSelectedIndex();
+			}
+		}
+
+		public void mouseMoved(MouseEvent me) {	
+			meX = me.getX();
+			meY = me.getY();			
+			if(mouseOverTab(meX, meY)){
+				controlCursor();
+				tabbedPane.repaint();
+			}
+		}
+
+		private void controlCursor() {
+			if(tabbedPane.getTabCount()>0)
+				if(closeUnderMouse(meX, meY)){
+					tabbedPane.setCursor(new Cursor(Cursor.HAND_CURSOR));
+				}
+				else{
+					tabbedPane.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
+				}	
+		}
+
+		private boolean closeUnderMouse(int x, int y) {		
+			rectangle.x = closeX;
+			rectangle.y = closeY;
+			return rectangle.contains(x,y);
+		}
+
+		public void paint(Graphics g) {
+
+			int tabCount = tabbedPane.getTabCount();
+			for(int j = 0; j < tabCount; j++)
+				if(isComponentClosable(getComponentAt(j))){			
+					int x = tabbedPane.getBoundsAt(j).x + tabbedPane.getBoundsAt(j).width -width-6;
+					int y = tabbedPane.getBoundsAt(j).y +7;
+					if(tabCount>1){
+						setTitleAt(j, getTabTitleAt(j));
+						drawClose(g,x,y);
+					} else {
+						setTitleAt(j, getTabTitleAt(j));
+					}
+				}
+		}
+
+		private void drawClose(Graphics g, int x, int y) {
+			if(tabbedPane != null && tabbedPane.getTabCount() > 0){
+				Graphics2D g2 = (Graphics2D)g;				
+				drawColored(g2, isUnderMouse(x,y)? Color.RED : Color.WHITE, x, y);
+			}
+		}
+
+		private void drawColored(Graphics2D g2, Color color, int x, int y) {
+			g2.setStroke(new BasicStroke(4));
+			g2.setColor(Color.BLACK);
+			g2.drawLine(x, y, x + width, y + height);
+			g2.drawLine(x + width, y, x, y + height);
+			g2.setColor(color);
+			g2.setStroke(new BasicStroke(2));
+			g2.drawLine(x, y, x + width, y + height);
+			g2.drawLine(x + width, y, x, y + height);
+
+		}
+
+		private boolean isUnderMouse(int x, int y) {
+			if(Math.abs(x-meX)<width && Math.abs(y-meY)<height )
+				return  true;		
+			return  false;
+		}
+
+		private boolean mouseOverTab(int x, int y) {
+			int tabCount = tabbedPane.getTabCount();
+			for(int j = 0; j < tabCount; j++)
+				if(tabbedPane.getBoundsAt(j).contains(meX, meY)&&(isComponentClosable(getComponentAt(j)))){
+					selectedTab = j;
+					closeX = tabbedPane.getBoundsAt(j).x + tabbedPane.getBoundsAt(j).width -width-6;
+					closeY = tabbedPane.getBoundsAt(j).y +7;					
+					return true;
+				}
+			return false;
+		}
+
+	}
+	
+	/** Add a tab with a JPanel
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The JPanel to show into the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, JPanel panel) {
+		return this.add(name, icon, panel, null);
+	}
+	/** Add a tab with an Applet
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The Applet to show into the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, Component panel) {
+		if(!icon.equalsIgnoreCase("")) {
+			ImageIcon logo = Macros.getIcon(icon);
+			this.addTab(name, logo, panel);
+		} else
+			this.addTab(name, null, panel);
+		this.revalidate();
+		return name;
+	}
+	/** Add a tab with a JPanel
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The JPanel to show into the tab
+	 * @param tooltip An tooltip for the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, JPanel panel, String tooltip) {
+		if(!icon.equalsIgnoreCase("")) {
+			ImageIcon logo = Macros.getIcon(icon);
+			this.addTab(name, logo, panel, tooltip);
+		} else
+			this.addTab(name, null, panel, tooltip);
+		this.revalidate();
+		return name;
+	}
+	/** Get a JPanel
+	 * @param name The id of JPanel
+	 * @return The JPanel
+	 */
+	public JPanel getPanel(String name) {
+		if(getComponentAt(indexOfTab(name)) instanceof JPanel)
+			return (JPanel) getComponentAt(indexOfTab(name));
+		return null;
+	}
+	/** Delete a tab
+	 * @param name The tab id
+	 */
+	public void del(String name) {
+		this.removeTabAt(this.indexOfTab(name));
+	}
+	/** Switch to a tab
+	 * @param name The id of the tab
+	 */
+	public void switchToTab(String name) {
+		this.setSelectedIndex(this.indexOfTab(name));
+	}
+
+	/** Say if a tab can be closed.
+	 * By default this function return true but it can be override.
+	 * This is in add of {@link ClosableComponent}.isClosable()
+	 */
+	public boolean isTabClosable(int tabIndex) {
+		return true;
+	}
+
+
+}
Index: src/org/javascool/gui/editor/JVSEditor.java
===================================================================
--- src/org/javascool/gui/editor/JVSEditor.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/JVSEditor.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,282 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.javascool.gui.editor;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Event;
+import java.awt.event.ActionEvent;
+import java.awt.event.KeyEvent;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+import javax.swing.AbstractAction;
+import javax.swing.ImageIcon;
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.KeyStroke;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+import javax.swing.text.BadLocationException;
+
+import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
+import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
+import org.fife.ui.rtextarea.Gutter;
+import org.fife.ui.rtextarea.RTextScrollPane;
+import org.javascool.gui.Desktop;
+import org.javascool.tools.FileManager;
+import org.javascool.widgets.MainFrame;
+import org.javascool.widgets.TabbedPane;
+import org.javascool.widgets.ToolBar;
+
+/** Define a JVSEditor
+ * Use JVSEditor to edit jvs files, it can be used as a panel
+ * @author Philippe VIENNE
+ */
+class JVSEditor extends JPanel implements EditorKit{
+
+	private static final long serialVersionUID = 1L;
+	/** Tests if on MacIntosh. */
+	private static boolean isMac() {
+		return System.getProperty("os.name").toUpperCase().contains("MAC");
+	}
+	/** The editor */
+	private RSyntaxTextArea textPane;
+	/** The scroll pane */
+	private RTextScrollPane scrollPane;
+	/** The ToolBar */
+	private ToolBar toolBar;
+	/** The Completion Provider */
+	private JVSAutoCompletionProvider jacp;
+	/** Opened file */
+	private FileReference file;
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#getFile()
+	 */
+	@Override
+	public FileReference getFile() {
+		return file;
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#getName()
+	 */
+	@Override
+	public String getName(){
+		if(file==null)
+			return "Nouveau Fichier";
+		if(file.isTmp())
+			return "Nouveau Fichier";
+		else
+			return file.getName();
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#setFile(org.javascool.gui.editor.JVSFileReferance)
+	 */
+	@Override
+	public void setFile(FileReference file) {
+		this.file = file;
+		textPane.setText(file.getContent());
+		firePropertyChange("name", null, getName());
+	}
+
+	/** Create a new JVSEditor
+	 * Common setup
+	 */
+	public JVSEditor(FileReference file) {
+		super(new BorderLayout());
+		TabbedPane.setComponentClosable(this);
+		this.file=file;
+		textPane = createTextArea();
+
+		jacp=new JVSAutoCompletionProvider(textPane);
+		jacp.setShowDescWindow(true);
+
+		scrollPane=new RTextScrollPane(textPane);
+		scrollPane.getGutter().setBorderColor(Color.BLACK);
+
+		add(scrollPane);
+
+		toolBar=new ToolBar();
+		toolBar.add(new FormatCodeAction(textPane));
+
+		add(toolBar,BorderLayout.NORTH);
+
+		setText(file.getContent());
+	}
+
+	/** TextArea initialization
+	 * Creates the text area for this application.
+	 * @return The text area.
+	 */
+	private RSyntaxTextArea createTextArea() {
+		RSyntaxTextArea textArea = new RSyntaxTextArea();
+		textArea.setCaretPosition(0);
+		textArea.requestFocusInWindow();
+		textArea.setMarkOccurrences(true);
+		textArea.setAntiAliasingEnabled(true);
+		textArea.setText("");
+		textArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);
+
+		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_S, Event.CTRL_MASK);
+		if (isMac()) {
+			key = KeyStroke.getKeyStroke(KeyEvent.VK_S, Event.META_MASK);
+		}
+		KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.CTRL_MASK);
+		if (isMac()) {
+			KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.META_MASK);
+		}
+		textArea.getInputMap().put(key,"save");
+		textArea.getActionMap().put("save", new AbstractAction() {
+
+			private static final long serialVersionUID = 1L;
+
+			@Override
+			public void actionPerformed(ActionEvent e) {
+				save();
+			}
+		});
+		textArea.getDocument().addDocumentListener(new DocumentListener() {
+			public void changedUpdate(DocumentEvent e) {
+				file.setContent(getText());
+			}
+			public void insertUpdate(DocumentEvent e) {}
+			public void removeUpdate(DocumentEvent e) {}
+		});
+		return textArea;
+	}
+
+	/** Get the RSyntaxTextArea */
+	public RSyntaxTextArea getRTextArea() {
+		return textPane;
+	}
+
+	/** Retourne le RTextScrollPane de l'éditeur */
+	public RTextScrollPane getScrollPane() {
+		return scrollPane;
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#getText()
+	 */
+	@Override
+	public String getText() {
+		return textPane.getText();
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#hasToSave()
+	 */
+	@Override
+	public Boolean hasToSave(){
+		return file.hasToSave();
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#removeLineSignals()
+	 */
+	@Override
+	public void removeLineSignals() {
+		getScrollPane().getGutter().removeAllTrackingIcons();
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#save()
+	 */
+	@Override
+	public Boolean save() {
+		if(file.isTmp()){
+			return saveAs();
+		} else {
+			file.setContent(getText());
+			setFile(file);
+			return file.save();
+		}
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#saveAs()
+	 */
+	public boolean saveAs() {
+		JFileChooser jfc=new JFileChooser();
+		jfc.setApproveButtonText(file.isTmp()?"Sauvegarder":"Sauvegarder sous");
+		if(jfc.showSaveDialog(MainFrame.getFrame())==JFileChooser.APPROVE_OPTION){
+			if(!jfc.getSelectedFile().getName().endsWith(FileReference.SOURCE_EXTENTION)){
+				jfc.setSelectedFile(new File(jfc.getSelectedFile().getParentFile(),jfc.getSelectedFile().getName()+FileReference.SOURCE_EXTENTION));
+			}
+			if(jfc.getSelectedFile().exists()){
+				if(JOptionPane.showConfirmDialog(MainFrame.getFrame(), 
+						"Êtes vous sûr de vouloir effacer ce fichier ?", 
+						"Confirmation",
+						JOptionPane.YES_NO_OPTION,
+						JOptionPane.ERROR_MESSAGE)
+						!= JOptionPane.OK_OPTION)
+					return save();
+			}
+			FileManager.save(jfc.getSelectedFile().getAbsolutePath(), "", false, true);
+			file.setFile(jfc.getSelectedFile());
+			return save();
+		} else {
+			return false;
+		}
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#saveBeforeClose()
+	 */
+	@Override
+	public boolean saveBeforeClose() {
+		if(!hasToSave())
+			return true;
+		int result = JOptionPane.showConfirmDialog(
+				Desktop.getInstance().getFrame(),
+				"Voulez vous enregistrer " + getName() + " avant de continuer ?");
+		if (result == JOptionPane.YES_OPTION) {
+			return save();
+		} else if (result == JOptionPane.NO_OPTION) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#setText(java.lang.String)
+	 */
+	@Override
+	public void setText(String text) {
+		textPane.setText(text);
+	}
+
+	/**
+	 * @see org.javascool.gui.editor.Editor#signalLine(int)
+	 */
+	@Override
+	public void signalLine(int line) {
+		Gutter gutter = getScrollPane().getGutter();
+		gutter.setBookmarkingEnabled(true);
+		ImageIcon icon = null;
+		BufferedImage img;
+		try {
+			img = ImageIO.read(ClassLoader.getSystemResourceAsStream("org/javascool/widgets/icons/error.png"));
+			icon = new ImageIcon(img);
+		} catch (IOException ex1) {
+			System.err.println("Dysfonctionnement innatendu ici "+ex1);
+		}
+		try {
+			getRTextArea().setCaretPosition(getRTextArea().getLineStartOffset(line - 1));
+			getScrollPane().getGutter().addLineTrackingIcon(line - 1, icon);
+		} catch (BadLocationException ex) {
+			System.err.println("Dysfonctionnement innatendu ici "+ex);
+		}
+	}
+
+
+}
Index: src/org/javascool/gui/editor/JVSAutoCompletionProvider.java
===================================================================
--- src/org/javascool/gui/editor/JVSAutoCompletionProvider.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/editor/JVSAutoCompletionProvider.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,42 @@
+package org.javascool.gui.editor;
+
+import org.fife.ui.autocomplete.AutoCompletion;
+import org.fife.ui.autocomplete.CompletionProvider;
+import org.fife.ui.autocomplete.DefaultCompletionProvider;
+import org.fife.ui.autocomplete.LanguageAwareCompletionProvider;
+import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
+import org.javascool.core.ProgletEngine;
+
+class JVSAutoCompletionProvider extends AutoCompletion {
+
+	public JVSAutoCompletionProvider(RSyntaxTextArea TextPane) {
+		super(createCodeCompletionProvider());
+		install(TextPane);
+		setAutoCompleteSingleChoices(false);
+		setAutoActivationEnabled(true);
+		setAutoActivationDelay(1500);
+	}
+	
+	@Override
+	public void doCompletion(){
+		if(isAutoCompleteEnabled()){
+			super.doCompletion();
+		}
+	}
+	
+	/**
+	 * Returns the provider to use when editing code.
+	 *
+	 * @return The provider.
+	 */
+	public static CompletionProvider createCodeCompletionProvider() {
+		DefaultCompletionProvider cp = new DefaultCompletionProvider();
+		if(!ProgletEngine.getInstance().getProglet().getCompletion().equals("")) {
+			JVSXMLCompletion.readCompletionToProvider(ProgletEngine.getInstance().getProglet().getCompletion(), cp);
+		}
+		JVSXMLCompletion.readCompletionToProvider("org/javascool/gui/editor/completion-macros.xml", cp);
+		LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(cp);
+		return lacp;
+	}
+
+}
Index: src/org/javascool/tools/ErrorCatcher.java
===================================================================
--- src/org/javascool/tools/ErrorCatcher.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/ErrorCatcher.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,97 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.tools;
+
+// Used to report a throwable
+
+// Used to frame a message
+import java.net.URLEncoder;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import org.javascool.macros.Macros;
+
+/** Détecte et rapporte de manière optimisée des erreurs lors de l'exécution.
+ *
+ * @see <a href="ErrorCatcher.java.html">code source</a>
+ * @serial exclude
+ */
+public class ErrorCatcher {
+  // @factory
+  private ErrorCatcher() {}
+
+  /** Ouvre une fenêtre d'alerte en cas d'exception intempestive et non prise en compte.
+   * <p> Installe un gestionnaire d'exception non interceptée qui recueille des informations sur:
+   * les versions des composants logiciels, le nom du process, la trace de la pile et
+   * l'affiche dans une fenêtre séparée afin d'être recueillies et communiquées par l'utilisateur.</p>
+   * @param header Un texte entête en HTML expliquant à l'utilisateur quoi faire avec cette sortie d'exception.
+   * @param revision Nom et/ou numéro de révision de l'application pour avoir une trace en cas d'erreur.
+   * @param keyword Si différent de null, le message n'est donné à l'utilisateur que si la trace de la pile contient le mot-clé (<tt>org.javascool</tt> par défaut)
+   */
+  public static void setUncaughtExceptionAlert(String header, String revision, String keyword) {
+    uncaughtExceptionAlertHeader = header;
+    uncaughtExceptionKeyword = keyword;
+    System.setProperty("application.revision", "" + revision);
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+                                                @Override
+                                                public void uncaughtException(Thread t, Throwable e) {
+                                                  String s = "", r = "";
+                                                  if(uncaughtExceptionAlertOnce <= 1) {
+                                                    s += uncaughtExceptionAlertHeader + "\n<hr><pre>";
+                                                    for(String p: new String[] { "application.revision", "java.version", "java.home", "os.name", "os.arch", "os.version", "user.name", "user.home", "user.dir" }
+                                                        )
+                                                      s += "> " + p + " = " + System.getProperty(p) + "\n";
+                                                  }
+                                                  try {
+                                                    s += "> localhost = "+ java.net.InetAddress.getLocalHost() + "\n";
+                                                  } catch(Exception er) {}
+                                                  s += "> thread.name = " + t.getName() + "\n";
+                                                  s += "> throwable = " + e + "\n";
+                                                  if(0 < uncaughtExceptionAlertOnce)
+                                                    s += "> count = " + uncaughtExceptionAlertOnce + "\n";
+                                                  s += "> stack-trace = «\n";
+                                                  for(int i = 0; i < t.getStackTrace().length; i++)
+                                                    r += e.getStackTrace()[i] + (i < t.getStackTrace().length - 1 ? "\n" : "»");
+                                                  boolean alert = uncaughtExceptionAlertOnce == 0 && 
+						    (uncaughtExceptionKeyword == null || r.indexOf(uncaughtExceptionKeyword) != -1) &&
+						    (e.toString().indexOf("java.util.ConcurrentModificationException") == -1);
+                                                  s += r + "</pre><hr>";
+						  System.err.println(s);
+                                                  try {
+                                                    s += FileManager.load("http://javascool.gforge.inria.fr?weberroreport="+URLEncoder.encode(s, "utf-8"));
+                                                  } catch(Exception er) {
+                                                    System.err.println("Impossible de lancer l'alerte à travers le web ("+er+")");
+                                                  }
+                                                  if(alert)
+                                                    Macros.message(s, true);
+                                                  uncaughtExceptionAlertOnce++;
+                                                }
+                                              }
+                                              );
+  }
+  public static void setUncaughtExceptionAlert(String header, String revision) {
+    setUncaughtExceptionAlert(header, revision, "org.javascool");
+  }
+  private static String uncaughtExceptionAlertHeader;
+  private static int uncaughtExceptionAlertOnce = 0;
+  private static String uncaughtExceptionKeyword = null;
+
+  /** Impose une version minimale de Java.
+   * <p>Si la version n'est pas correcte, l'application s'arrête et un téléchargement est proposé.</p>
+   * @param version Version de Java 5 pour 1.5, 6 pour 1.6.
+   */
+  public static void checkJavaVersion(int version) {
+    if(new Integer(System.getProperty("java.version").substring(2, 3)) < version) {
+      if(JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(
+           new JFrame(),
+           "<html>Vous n'avez pas une version suffisante de Java<br>"
+           + "cette application requiert Java 1." + version + " ou plus.<br>"
+           + "Voulez vous être redirigé vers le site de téléchargement ?",
+           "Confirmation",
+           JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE))
+        Macros.openURL("http://www.java.com/getjava");
+      System.exit(-1);
+    }
+  }
+}
Index: src/org/javascool/tools/Pml.java
===================================================================
--- src/org/javascool/tools/Pml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Pml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,1038 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+package org.javascool.tools;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.regex.Pattern;
+
+import java.util.ArrayList;
+import java.util.Properties;
+
+/** Définit la syntaxe PML (Programmatic Markup Language) et son DOM (Data Object Model) Java.
+ *
+ * <p> Un contenu PML (pour «Programmatic Métadata Logicalstructure») et une structure-logique minimale (Parametric Minimal Logical-structure)
+ * qui permet de définir les paramètres d'un objet numérique (algorithme, web-service) ou d'interfacer entre des applications.
+ * C'est une forme minimale de structure à-la XML.</p>
+ *
+ * <p> Ses paramètres sont <ul>
+ *   <li>Son <i>tag</i>, c'est à dire le nom qui définit son type.</li>
+ *   <li>Des <i>attributs</i> c'est à dire des valeurs indexes par un nom.</li>
+ *   <li>Des <i>éléments</i> c'est à dire des valeurs indexees par un entier non-négatif <tt>>= 0</tt>.</li>
+ * </ul> Chaque valeur étant elle même un PML ou une chaîne de caractères. Rien de plus.</p>
+ *
+ * <p>La syntaxe est de la forme:
+ * <div style="margin-left: 40px"><tt>"{tag name = value .. element .. }"</tt></div> où <ul>
+ * <li>Les PML sont encapsules avec des accolades <tt>{</tt> .. <tt>}</tt>.</li>
+ * <li>Les String avec des espaces, <tt>{</tt> ou <tt>}</tt> sont encapsulés avec des double quotes <tt>'"'</tt> (en utilisant <tt>'\"'</tt> pour y échapper).</li>
+ * </ul>Cette syntaxe est minimale, proche des langages à accolades (<tt>C/C++, PHP, Java</tt>), facile à lire ou éditer et surtout complètement standar.</p>
+ *
+ * <p>L'analyse syntaxique de PML est <i>tolérante</i> au sens où une valeur est toujours obtenue sans générer d'erreur de syntaxe,
+ * en utilisant des valeurs par défaut: <ul>
+ *  <li> La construction <tt>"name = value .. "</tt> sans accolade sera vue comme une liste de valeur de tag <tt>null</tt>,</li>
+ *  <li> Un attribut sans valeur recevra la valeur <tt>true</tt>,</li>
+ * </ul> etc..</p>
+ *
+ * @see <a href="Pml.java.html">source code</a>
+ * @serial exclude
+ */
+public class Pml {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public Pml() {}
+
+  private HashMap<String, Object> data = new HashMap<String, Object>();
+
+  /** Initialise la PML en la lisant dans une chaîne de caractères.
+   * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(String value) {
+    // Initializes the Pml
+    data = new HashMap<String, Object>();
+    tag = "";
+    parent = null;
+    count = -1;
+    // Parses the string
+    new PmlReader().read(value, this);
+    return this;
+  }
+  /** Initialise la PML en la lisant dans une chaîne de caractères dans un format donné.
+   * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
+   * @param format Les formats possible sont: <div id="input-format"><ul>
+   * <li>"PML" (valeur par défaut).</li>
+   * <li>"XML" pour utiliser les structure-logiques XML de la forme <tt>&lt;tag name = value .. > &lt;element .. &lt;/tag></tt>
+   * <li>"HTM" pour utiliser les structure-logiques HTML.</li>
+   * </ul></div>
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(String value, String format) {
+    format = format.toLowerCase();
+    if("xml".equals(format))
+      return reset(Xml2Xml.run(value, xml2pml), "pml");
+    else if("htm".equals(format) || "html".equals(format))
+      return reset(Xml2Xml.run(Xml2Xml.html2xhtml(value), xml2pml), "pml");
+    else
+      reset(value);
+    return this;
+  }
+  /** Initialise la PML en en recopiant la PML en entrée.
+   * @param pml Le PML à copier.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(Pml pml) {
+    // Initializes the Pml
+    data = new HashMap<String, Object>();
+    tag = "";
+    parent = null;
+    count = -1;
+    if(pml != null) {
+      setTag(pml.getTag());
+      for(String name : pml.attributes())
+        set(name, pml.getChild(name));
+      for(int i = 0; i < pml.getCount(); i++)
+        set(i, pml.getChild(i));
+    }
+    return this;
+  }
+  /** Initialise la PML à partir des arguments d'une ligne de commande.
+   * <p>La méthode s'utilise dans la construction: <pre>
+   * public static void main(String usage[]) {
+   *   Pml arguments = new Pml.reset(usage);
+   * ../..<pre></p>
+   * <p>Il respecte les conventions suivantes: <ul>
+   * <li><tt>-name</tt> définit un paramètre à la valeur true (la syntaxe <tt>--name</tt> est aussi acceptée),</li>
+   * <li><tt>-name value</tt> définit la valeur d'un paramètre,</li>
+   * <li><tt>file</tt> ajoute un élément de type string,</li>
+   * <li><tt>- file</tt> ajoute un élément de type string qui commence par un <tt>-</tt>.</li>
+   *</ul> Par exemple: <tt>command -quiet -level 123 input1 input2</tt> definit la PML <tt>{usage quiet=true level=123 input1 inpu2}</tt>.</p>
+   * @param usage Les éléments de la ligne de commande.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.   
+   */
+  public Pml reset(String[] usage) {
+    reset("{usage}");
+    for(int i = 0; i < usage.length; i++) {
+      if (!"-".equals(usage[i])) {
+	if (usage[i].startsWith("-") && (i == 0 || !"-".equals(usage[i-1]))) {
+	  String name = usage[i].replaceFirst("-+", "");
+	  if (i == usage.length - 1 || usage[i+1].startsWith("-"))
+	    set(name, true);
+	  else
+	    set(name, usage[++i]);
+	} else 
+	  add(usage[i]);
+      }
+    }
+    return this;
+  }
+  /** Retourne la PML sous forme de chaîne de caractères.
+   * @param format de sortie <div id="output-format"><ul>
+   * <li>"RAW" Retourne une chaîne 1D de longueur minimale (par défault).</li>
+   * <li>"TXT" Retourne une chaîne 2D formattée.</li>
+   * <li>"XML" Retourne une structure logique XML,
+   * en réduisant les tag et attributs à des nom XML valides et en considérant les PML sans attribut ni élément comme des chaînes.<li>
+   * <li>"PHP" Retourne un élément de code PHP de la forme:<tt>&lt;php $tag = array("_tag" = getTag(), . . "name" => "value", . . , "element");?></tt>.</li>
+   * <li>"JMF" Retourne un format de fichier de manifeste de JAR de la forme: <tt> name : value \n .. </tt> en omettant le tag et les éléments.</li>
+   * </ul></div>
+   * @return La chaîne qui représente la PML.
+   */
+  public String toString(String format) {
+    format = format.toLowerCase();
+    return "xml".equals(format) ? new XmlWriter().toString(this)
+           : "raw".equals(format) ? new PlainWriter().toString(this, 0)
+           : "php".equals(format) ? new PhpWriter().toString(this)
+           : "jmf".equals(format) ? new JmfWriter().toString(this)
+           : new PlainWriter().toString(this, 180);
+  }
+  @Override
+  public final String toString() {
+    return toString("raw");
+  }
+  /** Initialise la PML en la lisant dans un fichier donné.
+   * @param location  L'URL (Universal Resource Location) de chargement de <a href="FileManager.html#load-format">format standard</a>.
+   * @param format Le format de lecture parmi les <a href="#input-format">formats supportés</a>, par défaut donné par l'extension du fichier.
+   * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().load(..)</tt>.
+   */
+  public final Pml load(String location, String format, boolean utf8) {
+    if (format == null)
+        format = location.replaceAll("^.*\\.([A-Za-z]+)$", "$1");
+    return reset(FileManager.load(location, utf8), format);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location, String format) {
+    return load(location, format, false);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location, boolean utf8) {
+    return load(location, null, utf8);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location) {
+    return load(location, null, false);
+  }
+  /** Sauve la PML dans un fichier donné.
+   * @param location  L'URL (Universal Resource Location) d'écriture de <a href="FileManager.html#save-format">format standard</a>.
+   * @param format Le format d'écriture parmi les <a href="#output-format">formats supportés</a>, par défaut donné par l'extension du fichier.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().save(..)</tt>.
+   */
+  public final Pml save(String location, String format) {
+    FileManager.save(location, toString(format) + "\n");
+    return this;
+  }
+  /**
+   * @see #save(String, String)
+   */
+  public final Pml save(String location) {
+    return save(location, location.replaceAll("^.*\\.([A-Za-z]+)$", "$1"));
+  }
+  /** Definit l'analyseur lexical qui lit la chaîne mot à mot en normlisant les espaces et en titant le caractère '"'. */
+  protected static class TokenReader {
+    /** Definit un élément lexical. */
+    private static class token {
+      String string;
+      int line;
+
+      token(String s, int i0, int i1, int l) {
+        string = s.substring(i0, i1);
+        line = l;
+      }
+      @Override
+      public String toString() {
+        return "#" + line + " \"" + string + "\" ";
+      }
+    }
+    ArrayList<token> tokens;
+    int itoken;
+
+    /** Initialise le lecteur. */
+    public TokenReader reset(String string) {
+      // Initializes the buffer
+      tokens = new ArrayList<token>();
+      itoken = 0;
+      // Split the string into tokens
+      {
+        char[] chars = string.toCharArray();
+        for(int ichar = 0, ln = 0; ichar < chars.length;) {
+          // Skips spaces
+          while(ichar < chars.length && Character.isWhitespace(chars[ichar])) {
+            if(chars[ichar] == '\n')
+              ln++;
+            ichar++;
+          }
+          if(ichar < chars.length) {
+            int ichar0 = ichar;
+            // Detects a quoted string taking "{" "}" and \" constructs into account
+            if(chars[ichar0] == '"') {
+              while(ichar < chars.length && (ichar == ichar0 || chars[ichar] != '"' || chars[ichar - 1] == '\\'))
+                ichar++;
+              ichar++;
+              int ichar1;
+              if((ichar == ichar0 + 3) && ((chars[ichar0 + 1] == '{') || (chars[ichar0 + 1] == '}')))
+                ichar1 = ichar;
+              else {
+                ichar0++;
+                ichar1 = ichar - 1;
+              }
+              tokens.add(new token(string, ichar0, ichar1, ln));
+              // Detects a name
+            } else if(Character.isLetter(chars[ichar0]) || (chars[ichar0] == '_')) {
+              while(ichar < chars.length && (Character.isLetterOrDigit(chars[ichar]) || chars[ichar0] == '_'))
+                ichar++;
+              tokens.add(new token(string, ichar0, ichar, ln));
+              // Detects a number
+            } else if(Character.isDigit(chars[ichar0]) || (chars[ichar0] == '.')) {
+              while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                ichar++;
+              if((ichar < chars.length) && (chars[ichar] == '.')) {
+                ichar++;
+                while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                  ichar++;
+              }
+              if((ichar < chars.length) && ((chars[ichar] == 'E') || (chars[ichar] == 'e'))) {
+                ichar++;
+                if((ichar < chars.length) && ((chars[ichar] == '+') || (chars[ichar] == '-')))
+                  ichar++;
+                while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                  ichar++;
+              }
+              tokens.add(new token(string, ichar0, ichar, ln));
+              // Detects operators and punctuation
+            } else if(isOperator(chars[ichar0])) {
+              while(ichar < chars.length && isOperator(chars[ichar]))
+                ichar++;
+              tokens.add(new token(string, ichar0, ichar, ln));
+            } else
+              tokens.add(new token(string, ichar0, ++ichar, ln));
+          }
+        }
+      }
+      itoken = 0;
+      return this;
+    }
+    private static boolean isOperator(char c) {
+      switch(c) {
+      case '+':
+      case '-':
+      case '*':
+      case '/':
+      case '%':
+      case '&':
+      case '|':
+      case '^':
+      case '=':
+      case '!':
+      case '<':
+      case '>':
+      case '.':
+      case ':':
+        return true;
+      default:
+        return false;
+      }
+    }
+    /** Renvoie un des éléments.
+     * @param next Si 0 renvoie l'élément courant. Si 1 renvoie l'élément à suivre, etc..
+     * @return L'élément ou '}' à l afin du fichier.
+     */
+    public String getToken(int next) {
+      String current = itoken + next < tokens.size() ? tokens.get(itoken + next).string : "}";
+      return current;
+    }
+    /** Teste si il y reste des éléments. */
+    public boolean isNext() {
+      return itoken < tokens.size();
+    }
+    /** Avance à un élément suivant.
+     * @param next Si 1 avance d'un élément, etc..
+     */
+    public void next(int next) {
+      itoken += next;
+    }
+    /** Renvoie la fin de la chaîne. */
+    public String trailer() {
+      String t = "";
+      while(itoken < tokens.size())
+        t += " " + tokens.get(itoken++).string;
+      return t.trim();
+    }
+    /** Teste une condition de syntaxe. */
+    public void check(boolean ok, String message) {
+      if(!ok)
+        System.out.println("Erreur de syntaxe \"" + message + "\", ligne " + (itoken < tokens.size() ? "" + tokens.get(itoken).line + " vers \"" + getToken(0) + "\"" : "finale"));
+    }
+    @Override
+    public String toString() {
+      String s = "[";
+      for(int i = 0; i < tokens.size(); i++)
+        s += (i == itoken ? " ! " : " ") + "\"" + tokens.get(i).string + "\"#" + tokens.get(i).line;
+      return s + " ]";
+    }
+  }
+
+  /** Définit un lecteur de PML. */
+  private static class PmlReader extends TokenReader {
+    /** Lit la chaîne et en affecte les valeurs du PML. */
+    public void read(String string, Pml pml) {
+      reset(string);
+      // Parses the string
+      parse(pml);
+      // Detects the trailer if any
+      String trailer = trailer();
+      if(trailer.length() > 0) {
+        Pml p = new Pml();
+        p.setTag(trailer);
+        pml.set("string_trailer", p);
+      }
+    }
+    /** Effectue l'analyse syntaxique récursive. */
+    private Pml parse(Pml pml) {
+      String b = getToken(0);
+      // Parses a { } Pml construct
+      if("{".equals(b)) {
+        next(1);
+        for(boolean start = true; true; start = false) {
+          String t = getToken(0);
+          if("}".equals(t)) {
+            next(1);
+            break;
+            // Adds an element
+          } else if("{".equals(t)) {
+            Pml p = new Pml();
+            parse(p);
+            pml.add(p);
+            // Adds an attribute
+          } else if("=".equals(getToken(1))) {
+            next(2);
+            if("}".equals(getToken(0)))
+              pml.set(t, "true");
+            else {
+              Pml p = new Pml();
+              parse(p);
+              pml.set(t, p);
+            }
+            // Adds an attribute tag
+          } else if(start) {
+            next(1);
+            pml.setTag(t);
+            // Adds an atomic element
+          } else {
+            Pml p = new Pml();
+            parse(p);
+            pml.add(p);
+          }
+        }
+        // Considers the Pml as a list of name=value
+      } else if("=".equals(getToken(1)))
+        while("=".equals(getToken(1))) {
+          String t = getToken(0);
+          next(2);
+          if("}".equals(getToken(0)))
+            pml.set(t, "true");
+          else {
+            Pml p = new Pml();
+            parse(p);
+            pml.set(t, p);
+          }
+        }
+      // Considers the Pml as a simple string
+      else {
+        pml.setTag(b);
+        next(1);
+      }
+      return pml;
+    }
+  }
+
+  /** Définit le convertisseur de XML en PML. */
+  private static String xml2pml =
+    "<?xml version='1.0' encoding='utf-8'?>\n"
+    + "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n"
+    + "  <xsl:output method='xml' encoding='utf-8' omit-xml-declaration='yes'/>\n"
+    + "  <xsl:template match='*'>\n"
+    + "  {<xsl:value-of select='name(.)'/><xsl:text> </xsl:text>\n"
+    + "    <xsl:for-each select='@*'><xsl:value-of select='name(.)'/>=\"<xsl:value-of select=\"translate(., '&quot;','¨')\"/>\"<xsl:text> </xsl:text></xsl:for-each>\n"
+    + "    <xsl:apply-templates/>\n"
+    + "  }</xsl:template>\n"
+    + "</xsl:stylesheet>";
+
+  /** Définit le convertisseur de PML en chaîne de caractères. */
+  private static class PlainWriter {
+    private StringBuffer string;
+    int width, l;
+
+    /** Convertit la PML en chaîne.
+     * @param pml Le PML à convertir.
+     * @param width si width == 0 retourne une chaîne 1D de longueur minimale, sinon retourne une chaîne 2D de la largeur donnée.
+     * @return La chaîne générée.
+     */
+    public String toString(Pml pml, int width) {
+      if(pml == null)
+        return "null";
+      // Initializes the variables
+      string = new StringBuffer();
+      if(width == 0)
+        write1d(pml);
+      else {
+        this.width = width;
+        l = 0;
+        write2d(pml, 0, 0);
+      }
+      return string.toString();
+    }
+    private void write1d(Pml pml) {
+      if(pml == null) {
+        string.append(" {null} ");
+        return;
+      }
+      string.append("{").append(quote(pml.getTag()));
+      for(String name : pml.attributes()) {
+        string.append(" ").append(quote(name)).append("=");
+        write1d(pml.getChild(name));
+      }
+      for(int n = 0; n < pml.getCount(); n++) {
+        string.append(" ");
+        write1d(pml.getChild(n));
+      }
+      string.append("}");
+    }
+    private boolean write2d(Pml pml, int n, int tab) {
+      if(pml == null) {
+        string.append(" {null} ");
+        return false;
+      }
+      if(pml.getSize() == 0) {
+        boolean ln = n >= 0 && (n == 0 || (pml.getParent() != null&& pml.getParent().getChild(n - 1) != null&& pml.getParent().getChild(n - 1).getSize() > 0));
+        writeln(ln, tab);
+        write(quote(pml.getTag()), tab);
+        return ln;
+      } else {
+        boolean ln = pml.getTag().length() > 1 || "p".equals(pml.getTag());
+        writeln(n >= 0 && ln, tab);
+        write("{" + quote(pml.getTag()), tab);
+        ln = false;
+        for(String name : pml.attributes()) {
+          write(" " + quote(name) + " =", tab);
+          ln |= write2d(pml.getChild(name), -1, tab + 1);
+        }
+        for(int i = 0; i < pml.getCount(); i++)
+          ln |= write2d(pml.getChild(i), i, tab + 2);
+        writeln(ln, tab);
+        write("}", tab);
+        return ln;
+      }
+    }
+    private void writeln(boolean ln, int tab) {
+      if(ln) {
+        string.append("\n");
+        for(int t = 0; t < tab; t++)
+          string.append(" ");
+        l = tab;
+      } else
+        string.append(" ");
+    }
+    private void write(String word, int tab) {
+      if(l + word.length() > width)
+        writeln(false, tab + 1);
+      string.append(word);
+      l += word.length();
+    }
+    /** Retourne la chaîne en tenant compte des "{" "}" et \". */
+    private static String quote(String string) {
+      return string == null ? "null" :
+             string.matches("[a-zA-Z_][a-zA-Z0-9_]*") || "\"{\"".equals(string) || "\"}\"".equals(string) ? string :
+             "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
+    }
+  }
+
+  /** Définit le convertisseur de PML en XMl. */
+  private static class XmlWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en chaîne XML 1D. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "<null/>";
+      write(pml);
+      return string.toString();
+    }
+    private void write(Pml pml) {
+      if(pml.getSize() == 0)
+        string.append(" ").append(pml.getTag().replaceFirst("^\"([{}])\"$", "$1").replaceAll("&", "&amp;").replaceAll("<", "&lt;"));
+      else {
+        string.append(" <").append(toName(pml.getTag()));
+        for(String name : pml.attributes())
+          string.append(" ").append(toName(name)).append("=\"").append(pml.getChild(name).toString().replaceFirst("^\\{(.*)\\}$", "$1").replaceFirst("^\"(.*)\"$", "$1").
+                                                                       replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll("\"", "&quot;")).append("\"");
+        if(pml.getCount() > 0) {
+          string.append(">");
+          for(int n = 0; n < pml.getCount(); n++)
+            write(pml.getChild(n));
+          string.append("</").append(toName(pml.getTag())).append(">");
+        } else
+          string.append("/>");
+      }
+    }
+  }
+
+  /**  Définit le convertisseur de PML en PHP. */
+  private static class PhpWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en tableau PHP. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "<?php $pml = array(); ?>";
+      else {
+	String tag = toName(pml.getTag());
+	if (tag.length() == 0)
+	  tag = "pml";
+        string.append("<?php $").append(tag).append(" = array(\"_tag\" => ").append(quote(pml.getTag()));
+        for(String name : pml.attributes())
+          string.append(", ").append(quote(name)).append(" => ").append(quote(pml.getChild(name)));
+        for(int n = 0; n < pml.getCount(); n++)
+          string.append(", ").append(quote(pml.getChild(n)));
+        string.append("); ?>");
+      }
+      return string.toString();
+    }
+    /** Prends en compte les \". */
+    private static String quote(String string) {
+      return "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
+    }
+    private static String quote(Pml pml) {
+      return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
+    }
+  }
+
+  /**  Définit le convertisseur de PML en JMF. */
+  private static class JmfWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en fichier JMF. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "";
+      else
+        for(String name : pml.attributes())
+          string.append(name).append(": ").append(quote(pml.getChild(name))).append("\n");
+      return string.toString();
+    }
+    /** Elimine les \n. */
+    private static String quote(String string) {
+      return string.replaceAll("\n", " ");
+    }
+    private static String quote(Pml pml) {
+      return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
+    }
+  }
+
+  private static String toName(String string) {
+    if(string.length() > 0) {
+      String c_0 = string.substring(0, 1);
+      String name = c_0.matches("[_-]") || Character.isLetter(c_0.charAt(0)) ? "" : "_";
+      for(int i = 0; i < string.length(); i++) {
+        String c_i = string.substring(i, i + 1);
+        name += c_i.matches("_-") || Character.isLetterOrDigit(c_i.charAt(0)) ? c_i : "_";
+      }
+      return name;
+    } else
+      return string;
+  }
+  /** Renvoie le type de ce PML.
+   * @return The tag définit lors de l'initialisation, sinon le nom de la classe du PML.
+   */
+  public final String getTag() {
+    return tag;
+  }
+  protected final Pml setTag(String value) {
+    tag = value;
+    return this;
+  }
+  private String tag = getClass().getName();
+
+  /** Renvoie le parent du PML si défini.
+   * @return Si ce PML est un sous-partie d'un PML renvoie son parent, sinon renvoie null.
+   */
+  public final Pml getParent() {
+    return parent;
+  }
+  private void setParent(Pml value) {
+    if(parent == null)
+      parent = value;
+  }
+  private Pml parent = null;
+
+  /** Teste si un paramètre de ce PML est défini.
+   * <p>Cet appel est formellement équivalent à <tt>getChild(name) != null</tt></p>
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return True si le paramètre est défini, false sinon.
+   */
+  public final boolean isDefined(String name) {
+    return data.containsKey(name);
+  }
+  /**
+   * @see #isDefined(String)
+   */
+  public final boolean isDefined(int index) {
+    return isDefined(Integer.toString(index));
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML.
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return La valeur du paramètre, ou null si indéfini.
+   */
+  public Pml getChild(String name) {
+    Object o = data.get(name);
+    return o == null ? null : o instanceof Pml ? (Pml) o : new Pml().reset("{\"" + o.toString() + "\"}");
+  }
+  /**
+   * @see #getChild(String)
+   */
+  public final Pml getChild(int index) {
+    return getChild(Integer.toString(index));
+  }
+  /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return La valeur du paramètre, ou null si indéfini en tant que paramètre.
+   */
+  public Object getObject(String name) {
+    return data.get(name);
+  }
+  /**
+   * @see #getObject(String)
+   */
+  public final Object getObject(int index) {
+    return getObject(Integer.toString(index));
+  }
+  /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
+   *
+   *  /** Renvoie la valeur d'un paramètre de ce PML en tant que chaîne.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final String getString(String name, String value) {
+    if(data.get(name) == null)
+      return "";
+    String v = data.get(name).toString();
+    if(v.matches("[{]\".*\"[}]"))
+      v = v.substring(2, v.length() - 2);
+    if(v.matches("[{].*[}]"))
+      v = v.substring(1, v.length() - 1);
+    return v != null ? v : value != null ? value : "";
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(int index, String value) {
+    return getString(Integer.toString(index), value);
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(String name) {
+    return getString(name, null);
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(int index) {
+    return getString(index, null);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant que décimal.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "0".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final double getDecimal(String name, double value) {
+    try {
+      return Double.parseDouble(getString(name));
+    } catch(NumberFormatException e) {
+      return value;
+    }
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(int index, double value) {
+    return getDecimal(Integer.toString(index), value);
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(String name) {
+    return getDecimal(name, 0);
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(int index) {
+    return getDecimal(index, 0);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant qu'entier.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "0".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final int getInteger(String name, int value) {
+    try {
+      return Integer.parseInt(getString(name));
+    } catch(NumberFormatException e) {
+      return value;
+    }
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(int index, int value) {
+    return getInteger(Integer.toString(index), value);
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(String name) {
+    return getInteger(name, 0);
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(int index) {
+    return getInteger(index, 0);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant que boolean.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon false.
+   * @return La valeur true ou false si le paramètre est égal à "true" ou "false" indépendamment de la casse, la valeur par défaut sinon.int
+   */
+  public final boolean getBoolean(String name, boolean value) {
+    String v = getString(name);
+    if(v != null) {
+      if("true".equals(v.toLowerCase()))
+        return true;
+      if("false".equals(v.toLowerCase()))
+        return false;
+    }
+    return value;
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(int index, boolean value) {
+    return getBoolean(Integer.toString(index), value);
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(String name) {
+    return getBoolean(name, false);
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(int index) {
+    return getBoolean(index, false);
+  }
+  /** Définit la valeur d'un paramètre de ce PML.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur du paramètre (en tant que PML, object Java, entier, décimal ou entier). Si null efface la valeur précédente.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
+   */
+  public Pml set(String name, Object value) {
+    // Deletes the attribute value
+    if(value == null) {
+      try {
+        // Shifts removed elements to avoid "null wholes"
+        int i = Integer.parseInt(name), l = getCount() - 1;
+        if((0 <= i) && (i <= l)) {
+          for(int j = i; j < l; j++)
+            data.put(Integer.toString(j), data.get(Integer.toString(j + 1)));
+          data.remove(Integer.toString(l));
+        } else
+          data.remove(name);
+      } catch(NumberFormatException e) {
+        data.remove(name);
+      }
+      // Adds the parameter value
+    } else {
+      data.put(name, value);
+      if(value instanceof Pml)
+        ((Pml) value).setParent(this);
+    }
+    count = -1;
+    return this;
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, Object value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, String value) {
+    if (value == null) {
+      return set(name, (Object) null);
+    } else {
+      Pml v = new Pml();
+      v.reset("\"" + value.replaceAll("\"", "\\\"") + "\"");
+      return set(name, v);
+    }
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, String value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, double value) {
+    return set(name, Double.toString(value));
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, double value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, int value) {
+    return set(name, Integer.toString(value));
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, int value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, boolean value) {
+    return set(name, value ? "true" : "false");
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, boolean value) {
+    return set(Integer.toString(index), value);
+  }
+  /** Elimine la valeur d'un paramètre de ce PML.
+   * <p>Cet appel est formellement équivalent à <tt>set(name, null);</tt></p>
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().del(..)</tt>.
+   */
+  public Pml del(String name) {
+    return set(name, (Pml) null);
+  }
+  /**
+   * @see #del(String)
+   */
+  public final Pml del(int index) {
+    return set(Integer.toString(index), (Pml) null);
+  }
+  /** Ajoute un élément à ce PML.
+   * <p>Cet appel est formellement équivalent à <tt>set(getCount(), value);</tt></p>
+   * @param value La valeur du paramètre (en tant que PML, entier, décimal ou entier).
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().add(..)</tt>.
+   */
+  public final Pml add(Pml value) {
+    int c = getCount();
+    set(c, value);
+    count = ++c;
+    return this;
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(String value) {
+    Pml v = new Pml();
+    v.reset(value);
+    return add(v);
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(double value) {
+    return add(Double.toString(value));
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(int value) {
+    return add(Integer.toString(value));
+  }
+  /**  Définit la valeur de paramètres de ce PML.
+   * @param pml La structure dont on copie les paramètres
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
+   */
+  public final Pml set(Pml pml) {
+    for(String name : pml.attributes())
+      set(name, pml.getObject(name));
+    for(int n = 0; n < pml.getCount(); n++)
+      set(n, pml.getObject(n));
+    return this;
+  }
+  /**
+   * @see #set(Pml)
+   */
+  public final Pml set(Properties pml) {
+    for(String name : pml.stringPropertyNames())
+      set(name, pml.getProperty(name));
+    return this;
+  }
+  /** Renvoie le nombre d'éléments de ce PML.
+   * @return Le nombre d'éléments (indépendamment des attributs), les éléments null étant éliminés
+   */
+  public int getCount() {
+    if(count < 0) {
+      count = 0;
+      for(String key : data.keySet())
+        if(isIndex(key))
+          count = Math.max(Integer.parseInt(key) + 1, count);
+    }
+    return count;
+  }
+  private int count = -1;
+
+  /** Renvoie le nombre de paramètres de ce PML.
+   * @return Le nombre d'attributs et d'éléments. Si 0, ce PML correspond uniquement à une chaîne: son tag.
+   */
+  public int getSize() {
+    return data.size();
+  }
+  /** Définir un itérateur sur les attributs de ce PML.
+   * <p>- Les attributes sont énumérés avec une construction de la forme: <tt>for(String name : pml.attributes()) { Pml value = pml.getChild(name); .. }</tt>.</p>
+   * <p>- Les éléments sont énumérés avec une construction de la forme:  <tt>for(int n = 0; n &lt; pml.getCount(); n++) { Pml value = pml.getChild(n); .. }</tt>.</p>
+   */
+  public final Iterable<String> attributes() {
+    return new Iterable<String>() {
+             @Override
+             public Iterator<String> iterator() {
+               return new Iterator<String>() {
+                        Iterator<String> keys = data.keySet().iterator();
+                        String key;
+
+                        {
+                          nextKey();
+                        }
+
+                        private void nextKey() {
+                          for(key = null; keys.hasNext() && isIndex(key = keys.next()); key = null) {}
+                        }
+                        @Override
+                        public String next() {
+                          String value = key;
+                          nextKey();
+                          return value;
+                        }
+                        @Override
+                        public boolean hasNext() {
+                          return key != null;
+                        }
+                        @Override
+                        public void remove() { throw new UnsupportedOperationException();
+                        }
+               };
+             }
+    };
+  }
+  // @return true if the name is an index
+  private static boolean isIndex(String name) {
+    return index.matcher(name).matches();
+  }
+  static Pattern index = Pattern.compile("[0-9]+");
+
+  /** Renvoie les paramètres de cette PML sous forme de Properties.
+   * @return Une structure Properties contenant attributs et éléments sous forme de chaîne de caractère.
+   */
+  public final Properties toProperties() {
+    Properties properties = new Properties();
+    for(String name : attributes())
+      properties.setProperty(name, getObject(name).toString());
+    for(int n = 0; n < getCount(); n++)
+      properties.setProperty("" + n, getObject(n).toString());
+    return properties;
+  }
+  /** Lanceur du mécanisme de vérification/conversion d'une PML.
+   * @param usage <tt>java org.javascool.tools.Pml input-file [output-file.(pml|xml|php|jmf)]</tt>
+   */
+  public static void main(String[] usage) {
+    if(usage.length > 0)
+      new Pml().load(usage[0]).save(usage.length > 1 ? usage[1] : "stdout:", (usage.length > 1 && usage[1].matches(".*\\.(pml|php|xml|jmf)")) ? usage[1].replaceFirst(".*\\.", "") : "pml");
+  }
+}
Index: src/org/javascool/tools/UserConfig.java
===================================================================
--- src/org/javascool/tools/UserConfig.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/UserConfig.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ *           Philippe.Vienne, Copyright (C) 2011.  All rights reserved.         *
+ *******************************************************************************/
+package org.javascool.tools;
+
+import java.io.File;
+import java.util.Properties;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+/** Permet de stocker des informations dans un fichier de configuration de l'utilisateur.
+ *
+ * @author Philippe Vienne
+ * @see <a href="UserConfig.java.html">code source</a>
+ * @serial exclude
+ */
+public class UserConfig {
+    // @static-instance
+
+    private UserConfig(String applicationName) {
+        this.applicationName = applicationName;
+    }
+    /** Nom de l'application. */
+    private String applicationName;
+    /** Nom du fichier de configuration. */
+    private String configFile = "configuration.xml";
+    /** Table des propriétés de l'application. */
+    private Properties properties = null;
+
+    /** Renvoie le répertoire standard où stocker les données d'une application. */
+    public String getApplicationFolder() {
+        String OS = System.getProperty("os.name").toUpperCase();
+        if (OS.contains("WIN")) {
+            return System.getenv("APPDATA") + "\\" + applicationName + "\\";
+        } else if (OS.contains("MAC")) {
+            return System.getProperty("user.home") + "/Library/Application Support/" + applicationName + "/";
+        } else if (OS.contains("NUX")) {
+            return System.getProperty("user.home") + "/." + applicationName + "/";
+        } else {
+            throw new IllegalStateException("Impossible de définir un répertoire de configuration pour l'application " + applicationName + " sous le système d'exploitation «" + OS + "»");
+        }
+    }
+
+    /** Renvoie la liste de propriétés liées à cette application. */
+    private Properties getProperties() {
+        if (properties == null) {
+            properties = new Properties();
+            try {
+                properties.loadFromXML(new FileInputStream(getApplicationFolder() + configFile));
+            } catch (Exception e) {
+                System.err.println("Dysfonctionnement lors la lecture du fichier de configuration" + e);
+            }
+        }
+        return properties;
+    }
+
+    /** Lit une propriété liée à cette application.
+     * @param name Nom de la propriété.
+     * @param value Valeur par défaut.
+     * @return La valeur de la propriété, si elle définie, sinon null.
+     */
+    public String getProperty(String name, String value) {
+        return getProperties().getProperty(name, value);
+    }
+
+    /**
+     * @see #getProperty(String, String)
+     */
+    public String getProperty(String name) {
+        return getProperty(name, null);
+    }
+
+    /** Ecrit une propriété liée à cette application.
+     * @param name Nom de la propriété.
+     * @param value Valeur de la propriété.
+     * @return Cet objet, permettant de définir la construction <tt>getInstance(..).setProperty(..)</tt>.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la sauvergarde de la propriété.
+     */
+    public UserConfig setProperty(String name, String value) {
+        getProperties().setProperty(name, value);
+        try {
+            new File(getApplicationFolder()).mkdirs();
+            properties.storeToXML(new FileOutputStream(getApplicationFolder() + configFile), "JavaS'Cool user configuration");
+        } catch (Exception e) {
+            throw new RuntimeException("Erreur de la sauvegarde de la configuration de l'application " + applicationName + " dans le fichier " + getApplicationFolder() + configFile);
+        }
+        return this;
+    }
+
+    /** Crée et/ou renvoie l'unique instance de l'objet.
+     * <p>Une application ne peut définir qu'un seul objet de configuration.</p>
+     */
+    public static UserConfig getInstance(String applicationName) {
+        if (userConfig == null) {
+            return userConfig = new UserConfig(theApplicationName = applicationName);
+        } else if (theApplicationName.equals(applicationName)) {
+            return userConfig;
+        } else {
+            throw new IllegalArgumentException("Appel incohérent à la configuration de l'application avec deux noms différents " + theApplicationName + " puis " + applicationName);
+        }
+    }
+    private static String theApplicationName = null;
+    private static UserConfig userConfig = null;
+}
Index: src/org/javascool/tools/package.html
===================================================================
--- src/org/javascool/tools/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient des petits utilitaires de base pour JavaS'Cool, réutilisables pour d'autres applications.</body>
+
Index: src/org/javascool/tools/Xml2Xml.java
===================================================================
--- src/org/javascool/tools/Xml2Xml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Xml2Xml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,147 @@
+/*******************************************************************************
+* They.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.tools;
+
+import java.util.HashMap;
+
+// Used for the sax interface
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Properties;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.transform.stream.StreamResult;
+
+/** Transforme une structure XML en une autre structure XML avec un XSLT.
+ *
+ * <p>Note: utilise <tt>saxon.jar</tt> qui doit être dans le CLASSPATH.</p>
+ * @see <a href="Xml2Xml.java.html">code source</a>
+ * @serial exclude
+ */
+public class Xml2Xml {
+  // @factory
+  private Xml2Xml() {}
+
+  /** Convertit une chaîne XML en une autre chaîne XML selon des règles XSL.
+   * @param xml Le nom de fichier ou la chaîne XML en entrée.
+   * @param xsl Le nom de fichier ou la chaîne avec les règles de transformation XSL.
+   * <p> - Si la chaîne commence par un <tt>&lt;</tt> elle est reconnue comme un texte XSLT.</p>
+   * <p> - Sinon elle est reconnue comme un non de fichier.</p>
+   * @param params Paramètres de la transformation. La valeur null indique qu'il n'y a pas de paramètres.
+   *
+   * @return La chaîne en sortie.
+   *
+   * @throws IllegalArgumentException Si une erreur de syntaxe est détecté.
+   * @throws RuntimeException  Si une erreur d'entrée-sortie s'est produite.
+   */
+  public static String run(String xml, String xsl, Properties params) {
+    // Compile la tranformation XSLT dans le cache des XSLT
+    try {
+      if(!tranformers.containsKey(xsl)) {
+        StreamSource xslSource = null;
+        if(xsl.trim().startsWith("<"))
+          xslSource = new StreamSource(new StringReader(xsl));
+        else {
+          xslSource = new StreamSource(xsl);
+          xslSource.setSystemId(xsl);
+        }
+        tranformers.put(xsl, tfactory.newTransformer(xslSource));
+      }
+    } catch(TransformerConfigurationException e) { 
+      throw new RuntimeException(e + " when compiling: " + xsl);
+    }
+    // Applique la transformation
+    try {
+      if(xml == null)
+        xml = "<null/>";
+      StringWriter writer = new StringWriter();
+      Transformer transformer = tranformers.get(xsl);
+      // Ajoute les paramètres de la transformation, si définis
+      {
+        transformer.clearParameters();
+        if(params != null)
+          for(String name : params.stringPropertyNames())
+            transformer.setParameter(name, params.getProperty(name));
+      }
+      StreamSource in = xml.trim().startsWith("<") ? new StreamSource(new StringReader(xml)) : new StreamSource(xml);
+      transformer.transform(in, new StreamResult(writer));
+      return writer.toString();
+    } catch(TransformerException e) { throw new IllegalArgumentException(e.getMessageAndLocation());
+    }
+  }
+  /**
+   * @see #run(String, String, Properties)
+   */
+  public static String run(String xml, String xsl) {
+    return run(xml, xsl, null);
+  }
+  /**
+   * @see #run(String, String, Properties)
+   */
+  public static String run(String xml, String xsl, String paramName, String paramValue) {
+    Properties params = new Properties();
+    params.setProperty(paramName, paramValue);
+    return run(xml, xsl, params);
+  }
+  // Cash mechanism
+  private static TransformerFactory tfactory;
+  private static HashMap<String, Transformer> tranformers = new HashMap<String, Transformer>();
+  static {
+    try {
+      System.setProperty("javax.xml.parsers.SAXParserFactory", "com.icl.saxon.aelfred.SAXParserFactoryImpl");
+      System.setProperty("javax.xml.transform.TransformerFactory", "com.icl.saxon.TransformerFactoryImpl");
+      System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.icl.saxon.om.DocumentBuilderFactoryImpl");
+      tfactory = TransformerFactory.newInstance();
+    } catch(Throwable e) {
+      System.err.println("Configuration error: " + e);
+    }
+  }
+
+  /** Convertit une chaîne en HTML en chaîne XHTML.
+   * <p>Elimine les entitées HTML connues (tout n'est pas implémenté) et passe à de l'accentuation liée au codage local,
+   * élimine les constructions (commentaires, instructions) qui ne sont pas structures logiques XML et
+   * ferme les balises pur avoir une syntaxe bien formée.</p>
+   * <p>C'est une commande "fragile" au sens où un text HTML mal formé ne sera pas correctement traduit.</p>
+   * @param htm La chaîne HTML en entrée.
+   * @return La chaîne XML en sortie.
+   */
+  public static String html2xhtml(String htm) {
+    return htm. // Elimine les accentuation HTML
+           replaceAll("&agrave;", "à").
+           replaceAll("&acirc;", "â").
+           replaceAll("&eacute;", "é").
+           replaceAll("&egrave;", "è").
+           replaceAll("&euml;", "ë").
+           replaceAll("&ecirc;", "ê").
+           replaceAll("&iuml;", "ï").
+           replaceAll("&icirc;", "î").
+           replaceAll("&ouml;", "ö").
+           replaceAll("&ocirc;", "ô").
+           replaceAll("&ldquo;", "&#8220;").
+           replaceAll("&rdquo;", "&#8221;").
+           replaceAll("&laquo;", "&#171;").
+           replaceAll("&raquo;", "&#172;;").
+           replaceAll("&ugrave;", "ù").
+           replaceAll("&ccedil;", "ç").
+           // Eliminate les constructions étranges
+           replaceAll("<[!?][^>]*>", "").
+           replaceAll("&nbsp;", "&#160;").
+           // Encapsule les constructions non XML
+           replaceAll("(<(meta|img|hr|br|link)[^>/]*)/?>", "$1/>");
+  }
+  /** Lanceur de la transformation XML -XSLT-> XML.
+   * @param usage <tt>java org.javascool.tools.Xml2Xml input-file XSL-file [output-file] [paramName paramValue]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length == 5)
+      FileManager.save(usage[2], run(FileManager.load(usage[0]), usage[1], usage[3], usage[4]));
+    else if(usage.length > 1)
+      FileManager.save(usage.length > 2 ? usage[2] : "stdout:", run(FileManager.load(usage[0]), usage[1]));
+  }
+}
Index: src/org/javascool/tools/Invoke.java
===================================================================
--- src/org/javascool/tools/Invoke.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Invoke.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,33 @@
+package org.javascool.tools;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/** Invoque une méthode sur un objet Java.
+ */
+public class Invoke {
+  /** Invoke une méthode sans argument sur un objet.
+   * @param object L'objet sur lequel on invoque la méthode.
+   * @param method La méthode sans argument à invoquer, souvent : <tt>init</tt>, <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> ou <tt>run</tt>.
+   * @param run Si true (par défaut) appelle la méthode, si false teste simplement son existence.
+   * @return La valeur true si la méthode est invocable, false sinon.
+   * @throws RuntimeException si la méthode génère une exception lors de son appel.
+   */
+  public static boolean run(Object object, String method, boolean run) {
+    try {
+      Method m = object.getClass().getDeclaredMethod(method);
+      if(run)
+        m.invoke(object);
+    } catch(InvocationTargetException e) { throw new RuntimeException(e.getCause());
+    } catch(Throwable e) {
+      return false;
+    }
+    return true;
+  }
+  /**
+   * @see #run(Object, String, boolean)
+   */
+  public static boolean run(Object object, String method) {
+    return run(object, method, true);
+  }
+}
Index: src/org/javascool/tools/Sampler.java
===================================================================
--- src/org/javascool/tools/Sampler.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Sampler.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,122 @@
+/**************************************************************************
+*   vthierry@sophia.inria.fr, Copyright (C) 2004.  All rights reserved.   *
+**************************************************************************/
+
+package org.javascool.tools;
+
+// Used to catch exceptions
+import java.lang.RuntimeException;
+
+// Used for thread management
+import java.lang.Thread;
+import java.lang.Runnable;
+
+// Used for timer management
+import java.lang.System;
+import java.lang.InterruptedException;
+
+/** Defines the implementation of a periodic task.
+ * 
+ * <div>The periodic task is: <ul>
+ * <li><b>defined</b> by a runnable called at each iteration, and one parameter the <b><i>sampling-period</i></b>.</li>
+ * <li><b>controlled</b> by the start/stop method
+ *
+ * <li><a href="#start(int)">start()</a> (re)starting the iteration.
+ *  <div>User can overwrite the method with a construct of the form <tt>public void start() { &lt;specific-code> super.start(); }</tt></div></li>
+ *
+ * <li><a href="#stop()">stop()</a> which stops the iteration.
+ *  <div>User can overwrite the method with a construct of the form <tt>public void stop() { super.stop(); &lt;specific-code> }</tt></div></li>
+ *
+ * </ul></div>
+ *
+ */
+public class Sampler {
+  private Runnable runnable;
+  private int delay;
+
+  // @bean
+  public Sampler() { }
+ 
+  /** Sets the periodic task runnable.
+   * @param runnable The runnable to call periodically.
+   * @return this
+   */
+  public Sampler setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+
+  /** Sets the periodic task sampling-period.
+   * @param delay The periodic task delay in milli-seconds.
+   * @return this
+   */
+  public Sampler setDelay(int delay) {
+    this.delay = delay;
+    return this;
+  }
+
+  /** (Re)starts the sampling of the runnable.  */
+  public void start() {
+    error = null;
+    (thread = new Thread(new Runnable() {
+	// Loop with a time-period of samplingPeriod
+	public void run() {
+	  try {
+	    for (loop = resume = true; loop;) {
+	      long t = System.currentTimeMillis(); Thread.yield();
+	      if (resume) runnable.run();
+	      spareTime = delay - (int) (System.currentTimeMillis()-t);
+	      if (spareTime > 0) { try { Thread.sleep(spareTime); } catch(InterruptedException e) { } }
+	    }
+	  } catch(Throwable e) {
+	    error = e; 
+	  }
+	  loop = resume = false;
+	}
+      })).start();
+  }
+  // This flag is true during sampling loop
+  private boolean loop = false, resume = false;
+
+  /** Returns the iteraton thread.
+   * @return The thread with the periodic sampling or null if not running.
+   */
+  public Thread getThread() { return thread; }
+  private Thread thread = null;
+  
+  /** Pauses the iteration mechanism. 
+   */
+  public void pause() { resume = false; }
+
+  /** Resumes the iteration after a pause.
+   */
+  public void resume() { resume = true; }
+
+  /** Tests if the iteration is paused
+   * @return True if the iteration has been paused via <tt>pause()</tt> false if the iteration has been resumed via <tt>resumed()</tt> or never paused.
+   */
+  public boolean isPaused() { return !resume; }
+
+  /** Returns the runtime-exception thrown by the iteration runnable.
+   * @return The runtime-exception thrown by the iteration runnable if any, else null.
+   */
+  public Throwable getThrowable() {
+    return error;
+  }
+  private Throwable error = null;
+
+  /** Requires the sampling to stop.
+   * <div>The current iteration, if any, terminates before stopping.</div>
+   */
+  public void stop() { loop = resume = false; thread = null; }
+
+  /** Returns the spare-time between two samplings.
+   *
+   * @return The last spare-time between two samplings, in milliseconds: <ul>
+   *  <li> If negative, it indicates that the task overruns.</li> 
+   *  <li> It is equal to Integer.MIN_VALUE if no iteration has been completed. </li> 
+   *  <li> It depends on both the task execution time and other thread execution times.</li>
+   * </ul> 
+   */
+  public int getSpareTime() { return spareTime; } private int spareTime = -Integer.MIN_VALUE;
+}
Index: src/org/javascool/tools/FileManager.java
===================================================================
--- src/org/javascool/tools/FileManager.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/FileManager.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+ *******************************************************************************/
+package org.javascool.tools;
+
+// Used for URL formation
+import java.net.URL;
+import java.util.Arrays;
+import org.javascool.macros.Macros;
+import java.io.File;
+import java.io.IOException;
+
+// Used for URL read
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
+
+// Used for URL write
+import java.net.URLConnection;
+import java.io.OutputStreamWriter;
+import java.io.FileOutputStream;
+
+// Used for list/exists
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.jar.JarFile;
+import java.util.jar.JarEntry;
+import java.util.Enumeration;
+
+/** Met à disposition des fonctions de gestion de fichiers locaux et distants.
+ * <p>Lit/Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.</p>
+ *
+ * @see <a href="FileManager.java.html">code source</a>
+ * @serial exclude
+ */
+public class FileManager {
+    // @factory
+
+    private FileManager() {
+    }
+
+    /** Lit un contenu textuel local ou distant en tenant compte de l'encodage local.
+     *
+     * @param location Une URL (Universal Resource Location) de la forme: <div id="load-format"><table align="center">
+     * <tr><td><tt>http:/<i>path-name</i></tt></td><td>pour aller chercher le contenu sur un site web</td></tr>
+     * <tr><td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td><td>pour le récupérer sous forme de requête HTTP</td></tr>
+     * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour le charger du système de fichier local ou en tant que ressource Java dans le CLASSPATH</td></tr>
+     * <tr><td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td><td>pour le charger d'une archive
+     *  <div>(exemple:<tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>)</div></td></tr>
+     * </table></div>
+     * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static String load(String location, boolean utf8) {
+        try {
+            BufferedReader reader = new BufferedReader(new InputStreamReader(Macros.getResourceURL(location, true).openStream(), 
+                        utf8 ? Charset.forName("utf-8") : Charset.defaultCharset()), 10240);
+            StringBuilder buffer = new StringBuilder();
+            char chars[] = new char[10240];
+            while (true) {
+                int l = reader.read(chars);
+                if (l == -1) {
+                    break;
+                }
+                buffer.append(chars, 0, l);
+            }
+            return buffer.toString();
+
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when loading: " + location);
+        }
+    }
+    /**
+     * * @see #load(String, boolean)
+     */
+     public static String load(String location) {
+        return load(location, false);
+     }
+    /** Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.
+     *
+     * @param location @optional<"stdout:"> Une URL (Universal Resource Location) de la forme: <div id="save-format"><table>
+     * <tr><td><tt>ftp:/<i>path-name</i></tt></td><td>pour sauver sur un site FTP.</td></tr>
+     * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour sauver dans le système de fichier local (le <tt>file:</tt> est optionnel).</td></tr>
+     * <tr><td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td><td>pour envoyer un courriel avec le texte en contenu.</td></tr>
+     * <tr><td><tt>stdout:/</tt></td><td>pour l'imprimer dans la console.</td></tr>
+     * </table></div>
+     * @param string Le texte à sauvegarder.
+     * @param backup Si true, dans le cas d'un fichier, crée une sauvegarde d'un fichier existant. Par défaut false.
+     * * <p>Le fichier sauvegardé est doté d'un suffixe numérique unique.</p>
+     * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static void save(String location, String string, boolean backup, boolean utf8) {
+        if (location.startsWith("stdout:")) {
+            System.out.println("\n" + location + " " + string);
+            return;
+        }
+        location = Macros.getResourceURL(location, false).toString();
+        try {
+            if(location.startsWith("file:") && new File(location.substring(5)).getParentFile() != null)
+	      new File(location.substring(5)).getParentFile().mkdirs();
+            if (backup && !location.startsWith("file:")) {
+                throw new IllegalArgumentException("Impossible de procéder à un backup pour l'URL «" + location + "»");
+            }
+            OutputStreamWriter writer = location.startsWith("file:") ? getFileWriter(location.substring(5), backup, utf8) : getUrlWriter(location, utf8);
+            for (int i = 0; i < string.length(); i++) {
+                writer.write(string.charAt(i));
+            }
+            writer.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when saving: " + location);
+        }
+    }
+
+    /**
+     * @see #save(String, String, boolean, boolean)
+     */
+    public static void save(String location, String string, boolean backup) {
+        save(location, string, backup, false);
+    }
+   /**
+     * @see #save(String, String, boolean, boolean)
+     */
+    public static void save(String location, String string) {
+        save(location, string, false, false);
+    }
+
+    /** Met en place le writer dans le cas d'une URL. */
+    private static OutputStreamWriter getUrlWriter(String location, boolean utf8) throws IOException {
+        URL url = new URL(location);
+        URLConnection connection = url.openConnection();
+        connection.setDoOutput(true);
+        OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), 
+                    utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
+        if (url.getProtocol().equals("mailto")) {
+            int i = url.toString().indexOf("?subject=");
+            if (i != -1) {
+                writer.write("Subject: " + url.toString().substring(i + 9) + "\n");
+            }
+        }
+        return writer;
+    }
+
+    /** Mets en place le writer dans le cas d'un fichier. */
+    private static OutputStreamWriter getFileWriter(String location, boolean backup, boolean utf8) throws IOException {
+        File file = new File(location), parent = file.getParentFile();
+        if ((parent != null) && (!parent.isDirectory())) {
+            parent.mkdirs();
+        }
+        if (backup && file.exists())
+            backup(file);
+        return new OutputStreamWriter(new FileOutputStream(location), utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
+    }
+    /** Mécanisme de backup. */
+    private static void backup(File file) {
+      File backup = new File(file.getAbsolutePath()+"~");
+      if (backup.exists())
+        backup(backup);
+      file.renameTo(backup);
+    }
+
+    /** Détecte si une URL existe.
+     * @param location Une URL (Universal Resource Location).
+     * @return Renvoie true si l'URL existe et est lisible, false sinon.
+     */
+    public static boolean exists(String location) {
+        if (location.matches("(ftp|http|https|jar):.*")) {
+            try {
+                return exists(new URL(location));
+            } catch (IOException e) {
+                return false;
+            }
+        } else {
+            if (location.matches("file:.*")) {
+                location = location.substring(5);
+            }
+            return new File(location).canRead();
+        }
+    }
+
+    /**
+     * @see #exists(String)
+     */
+    public static boolean exists(URL location) {
+        try {
+            location.openStream().close();
+            return true;
+        } catch (IOException e) {
+            return false;
+        }
+    }
+
+    /** Renvoie les fichiers d'un répertoire ou d'un jar.
+     * @param folder Le nom du répertoire ou du fichier jar (fichier d'extension ".jar").
+     * @param pattern Une regex qui définit le type de fichier (ex : <tt>".*\.java"</tt>). Par défaut tous les fichiers.
+     * @param depth Dans le cas d'un répertoire, profondeur: 0 (défaut) pour lire dans le répertoire, 1: répertoire et sous-répertoire, etc..
+     * @return Une énumération des fichiers listés: le path canonique est renvoyé. Si le répertoire ou le jar ne peut être lu, renvoie une liste vide dans erreur.
+     *
+     * @throws IllegalArgumentException Si l'URL ne peut pas être listée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+  public static String[] list(String folder, String pattern, int depth) {
+        if (folder.matches("(ftp|http|https|jar):.*")) {
+            throw new IllegalArgumentException("Impossible de lister le contenu d'un URL de ce type: " + folder);
+        }
+        if (folder.matches("file:.*")) {
+            folder = folder.substring(5);
+        }
+        ArrayList<String> files = new ArrayList<String>();
+        if (folder.matches(".*\\.jar")) {
+            try {
+                for (Enumeration<JarEntry> e = new JarFile(folder).entries(); e.hasMoreElements();) {
+                    String file = e.nextElement().getName();
+                    if ((pattern == null) || file.matches(pattern)) {
+                        files.add("jar:" + folder + "!" + file);
+                    }
+                }
+            } catch(IOException e) {
+                throw new IllegalArgumentException(e);
+            }
+        } else if (new File(folder).isDirectory() && depth >= 0) {
+            try {
+                for (File file : new File(folder).listFiles()) {
+                    if ((pattern == null) || file.getName().matches(pattern)) {
+                        files.add(file.getCanonicalPath());
+                    }
+                }
+		if (depth > 0) {
+		  for (File file : new File(folder).listFiles()) 
+		    if (file.isDirectory()) 
+		      files.addAll(Arrays.asList(list(file.getCanonicalPath(), pattern, depth - 1)));
+		}
+            } catch(IOException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+        return files.toArray(new String[files.size()]);
+    }
+
+    /**
+     * @see #list(String, String, int)
+     */
+    public static String[] list(String folder, String pattern) {
+      return list(folder, pattern, 0);
+    }
+
+
+    /**
+     * @see #list(String, String, int)
+     */
+    public static String[] list(String folder)  {
+      return list(folder, null, 0);
+    }
+
+    /** Crée un répertoire temporaire dans le répertoire temporaire de la machine.
+     * @param prefix Prefix du répertoire.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static File createTempDir(String prefix) {
+        try {
+	  File d = File.createTempFile(prefix, "");
+	  d.delete();
+	  d.mkdirs();
+	  return d;
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when creating temporary directory");
+        }
+    }
+}
Index: src/org/javascool/core/Jvs2Java.java
===================================================================
--- src/org/javascool/core/Jvs2Java.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Jvs2Java.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,131 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+package org.javascool.core;
+
+// Used to report a throwable
+import java.lang.reflect.InvocationTargetException;
+
+/** Implémente le mécanisme de base de traduction d'un code Jvs en code Java standard.
+ * <p>Les erreurs de traduction sont affichées dans la console.</p>
+ *
+ * @see <a href="Jvs2Java.java.html">source code</a>
+ * @serial exclude
+ */
+public class Jvs2Java extends Translator {
+  // @bean
+  public Jvs2Java() {}
+
+  /** Définit un mécanisme spécifique de traduction en plus du mécanisme standard.
+   * @param progletTranslator Le mécanisme de traduction spécifique d'une proglet donnée.
+   * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletTranslator(..)</tt>.
+   */
+  public Jvs2Java setProgletTranslator(Translator progletTranslator) {
+    // @bean-parameter(Translator, progletTranslator, w);
+    this.progletTranslator = progletTranslator;
+    return this;
+  }
+  private Translator progletTranslator = null;
+
+  /** Définit le nom complet du package de la proglet pour ce mécanismes de traduction.
+   * @param progletPackageName Le nom complet du package de la proglet.
+   * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletPackageName(..)</tt>.
+   */
+  public Jvs2Java setProgletPackageName(String progletPackageName) {
+    // @bean-parameter(String, progletPackageName, w);
+    this.progletPackageName = progletPackageName;
+    return this;
+  }
+  private String progletPackageName = null;
+
+  @Override
+  public String translate(String jvsCode) {
+    String text = jvsCode.replace((char) 160, ' ');
+    // Ici on ajoute
+    if(!text.replaceAll("[ \n\r\t]+", " ").matches(".*void[ ]+main[ ]*\\([ ]*\\).*")) {
+      if(text.replaceAll("[ \n\r\t]+", " ").matches(".*main[ ]*\\([ ]*\\).*")) {
+        System.out.println("Attention: il faut mettre \"void\" devant \"main()\" pour que le programme puisque se compiler");
+        text = text.replaceFirst("main[ ]*\\([ ]*\\)", "void main()");
+      } else {
+        System.out.println("Attention: il faut un block \"void main()\" pour que le programme puisque se compiler");
+        text = "\nvoid main() {\n" + text + "\n}\n";
+      }
+    }
+    String[] lines = text.split("\n");
+    StringBuilder head = new StringBuilder();
+    StringBuilder body = new StringBuilder();
+    // Here is the translation loop
+    {
+      int i = 1;
+      // Copies the user's code
+      for(String line : lines) {
+        if(line.matches("^\\s*(import|package)[^;]*;\\s*$")) {
+          head.append(line);
+          body.append("//").append(line).append("\n");
+          if(line.matches("^\\s*package[^;]*;\\s*$"))
+            System.out.println("Attention: on ne peut normalement pas définir de package Java en JavaScool\n le programme risque de ne pas s'exécuter correctement");
+        } else
+          body.append(line).append("\n");
+        i++;
+      }
+      // Imports proglet's static methods
+      head.append("import static java.lang.Math.*;");
+      head.append("import static org.javascool.macros.Macros.*;");
+      head.append("import static org.javascool.macros.Stdin.*;");
+      head.append("import static org.javascool.macros.Stdout.*;");
+      if(progletPackageName != null)
+        head.append("import static ").append(progletPackageName).append(".Functions.*;");
+      if(progletTranslator != null)
+        head.append(progletTranslator.getImports());
+      // Declares the proglet's core as a Runnable in the Applet
+      uid++;
+      head.append("public class JvsToJavaTranslated").append(uid).append(" implements Runnable{");
+      head.append("  private static final long serialVersionUID = ").append(uid).append("L;");
+      head.append("  public void run() {");
+      head.append("   try{ main(); } catch(Throwable e) { ");
+      head.append("    if (e.toString().matches(\".*Interrupted.*\"))System.out.println(\"\\n-------------------\\nProggramme arrêté !\\n-------------------\\n\");");
+      head.append("    else System.out.println(\"\\n-------------------\\nErreur lors de l'exécution de la proglet\\n\"+org.javascool.core.Jvs2Java.report(e)+\"\\n-------------------\\n\");}");
+      head.append("}");
+    }
+    String finalBody = body.toString().
+                       replaceAll("(while.*\\{)", "$1 sleep(1);");
+    if(progletTranslator != null)
+        finalBody = progletTranslator.translate(finalBody);
+    System.err.println(
+                "\n-------------------\nCode java généré\n-------------------\n" +
+                head.toString().replaceAll("([{;])", "$1\n") + "\n" + finalBody + "}" +
+                "\n----------------------------------------------------------\n");
+    return head.toString() + finalBody + "}";
+  }
+  /** Renvoie le nom de la dernière classe Java générée lors de la traduction. */
+  public String getClassName() {
+    return "JvsToJavaTranslated" + uid;
+  }
+  // Counter used to increment the serialVersionUID in order to reload the different versions of the class
+  private static int uid = 0;
+
+  /** Rapporte une erreur survenue lors de l'exécution d'un prograamme Jvs.
+   * @param error L'erreur ou exception à rapporter.
+   * @return Le rapport d'erreur.
+   */
+  public static String report(Throwable error) {
+    if(error instanceof InvocationTargetException)
+      return report(error.getCause());
+    String s = error.toString()+"\n";
+    for(int i = 0; i < 4 && i < error.getStackTrace().length; i++) {
+      String s_i = "" + error.getStackTrace()[i];
+      if (s_i.startsWith("JvsToJavaTranslated"))
+	s += s_i.replaceFirst("JvsToJavaTranslated[0-9]*", "") + "\n";
+    }
+    return s;
+  }
+
+  /** Lanceur de la conversion Jvs en Java.
+   * @param usage <tt>java org.javascool.core.Jvs2Java input-file [output-file]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 0)
+      org.javascool.tools.FileManager.save(usage.length > 1 ? usage[1] : "stdout:", new Jvs2Java().translate(org.javascool.tools.FileManager.load(usage[0])));
+  }
+}
Index: src/org/javascool/core/package.html
===================================================================
--- src/org/javascool/core/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,5 @@
+<body>Ce package contient les mécanismes du moteur de JavaScool.
+<p>Le moteur de JavaScool fonctionne ainsi:
+<p><img src="http://javascool.gforge.inria.fr/v4/documents/javadoc/javascool-workflow.png" alt="Cycle de vie d'un code Jvs and Javascool" width="100%"/></p>
+</p>
+</body>
Index: src/org/javascool/core/Java2Jar.java
===================================================================
--- src/org/javascool/core/Java2Jar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Java2Jar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,87 @@
+/**************************************************************
+ * Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+ **************************************************************/
+package org.javascool.core;
+
+import java.io.File;
+import java.io.IOException;
+import org.javascool.Core;
+import org.javascool.builder.JarManager;
+import org.javascool.tools.Pml;
+
+/** Définit le mécanisme de compilation en ligne d'un code Java et de création du Jar obtenu.
+ *
+ * @see <a href="Java2Jar.java.html">code source</a>
+ * @serial exclude
+ */
+public class Java2Jar {
+  // @factory
+  private Java2Jar() {}
+
+  /** Compile dans le système de fichier local, un code source Java.
+   * <p>Les fichiers <tt>.class</tt> sont générés dans sur place.</p>
+   * <p>Les erreurs de compilation sont affichées dans la console.</p>
+   * @param jarFile La jarre de stockage du résultat.
+   * @param mainClass Le nom de la classe qui contient le main.
+   * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
+   * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
+   * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
+   *
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFile, boolean allErrors) {
+    String javaFiles[] = { javaFile };
+    return compile(jarFile, mainClass, javaFiles, allErrors);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFile) {
+    return compile(jarFile, mainClass, javaFile, false);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFiles[]) {
+    return compile(jarFile, mainClass, javaFiles, false);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFiles[], boolean allErrors)  {
+    try {
+      String buildDir = ".build";
+      JarManager.rmDir(new File(buildDir));
+      new File(buildDir).mkdirs();
+      JarManager.jarExtract(Core.javascoolJar(), buildDir, "org/javascool");
+      for (int i = 0; i < javaFiles.length; i++) {
+        String file = javaFiles[i]; javaFiles[i] =  buildDir+File.separator+file;
+        JarManager.copyFiles(file, javaFiles[i]);
+      }
+      if (!Java2Class.compile(javaFiles, allErrors))
+	return false;
+      String mfFile = buildDir + File.separator + "manifest.jmf";
+      Pml manifest = new Pml().set("Main-Class", mainClass).
+	set("Implementation-URL", "http://javascool.gforge.inria.fr").
+	save(mfFile);
+      JarManager.jarCreate(jarFile, mfFile, buildDir);
+      JarManager.rmDir(new File(buildDir));
+      return true;
+    } catch(IOException e) {
+      throw new RuntimeException("Erreur d'entrées-sorties à la compilation : "+ e);
+    }
+  }
+  
+  /** Lanceur de la conversion Jvs en Java.
+   * @param usage <tt>java org.javascool.core.Java2Jar main-file [input-file(s) ..] [output-file]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 1) {
+      String javaFiles[] = new String[usage.length-1];
+      System.arraycopy(usage, 0, javaFiles, 0, javaFiles.length);
+      compile(usage[usage.length-1], new File(usage[0]).getName().replaceAll("\\.java$", ""), javaFiles, true);
+    }
+  }
+}
+  
Index: src/org/javascool/core/Translator.java
===================================================================
--- src/org/javascool/core/Translator.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Translator.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,28 @@
+package org.javascool.core;
+
+/** Définit une traduction d'un code Jvs en code Java standard.
+ * <p>Cette classe permet de définir des variantes de langage pour une proglet donnée.</p>
+ *
+ * @see <a href="Translator.java.html">code source</a>
+ * @serial exclude
+ */
+public class Translator {
+  /** Renvoie les déclarations d'import spécifiques à cette proglet.
+   * <p>Ce sont les déclarations d'import spécifiques dont l'utilisateur a besoin pour que son code Jvs puisse se compiler.</p>
+   * <p>- Par exemple: <tt>"import javax.swing.JPanel;import static org.javascool.proglets.maProglet.*;"</tt></p>
+   * <p>Note: tous les imports liés aux fonctions de la proglet à l'usage des macros de JavaScool etc.. sont automatiquement prises en charge.</p>
+   * @return Renvoie les imports en syntaxe Java (par défaut la chaîne vide).
+   */
+  public String getImports() {
+    return "";
+  }
+  /** Transforme globalement le code pour passer des constructions spécifiques à Jvs à du java standard.
+   * <p>Ce sont souvent des expression régulières appliquées à la chaîne, tout est ici de la responsabilité du concepteur de la proglet.</p>
+   * <p>Note: toutes les traductions standard du paassage de Jvs à Java sont automatiquement prises en charges.</p>
+   * @param code Le code Jvs en entrée.
+   * @return Le code transformé en Java pour ce qui est spécifique de cette proglet (par défaut la chaîne en entrée).</p>
+   */
+  public String translate(String code) {
+    return code;
+  }
+}
Index: src/org/javascool/core/Java2Class.java
===================================================================
--- src/org/javascool/core/Java2Class.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Java2Class.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,202 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+package org.javascool.core;
+
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Pattern;
+import javax.tools.Diagnostic;
+import javax.tools.DiagnosticCollector;
+import javax.tools.JavaCompiler;
+import javax.tools.JavaFileObject;
+import javax.tools.StandardJavaFileManager;
+import javax.tools.ToolProvider;
+
+/** Définit le mécanisme de compilation en ligne d'un code Java et du chargement de la classe obtenue.
+ * <p>Note: utilise un sous ensemble du <tt>tools.jar</tt> de la JDK appelé ici <tt>javac.jar</tt> qui doit être dans le CLASSPATH.</p>
+ *
+ * @see <a href="Java2Class.java.html">code source</a>
+ * @serial exclude
+ */
+public class Java2Class {
+  // @factory
+  private Java2Class() {}
+
+  /** Compile dans le système de fichier local, un code source Java.
+   * <p>Les fichiers <tt>.class</tt> sont générés sur place.</p>
+   * <p>Les erreurs de compilation sont affichées dans la console.</p>
+   * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
+   * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
+   * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
+   *
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
+   */
+  public static boolean compile(String javaFile, boolean allErrors) {
+    String javaFiles[] = { javaFile };
+    return compile(javaFiles, allErrors);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFile) {
+    return compile(javaFile, false);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFiles[]) {
+    return compile(javaFiles, false);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFiles[], boolean allErrors) {
+    if(javaFiles.length == 0)
+      return false;
+    return compile2(javaFiles, allErrors);
+  }
+
+  // Implementation using the javac compiler api : il n'est plus utilisé (donc plus maintenu !) avec l'arrivée dela jre 76
+  private static boolean compile1(String javaFiles[], boolean allErrors) {
+    // Initialisation des objets dy compilateur// The compiler tool
+    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); // The compiler tool
+    if (compiler == null) {
+      System.err.println("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)");
+      throw new IllegalStateException("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)");
+    }
+    DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>(); // The diagnostic colector
+    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.FRENCH, null); // The file manager
+    // Mise en place des fichiers
+    List<File> sourceFileList = new ArrayList<File>();
+    for(String javaFile : javaFiles)
+      sourceFileList.add(new File(javaFile));
+    Iterable< ? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(sourceFileList);
+    // Lancement de la compilation
+    JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits);
+    task.call();
+    try {
+      fileManager.close();
+    } catch(IOException e) {
+      System.err.println("Erreur à la fermeture du file-manager du compilateur : " + e);
+    }
+    // Gestion des erreurs
+    for(Diagnostic diagnostic : diagnostics.getDiagnostics()) {
+      String javaDiagnostic = diagnostic.getMessage(Locale.FRENCH);
+      String jvsDiagnostic = javaFiles.length > 1 ? javaDiagnostic : javaDiagnostic.split(" ", 2)[1];
+      if(jvsDiagnostic.equals("not a statement"))
+	jvsDiagnostic = "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)";
+      else if(jvsDiagnostic.equals("';' expected"))
+	jvsDiagnostic = "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)";
+      else if(jvsDiagnostic.startsWith("cannot find symbol"))
+	jvsDiagnostic = "Il y a un symbole non-défini à cette ligne: " +
+	  jvsDiagnostic.replaceFirst("cannot[^:]*:\\s*([^\\n]*)[^:]*:\\s*(.*)", "«$1»");
+      else if(jvsDiagnostic.matches(".*\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)"))
+	jvsDiagnostic = jvsDiagnostic.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
+						 "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
+      else if(jvsDiagnostic.matches("package org\\.javascool\\.proglets\\.[A-Za-z0-9_]+ does not exist"))
+	jvsDiagnostic = jvsDiagnostic.replaceAll("package org\\.javascool\\.proglets\\.([A-Za-z0-9_]+) does not exist",
+						 "La proglet $1 n'existe pas");
+      else
+	jvsDiagnostic = "Erreur Java : «" + jvsDiagnostic + "»";
+      int line = (int) diagnostic.getLineNumber();
+      String source = new File(diagnostic.getSource().toString()).getParentFile().getName() + "/" + new File(diagnostic.getSource().toString()).getName();
+      String where = javaFiles.length == 1 ? "" : " de " + source + "";
+      System.out.println("-------------------\nErreur lors de la compilation à la ligne " + line + where + ".\n" + jvsDiagnostic + "\n-------------------");
+      System.err.println("Erreur à la compilation: fichier="+source+" ligne ="+line +" erreur="+javaDiagnostic);
+      // En fait ici on choisit d'arrêter à la 1ère erreur pour pas embrouiller l'apprennant
+      if(diagnostic.getKind().equals(Diagnostic.Kind.ERROR) && !allErrors)
+	return false;
+    }
+    return true;
+  }
+  
+  private static boolean compile2(String javaFiles[], boolean allErrors) {
+    // Appel du compilateur par sa méthode main
+    int options = 2;
+    String args[] = new String[options + javaFiles.length];
+    args[0] = "-g";
+    args[1] = "-nowarn";
+    System.arraycopy(javaFiles, 0, args, options, javaFiles.length);
+    StringWriter out = new StringWriter();
+    Method javac;
+    try {
+      javac = Class.forName("com.sun.tools.javac.Main").
+	getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter"));
+    } catch(Exception e) {
+      throw new IllegalStateException("Impossible d'accéder au compilateur javac : "+ e);
+    }   
+    try {
+      javac.invoke(null, (Object) args, new PrintWriter(out));
+    } catch(Exception e) {
+      throw new IllegalStateException("Erreur système lors du lancement du compilateur javac : "+ e);
+    }   
+    // Traitement du message de sortie
+    {
+      String sout = out.toString().trim();
+      // Coupure à la première erreur
+      if (sout.indexOf("^") != -1 && !allErrors) sout = sout.substring(0, sout.indexOf("^") + 1);
+      if (javaFiles.length > 1) {
+	// Remplacement des chemins des sources par leur simple nom
+	for(String javaFile : javaFiles)
+	  sout = sout.replaceAll(Pattern.quote(new File(javaFile).getParent()+File.separator), "\n");
+	// Explicitation du numéro de ligne
+	for(String javaFile : javaFiles)
+	  sout = sout.replaceAll("("+Pattern.quote(new File(javaFile).getName())+"):([0-9]+):", "$1 : erreur de syntaxe ligne $2 :\n ");
+      } else {
+	sout = sout.replaceAll("("+Pattern.quote(new File(javaFiles[0]).getPath())+"):([0-9]+):", "\n Erreur de syntaxe ligne $2 :\n ");
+        sout = sout.replaceAll(Pattern.quote(new File(javaFiles[0]).getName().replaceFirst("java$", "")), "");
+      }
+      // Passage en français des principaux diagnostics
+      sout = sout.replaceAll("not a statement", 
+			     "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)");
+      sout = sout.replaceAll("';' expected", 
+			     "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)");
+      sout = sout.replaceAll("cannot find symbol\\s*symbol\\s*:\\s*([^\\n]*)[^:]*:\\s*(.*)", 
+			     "Il y a un symbole non-défini à cette ligne : «$1» (utilisez-vous la bonne proglet ?)");
+      sout = sout.replaceAll("illegal start of expression", 
+			     "($0) L'instruction (ou la précédente) est tronquée ou mal écrite");
+      sout = sout.replaceAll("class, interface, or enum expected", 
+			     "($0) Il y a probablement une erreur dans les accolades (peut-être trop de '}')");
+      sout = sout.replaceAll("'.class' expected", 
+			     "($0) Il manque des accolades ou des parenthèses pour définir l'instruction");
+      sout = sout.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
+			     "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
+      // Elimination des notes de warning de fin de compilation
+      if (sout.indexOf("Note:") != -1) 
+	sout = sout.substring(0, sout.indexOf("Note:")).trim();
+      // Impression du message d'erreur si il existe et retour du statut
+      if (sout.length() > 0) System.out.println(sout);
+	   return sout.length() == 0;
+    }
+  }
+
+  /** Charge dynamiquement une classe Java qui implémente un Runnable, pour son e×écution au cours d'une session.
+   * @param path Le chemin vers la classe Java à charger. La classe ne doit pas appartenir à un package, c'est-à-dire au package "default".
+   * @return Une instanciation de cette classe Java.
+   *
+   * @throws IllegalArgumentException Si la classe n'est pas un Runnable.
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors du chargement.
+   */
+  public static Runnable load(String path) {
+    try {
+      File javaClass = new File(path).getAbsoluteFile();
+      URL[] urls = new URL[] { new URL("file:" + javaClass.getParent() + File.separator) };
+      Class< ? > j_class = new URLClassLoader(urls).loadClass(javaClass.getName().replaceAll("\\.java", ""));
+      Object o = j_class.newInstance();
+      if(!(o instanceof Runnable))
+         throw new IllegalArgumentException("Erreur: la classe de "+javaClass+" qui n'est pas un Runnable");
+      return (Runnable) o;
+    } catch(Throwable e) { throw new RuntimeException("Erreur: impossible de charger la classe de : "+path);
+    }
+  }
+}
+
Index: src/org/javascool/core/JvsBeautifier.java
===================================================================
--- src/org/javascool/core/JvsBeautifier.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/JvsBeautifier.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,134 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.core;
+
+/** Normalise la mise en page d'un source Jvs. */
+public class JvsBeautifier {
+  /** Reformate un morceau de code Jvs.
+   * <p>- C'est un mécanisme restritif un peu fragile destiné au sous-langage Jvs de Java.</p>
+   * @param text Le source à reformate.
+   * @return Le source reformaté.
+   */
+  public static String run(String text) {
+    char f[] = text.trim().replace((char) 160, ' ').toCharArray();
+    String g = "", ln = "\n";
+    int par = 0;
+    for(int i = 0, j; i < f.length;) {
+      // Escapes /* comments
+      if((f[i] == '/') && (i < f.length - 1) && (f[i + 1] == '*')) {
+        g += f[i++];
+        while(i < f.length && !(f[i - 1] == '*' && f[i] == '/'))
+          g += f[i++];
+        if(i < f.length)
+          g += f[i++] + ln;
+        // Escapes // comments
+      } else if((f[i] == '/') && (i < f.length - 1) && (f[i + 1] == '/')) {
+        while(i < f.length && f[i] != '\n')
+          g += f[i++];
+        g += ln;
+        i++;
+        // Escapes " chars
+      } else if(f[i] == '"') {
+        g += f[i++];
+        while(i < f.length && (f[i - 1] == '\\' || f[i] != '"') && f[i] != '\n')
+          g += f[i++];
+        if(i < f.length)
+          g += f[i++];
+        // Escapes @ pragma
+      } else if(f[i] == '@') {
+        while(i < f.length && f[i] != '\n')
+          g += f[i++];
+        g += ln;
+        i++;
+        // Normalizes spaces
+      } else if(Character.isWhitespace(f[i])) {
+        g += ' ';
+        i++;
+        while(i < f.length && Character.isWhitespace(f[i]))
+          i++;
+      } else {
+        char c0 = g.length() == 0 ? ' ' : g.charAt(g.length() - 1);
+        // Counts (parenthesies)
+        if(f[i] == '(')
+          par++;
+        if(f[i] == ')')
+          par--;
+        // Normalize spaces around operators
+        if(isOperator(f[i])) {
+          if(!(Character.isWhitespace(c0) || isOperator(c0)))
+            g += ' ';
+          g += f[i];
+          if((i < f.length - 1) && !(Character.isWhitespace(f[i + 1]) || isOperator(f[i + 1])))
+            g += ' ';
+        } else if(f[i] == '.') {
+          if(g.length() > 0 && Character.isWhitespace(c0))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          while(i < f.length - 1 && Character.isWhitespace(f[i + 1]))
+            i++;
+          // Normalize spaces around punctuation
+        } else if((f[i] == ',') || (f[i] == ';') || (f[i] == ')')) {
+          if(g.length() > 0 && Character.isWhitespace(c0))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          if((par > 0) && (f[i] != ')'))
+            if((i < f.length - 1) && !Character.isWhitespace(f[i + 1]))
+              g += ' ';
+          if((f[i] == ')') && (i < f.length - 1) && (f[i + 1] == '{'))
+            g += ' ';
+        } else if(f[i] == '(') {
+          if(g.length() > 0 && Character.isWhitespace(c0) && (g.length() > 1) && Character.isLetterOrDigit(g.charAt(g.length() - 2)))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          while(i < f.length - 1 && Character.isWhitespace(f[i + 1]))
+            i++;
+        } else if(f[i] == '}') {
+          for(int n = 0; n < 3; n++)
+            if(g.length() > 0 && Character.isWhitespace(g.charAt(g.length() - 1)))
+              g = g.substring(0, g.length() - 1);
+          g += f[i];
+        } else
+          g += f[i];
+        // Reformats {blocks}
+        if((f[i] == '{') || (f[i] == '}') || ((f[i] == ';') && (par == 0))) {
+          if(f[i] == '{')
+            ln += "   ";
+          if(ln.length() >= 3 && f[i] == '}')
+            ln = ln.substring(0, ln.length() - 3);
+          g += ln;
+          if(ln.length() == 1)
+            g += "\n";
+          i++;
+          while(i < f.length && Character.isWhitespace(f[i]))
+            i++;
+        } else
+          i++;
+      }
+    }
+    return "\n" + g.
+           replaceAll("\\}\\s*else\\s*(\\{|if)", "} else $1").
+           replaceAll("(while|if|for|return)\\s*([^a-z_0-9_])", "$1 $2");
+  }
+  private static boolean isOperator(char c) {
+    switch(c) {
+    case '+':
+    case '-':
+    case '*':
+    case '/':
+    case '%':
+    case '&':
+    case '|':
+    case '^':
+    case '=':
+    case '!':
+    case '<':
+    case '>':
+    case ':':
+      return true;
+    default:
+      return false;
+    }
+  }
+}
Index: src/org/javascool/core/ProgletEngine.java
===================================================================
--- src/org/javascool/core/ProgletEngine.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/ProgletEngine.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,427 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.core;
+
+import java.applet.Applet;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.util.ArrayList;
+import org.javascool.macros.Macros;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.Comparator;
+import javax.swing.JFrame;
+import org.javascool.Core;
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Pml;
+import org.javascool.tools.Invoke;
+import org.javascool.widgets.MainFrame;
+
+/** Définit les mécanismes de compilation, exécution, gestion de proglet.
+ *
+ * @see <a href="ProgletEngine.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletEngine {
+
+    /** Tables des proglets. */
+    private ArrayList<Proglet> proglets=new ArrayList<ProgletEngine.Proglet>();
+
+    // @static-instance
+    /** Crée et/ou renvoie l'unique instance de l'engine.
+     * <p>Une application ne peut définir qu'un seul engine.</p>
+     */
+    public static ProgletEngine getInstance() {
+        if (engine == null) {
+            engine = new ProgletEngine();
+        }
+        return engine;
+    }
+    private static ProgletEngine engine = null;
+
+    private ProgletEngine() {
+        
+        // Détection des proglets présentes dans le jar
+        try {String javascoolJar = Core.javascoolJar();
+            proglets = new ArrayList<Proglet>();
+            for (String dir : FileManager.list(javascoolJar, "org.javascool.proglets.[^\\.]+.proglet.pml")) {
+                String name = dir.replaceFirst("jar:[^!]*!(.*)proglet.pml", "$1");
+	      try {
+                Proglet proglet = new Proglet().load(name);
+                proglets.add(proglet);
+	      }  catch(Exception e) {
+		System.err.println("Erreur lors de la détection dans le jar de la proglet "+name+" en "+dir+" ("+e+")");
+	      }
+            }
+        } catch(Exception er) {
+	  //System.err.println("Erreur lors de la détection des proglets ("+er+" avec "+javascoolJar+"\n . . vous pouvez quand même utiliser JavaScool");
+        }
+        // Définit une proglet "vide" pour lancer l'interface
+        if (proglets.isEmpty()) {
+            for (int i = 0; i < 1; i++) {
+                Proglet p = new Proglet();
+                p.pml.set("name", "Interface");
+                p.pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
+                p.pml.set("help-location", "org/javascool/macros/memo-macros.htm");
+                proglets.add(p);
+            }
+        }   
+        // Tri des proglets par ordre alphabétique
+            Collections.sort(proglets, new Comparator<Proglet>() {
+                    @Override
+                     public int compare(Proglet p1, Proglet p2) {
+                         return p1.getName().compareTo(p2.getName());
+            }});    
+    }
+    //
+    // [1] Mécanisme de compilation/exécution
+    //
+
+    /** Mécanisme de compilation du fichier Jvs.
+     * @param program Nom du programme à compiler.
+     * @return La valeur true si la compilation est ok, false sinon.
+     */
+    public boolean doCompile(String program) {
+        doStop();
+        // Traduction Jvs -> Java puis Java -> Class et chargement de la classe si succès
+        Jvs2Java jvs2java = new Jvs2Java();
+        if (getProglet() != null) {
+            jvs2java.setProgletTranslator(getProglet().getTranslator());
+            jvs2java.setProgletPackageName(getProglet().hasFunctions() ? "org.javascool.proglets." + getProglet().getName() : null);
+        }
+        String javaCode = jvs2java.translate(program);
+        // Creation d'un répertoire temporaire
+        String javaFile;
+        try {
+            File buildDir = FileManager.createTempDir("javac");
+            javaFile = buildDir + File.separator + jvs2java.getClassName() + ".java";
+            FileManager.save(javaFile, javaCode);
+            // Si il y a un problème avec le répertoire temporaire on se rabat sur le répertoire local
+        } catch(Exception e) {
+            javaFile = new File(jvs2java.getClassName() + ".java").getAbsolutePath();
+            System.err.println("Sauvegarde locale du fichier : "+ javaFile);
+            FileManager.save(javaFile, javaCode);
+        }
+        if (Java2Class.compile(javaFile)) {
+            runnable = Java2Class.load(javaFile);
+            return true;
+        } else {
+            runnable = null;
+            return false;
+        }
+    }
+
+    /** Mécanisme de lancement du programme compilé. */
+    public void doRun() {
+        doStop();
+        // Lancement du runnable dans un thread
+        if (runnable != null) {
+            (thread = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    try {
+                        runnable.run();
+                        thread = null;
+                    } catch (Throwable e) {
+                        System.out.println("Erreur à l'exécution: " + e);
+                    }
+                }
+            })).start();
+        }
+    }
+
+    /** Mécanisme d'arrêt du programme compilé. 
+     * @param message Message d'erreur affiché à la console. Si null (par défaut) pas de message.
+     */
+    public void doStop(String message) {
+        if (thread != null) {
+            thread.interrupt();
+            thread = null;
+        }
+        if (message != null) {
+            System.out.println("Cause de l'interruption : " + message);
+        }
+    }
+
+    /**
+     * @see #doStop(String)
+     */
+    public void doStop() {
+        doStop(null);
+    }
+
+    /** Renvoie true si le programme est en cours. */
+    public boolean isRunning() {
+        return thread != null;
+    }
+    private Thread thread = null;
+    private Runnable runnable = null;
+
+    /** Renvoie le runnable correspondant au programme utilisateur en cours.
+     * @return Le runnable correspondant au programme démarré par doRun() ou null si il n'y en a pas.
+     */
+    public Runnable getProgletRunnable() {
+        return runnable;
+    }
+    //
+    // Mécanisme de chargement d'une proglet
+    //
+
+    /** Mécanisme de chargement d'une proglet.
+     * @param proglet Le nom de la proglet.
+     * @return La proglet en fonctionnement ou null si la proglet n'existe pas.
+     * @throws IllegalArgumentException Si il y a tentative d'utilisation d'une proglet indéfinie
+     */
+    public Proglet setProglet(String proglet) {
+        if (currentProglet != null)
+        currentProglet.stop();
+        currentProglet = null;
+        for (Proglet p : getProglets()) {
+            if (p.getName().equals(proglet)) {
+                currentProglet = p;
+            }
+        }
+        if (currentProglet == null)
+            throw new IllegalArgumentException("Tentative d'utilisation d'une proglet indéfinie : "+proglet);
+        currentProglet.start();
+        return currentProglet;
+    }
+
+    /** Renvoie la proglet demandé.
+     * @return la proglet ou null sinon.
+     */
+    public Proglet getProglet(String proglet) {
+        for (Proglet p : getProglets()) {
+            if (p.getName().equals(proglet)) {
+                return p;
+            }
+        }
+        return null;
+    }
+
+    /** Renvoie la proglet courante.
+     * * @return la proglet courante ou null sinon.
+     */
+    public Proglet getProglet() {
+        return currentProglet;
+    }
+    private Proglet currentProglet = null;
+
+    /** Renvoie toutes les proglets actuellement disponibles.
+     * @return Un objet utilisable à travers la construction <tt>for(Proglet proglet: getProglets()) { .. / .. }</tt>.
+     */
+    public Iterable<Proglet> getProglets() {
+        return proglets;
+    }
+
+    public class Proglet {
+
+        /** Méta-données de la proglet. */
+        public Pml pml = new Pml();
+
+        /** Définit une proglet à partir d'un répertoire donné.
+         * @param location L'URL (Universal Resource Location) où se trouve la proglet.
+         * @throws IllegalArgumentException Si l'URL est mal formée.
+         * @return Cet objet, permettant de définir la construction <tt>new Proglet().load(..)</tt>.
+         */
+        public Proglet load(String location) {
+            // Définit les méta-données de la proglet.
+            pml.load(location + "proglet.pml", true);
+            pml.set("location", location);
+            try {
+                pml.set("name", new File(location).getName());
+            } catch (Exception e) {
+                throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+            }
+            if (FileManager.exists(Macros.getResourceURL(location + "completion.xml"))) {
+                pml.set("completion", location + "completion.xml");
+            }
+            if (pml.isDefined("icon")
+                    && FileManager.exists(Macros.getResourceURL(location + pml.getString("icon")))) {
+                pml.set("icon-location", location + pml.getString("icon"));
+            } else {
+                pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
+            }
+            try {
+                Class.forName("org.javascool.proglets." + pml.getString("name") + ".Functions");
+                pml.set("has-functions", true);
+            } catch (Throwable e) {
+                pml.set("has-functions", false);
+            }
+            if (!pml.isDefined("help-location")) {
+                pml.set("help-location", pml.getString("location") + "help.htm");
+            }
+            try {
+                pml.set("jvs-translator", (Translator) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Translator").newInstance());
+            } catch (Throwable e) {
+            }
+            return this;
+        }
+
+        @Override
+        public String toString() {
+            return pml.toString();
+        }
+
+        /** Renvoie le nom de la proglet.
+         * @return Le nom de la proglet.
+         */
+        public String getName() {
+            return pml.getString("name");
+        }
+
+        /** Renvoie le titre de la proglet.
+         * @return Le titre de la proglet.
+         */
+        public String getTitle() {
+            return pml.getString("title");
+        }
+
+        /** Renvoie l'icone de la proglet.
+         * @return Le nom de l'URL de l'icone de la proglet, ou l'icone par defaut sinon.
+         */
+        public String getIcon() {
+            return pml.getString("icon-location");
+        }
+
+        /** Renvoie la documentation de la proglet.
+         * @return L'URL de la documentation de la proglet.
+         */
+        public String getHelp() {
+            return pml.getString("help-location");
+        }
+
+        /** Renvoie l'url du fichier de completion de la proglet.
+         * @return L'URL de l'xml de completion de la proglet.
+         */
+        public String getCompletion() {
+            return pml.getString("completion", "");
+        }
+
+        /** Indique si la proglet définit des fonctions statiques pour l'utilisateur.
+         */
+        public boolean hasFunctions() {
+            return pml.getBoolean("has-functions");
+        }
+
+        /** Renvoie, si il existe, le panneau graphique à insérer dans javascool.
+         * @return Le panneau graphique de la proglet si il existe, sinon null.
+         */
+        public Component getPane() {
+           setPane();
+            return (Component) pml.getObject("java-pane");
+        }
+        /** Renvoie, si il existe, le panneau graphique de la proglet.
+         * @return Le panneau graphique de la proglet si il existe, sinon null.
+         */
+        public Component getProgletPane() {
+           setPane();
+           return (Component) pml.getObject("java-proglet-pane");
+        }
+        private void setPane() {
+          if (!pml.isDefined("pane-defined")) {
+              pml.set("pane-defined", true);
+            if (this.isProcessing()) {
+                boolean popup = true;
+                try {
+		  int width = pml.getInteger("width", 500), height = pml.getInteger("height", 500);
+                    Applet applet = (Applet) Class.forName("" + pml.getString("name") + "").newInstance();
+                    applet.init();
+                    applet.setMinimumSize(new Dimension(width, height));
+                    applet.setMaximumSize(new Dimension(width, height));
+                    if (popup) {
+                        popupframe = (new MainFrame() {
+                                @Override
+                            public boolean isClosable() { return false; }
+			  }).asPopup().reset(getName(), getIcon(), width, height, applet);
+                        pml.set("java-pane", null);
+                    }  else {
+                        pml.set("java-pane", applet);
+                    }
+                    pml.set("java-proglet-pane", applet);
+                } catch(java.lang.ClassNotFoundException e0) {
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    System.out.println("Upps erreur de chargement d'une proglet processing : "+e);
+                }
+            } else {
+                try {
+                    Component pane = (Component) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Panel").newInstance();
+                    if (pane instanceof JFrame) {
+                     ((JFrame) pane).setVisible(true);
+                     pml.set("java-pane", null);
+                    } else
+                        pml.set("java-pane", pane);
+                    pml.set("java-proglet-pane", pane);
+                } catch(java.lang.ClassNotFoundException e0) {
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    System.out.println("Upps erreur de chargement d'une proglet : "+e);
+                }
+            }
+            }
+        }
+        private MainFrame popupframe = null;
+        /** Renvoie, si il existe, le translateur de code de la proglet.
+         * @return Le translateur de code de la proglet si il existe, sinon null.
+         */
+        public Translator getTranslator() {
+            return (Translator) pml.getObject("jvs-translator");
+        }
+
+        /** Indique si la proglet a une démo pour l'utilisateur.
+         */
+        public boolean hasDemo() {
+            return getPane() != null && Invoke.run(getPane(), "start", false);
+        }
+
+        /** Lance la démo de la proglet.
+         * @throws RuntimeException si la méthode génère une exception lors de son appel.
+         */
+        public void doDemo() {
+            if (hasDemo()) {
+                (new Thread() {
+
+                    @Override
+                    public void run() {
+                        Invoke.run(getPane(), "start");
+                    }
+                }).start();
+            }
+        }
+
+        /**  Indique si la proglet est une proglet processing.
+         * @return La valeur true si cette applet est développée en processing.
+         */
+        public boolean isProcessing() {
+            return pml.getBoolean("processing");
+        }
+        /** Démarre la proglet. */
+        public void start() {
+        if (popupframe != null)
+            popupframe.setVisible(true);
+       try {
+        if (getPane() != null && getPane() instanceof Applet)
+            ((Applet) getPane()).start();
+        } catch(Throwable e) {
+            System.err.println("Erreur au démarrage de l'applet/proglet");
+        }
+        }
+        /** Arrête la proglet. */
+        public void stop() {
+        try {
+        if (getPane() != null && getPane() instanceof Applet)
+            ((Applet) getPane()).stop();
+        } catch(Throwable e) {
+            System.err.println("Erreur à l'arrêt de l'applet/proglet");
+        }
+        if (popupframe != null)
+            popupframe.setVisible(false);
+        }
+    }
+}
Index: src/org/javascool/core/Exec.java
===================================================================
--- src/org/javascool/core/Exec.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Exec.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,118 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.core;
+
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import java.io.File;
+import org.javascool.macros.Macros;
+import java.io.BufferedInputStream;
+import java.io.FileOutputStream;
+import java.net.URL;
+
+/** Exécute une commande du système d'exploitation.
+ * @see <a href="Exec.java.html">code source</a>
+ * @serial exclude
+ */
+public class Exec {
+  // @factory
+  private Exec() {}
+
+  /** Execute la commande et renvoie le résultat.
+   * @param command La commande avec ses arguments séparés par des tabulations (caractère "\t") ou, sans cela, des espaces (caractère " ").
+   * @param timeout Temporisation maximale avant la fin de la commande.  Valeur par défaut 10.
+   * <p>Si 0, l'attente est indéfinie.</p>
+   * <p>Si -1, la commande est lancée en arrière plan et la fonction revient tout de suite, sans résultat.</p>
+   * @return Le résultat: ce que la commande écrit en sortie.
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'exécution.
+   * @throws IllegalStateException Si le statut de retour de la commande n'est pas 0 (donc a un numéro d'erreur) ou si la temporisation est dépassée.
+   */
+  public static String run(String command, int timeout) {
+    try { 
+      Process process = exec(command);
+      if (timeout == -1)
+        return "";
+      StringBuffer output = new StringBuffer();
+      long time = timeout > 0 ? System.currentTimeMillis() + 1000 * timeout : 0;
+      InputStreamReader stdout = new InputStreamReader(process.getInputStream());
+      InputStreamReader stderr = new InputStreamReader(process.getErrorStream());
+      for(boolean waitfor = true; waitfor;) {
+        waitfor = false;
+        Thread.yield();
+        while(stdout.ready()) {
+          waitfor = true;
+          output.append((char) stdout.read());
+        }
+        while(stderr.ready()) {
+          waitfor = true;
+          output.append((char) stderr.read());
+        }
+        if(!waitfor) {
+          try {
+            process.exitValue();
+          } catch(IllegalThreadStateException e1) {
+            try {
+              Thread.sleep(100);
+            } catch(Exception e2) {}
+            waitfor = true;
+          }
+        }
+        if((time > 0) && (System.currentTimeMillis() > time)) throw new IllegalStateException("Command {" + command + "} timeout (>" + timeout + "s) output=[" + output + "]\n");
+      }
+      stdout.close();
+      stderr.close();
+      // Terminates the process
+      process.destroy();
+      try {
+        process.waitFor();
+      } catch(Exception e) {}
+      Thread.yield();
+      if(process.exitValue() != 0) throw new IllegalStateException("Command {" + command + "} error #" + process.exitValue() + " output=[\n" + output + "\n]\n");
+      return output.toString();
+    } catch(IOException e) { throw new RuntimeException(e + " when executing: " + command);
+    }
+  }
+  /**
+   * @see #run(String, int)
+   */
+  public static String run(String command) {
+    return run(command, 10);
+  }
+  // Lance une commande en arrière plan
+  private static Process exec(String command) throws IOException  {
+    return Runtime.getRuntime().exec(command.trim().split((command.indexOf('\t') == -1) ? " " : "\t"));
+  }
+  /** Démarre un nouveau programme java en place de celui là.
+   * @param jar La jarre contenant le programme Java à lancé à la place de celui là.
+   * @return La valeur true si le programme a pu se lancer, sinon la valeur false.
+   */
+  public static boolean start(String jar) {
+     try {
+       String command = System.getProperty("java.home")+File.separator+"bin"+File.separator+"java\t-jar\t"+getLocal(jar);
+       exec(command);   
+       return true;
+     } catch(IOException e) {
+       System.err.println("Impossible de lancer le jar '"+jar+"' :"+e);
+       return false;
+     }
+  }
+  // Fait une copie locale d'une jarre globale
+  private static String getLocal(String location) throws IOException  {
+     URL url = Macros.getResourceURL(location, true);
+     File file = File.createTempFile(new File(url.getFile()).getName().replaceFirst("\\.jar$", "")+"-", ".jar"); 
+     {
+       BufferedInputStream i = new BufferedInputStream(url.openStream(), 2048);
+       FileOutputStream o = new FileOutputStream(file);
+       byte data[] = new byte[2048];
+       for(int c; (c = i.read(data, 0, 2048)) != -1;)
+         o.write(data, 0, c);
+       i.close();
+       o.close();
+     }
+     return file.getCanonicalPath();
+  }
+}
Index: src/org/javascool/widgets/CurveOutput.java
===================================================================
--- src/org/javascool/widgets/CurveOutput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/CurveOutput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,299 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Color;
+import java.awt.Graphics;
+
+// Used to define a click
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.event.MouseEvent;
+
+// Used to define an icon/label
+
+// Used to store labels
+import java.util.ArrayList;
+
+/** Panneau pour le tracé de courbes 2D.
+ *
+ * @see <a href="CurveOutput.java.html">source code</a>
+ * @serial exclude
+ */
+public class CurveOutput extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  // @bean
+  public CurveOutput() {}
+  private static class point {
+    double x, y;
+  };
+  private ArrayList<ArrayList<point> > curves = new ArrayList<ArrayList<point> >();
+  private static class line {
+    double x1, y1, x2, y2;
+    Color c;
+  }
+  private ArrayList<line> lines = new ArrayList<line>();
+  private static class oval {
+    double x, y, w, h;
+    Color c;
+  }
+  private ArrayList<oval> ovals = new ArrayList<oval>();
+  private static class label {
+    double x, y;
+    String s;
+    Color c;
+  }
+  private ArrayList<label> labels = new ArrayList<label>();
+  {
+    ReticuleMouseListener l = new ReticuleMouseListener();
+    addMouseMotionListener(l);
+    addMouseListener(l);
+    reset(0, 0, 1, 1);
+  }
+
+  /** Routine interne de tracé, ne pas utiliser.
+   *
+   */
+  @Override
+  public void paint(Graphics g) {
+    width = getWidth();
+    height = getHeight();
+    i0 = width / 2;
+    j0 = height / 2;
+    w0 = i0 - 10;
+    h0 = j0 - 10;
+    super.paint(g);
+    paintBackground(g);
+    g.setPaintMode();
+    for(int c = 0; c < 10; c++) {
+      ArrayList<point> curve = curves.get(c);
+      g.setColor(colors[c]);
+      for(int i = 1; i < curve.size(); i++) {
+        point p0 = curve.get(i - 1), p1 = curve.get(i);
+        g.drawLine(x2i(p0.x), y2j(p0.y), x2i(p1.x), y2j(p1.y));
+      }
+    }
+    for(line l : lines) {
+      g.setColor(l.c);
+      g.drawLine(x2i(l.x1), y2j(l.y1), x2i(l.x2), y2j(l.y2));
+    }
+    for(oval l : ovals) {
+      g.setColor(l.c);
+      g.drawOval(x2i(l.x), y2j(l.y), x2w(l.w), y2h(l.h));
+    }
+    for(label l : labels) {
+      int i = x2i(l.x), j = y2j(l.y);
+      g.setColor(l.c);
+      g.drawString(l.s, i, j);
+      g.drawLine(i - 1, j, i + 1, j);
+      g.drawLine(i, j - 1, i, j + 1);
+    }
+    paintReticule(g);
+  }
+  private void paintReticule(Graphics g) {
+    int i = x2i(reticuleX), j = y2j(reticuleY);
+    g.setColor(Color.white);
+    g.setXORMode(Color.black);
+    g.drawLine(i0 - w0, j, i0 + w0, j);
+    g.drawLine(i, j0 - h0, i, j0 + h0);
+  }
+  private void paintBackground(Graphics g) {
+    g.setPaintMode();
+    g.setColor(Color.CYAN);
+    g.fillRoundRect(1, 1, width - 2, height - 2, 30, 30);
+    g.setColor(Color.BLACK);
+    g.drawRoundRect(1, 1, width - 2, height - 2, 30, 30);
+    g.setColor(Color.DARK_GRAY);
+    g.fillRect(i0 - w0, j0 - h0, 2 * w0, 2 * h0);
+    g.setColor(Color.WHITE);
+    g.drawRect(i0 - w0, j0 - h0, 2 * w0, 2 * h0);
+    g.drawLine(i0, j0 - h0, i0, j0 + h0);
+    g.drawLine(i0 - w0, j0, i0 + w0, j0);
+  }
+  private int x2i(double x) {
+    return (int) Math.rint(i0 + w0 * x);
+  }
+  private int y2j(double y) {
+    return (int) Math.rint(j0 - h0 * y);
+  }
+  private int x2w(double x) {
+    return (int) Math.rint(w0 * x);
+  }
+  private int y2h(double y) {
+    return (int) Math.rint(h0 * y);
+  }
+  private double i2x(int i) {
+    return ((double) (i - i0)) / w0;
+  }
+  private double j2y(int j) {
+    return ((double) (j0 - j)) / h0;
+  }
+  private int width, height, i0, j0, w0, h0;
+
+  private class ReticuleMouseListener implements MouseMotionListener, MouseListener {
+    private static final long serialVersionUID = 1L;
+    @Override
+    public void mouseDragged(MouseEvent e) {
+      paintReticule(getGraphics());
+      reticuleX = i2x(e.getX());
+      reticuleY = j2y(e.getY());
+      paintReticule(getGraphics());
+    }
+    @Override
+    public void mouseReleased(MouseEvent e) {
+      mouseDragged(e);
+      if(runnable != null)
+        runnable.run();
+    }
+    @Override
+    public void mouseMoved(MouseEvent e) {}
+    @Override
+    public void mousePressed(MouseEvent e) {}
+    @Override
+    public void mouseClicked(MouseEvent e) {}
+    @Override
+    public void mouseEntered(MouseEvent e) {}
+    @Override
+    public void mouseExited(MouseEvent e) {}
+  }
+
+  /** Efface et initialize le tracé.
+   * @param Xoffset Abscisse du point central. 0 par défaut.
+   * @param Yoffset Ordonnée du point central. 0 par défaut.
+   * @param Xscale Echelle horizontale, le tracé se fait dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param Yscale Echelle verticale, le tracé se fait dans  [-Yscale+Yoffset..Yscale+Yoffset].
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
+   */
+  public CurveOutput reset(double Xoffset, double Yoffset, double Xscale, double Yscale) {
+    this.Xoffset = Xoffset;
+    this.Yoffset = Yoffset;
+    this.Xscale = Xscale;
+    this.Yscale = Yscale;
+    curves = new ArrayList<ArrayList<point> >();
+    for(int c = 0; c < 10; c++)
+      curves.add(new ArrayList<point>());
+    lines = new ArrayList<line>();
+    ovals = new ArrayList<oval>();
+    labels = new ArrayList<label>();
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /** Efface et initialize le tracé.
+   * @param Xscale Echelle horizontale.
+   * @param Yscale Echelle verticale.
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
+   * @see #reset(double, double, double, double)
+   */
+  public CurveOutput reset(double Xscale, double Yscale) {
+    return reset(0, 0, Xscale, Yscale);
+  }
+  /**
+   * @see #reset(double, double, double, double)
+   */
+  public CurveOutput reset() {
+    return reset(0, 0, 1, 1);
+  }
+  private double Xoffset = 0, Yoffset = 0, Xscale = 1, Yscale = 1;
+
+  /** Ajoute un point à une courbe.
+   * @param x Abscisse du point dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du point dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param c Couleur de la courbe, dans {0, 9}. Le code des couleurs est le suivant:
+   * <div id="colors"><b>Code des couleurs</b><table>
+   * <tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr>
+   * <tr><td>noir</td><td>marron</td><td>rouge</td><td>orange</td><td>jaune</td><td>vert</td><td>bleu</td><td>violet</td><td>gris</td><td>blanc</td></td>
+   * </table></div>
+   */
+  public void add(double x, double y, int c) {
+    point p = new point();
+    p.x = (x - Xoffset) / Xscale;
+    p.y = (y - Yoffset) / Yscale;
+    if((0 <= c) && (c < 10))
+      curves.get(c).add(p);
+    repaint(0, 0, getWidth(), getHeight());
+  }
+  /** Trace une ligne.
+   * @param x1 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y1 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param x2 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y2 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x1, double y1, double x2, double y2, int c) {
+    line l = new line();
+    l.x1 = (x1 - Xoffset) / Xscale;
+    l.y1 = (y1 - Yoffset) / Yscale;
+    l.x2 = (x2 - Xoffset) / Xscale;
+    l.y2 = (y2 - Yoffset) / Yscale;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    lines.add(l);
+  }
+  /** Trace un cercle.
+   * @param x Abscisse du centre, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param r Rayon du cercle.
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x, double y, double r, int c) {
+    oval l = new oval();
+    l.x = (x - Xoffset - r) / Xscale;
+    l.y = (y - Yoffset + r) / Yscale;
+    l.w = 2 * r / Xscale;
+    l.h = 2 * r / Yscale;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    ovals.add(l);
+  }
+  /** Trace une chaîne de caractères.
+   * @param x Abscisse du coin en haut à gauche du texte, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du coin en haut à gauche du texte, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param s Texte à tracer.
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x, double y, String s, int c) {
+    label l = new label();
+    l.x = (x - Xoffset) / Xscale;
+    l.y = (y - Yoffset) / Yscale;
+    l.s = s;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    labels.add(l);
+  }
+  /** Renvoie la position horizontale du réticule. */
+  public double getReticuleX() {
+    return Xoffset + Xscale * reticuleX;
+  }
+  /** Renvoie la position verticale du réticule. */
+  public double getReticuleY() {
+    return Yoffset + Yscale * reticuleY;
+  }
+  /** Définit la position du réticule.
+   * @param x Abscisse du réticule, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Reticule ordinate, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   */
+  public void setReticule(double x, double y) {
+    x -= Xoffset;
+    x /= Xscale;
+    y -= Yoffset;
+    y /= Yscale;
+    reticuleX = x < -1 ? -1 : x > 1 ? 1 : x;
+    reticuleY = y < -1 ? -1 : y > 1 ? 1 : y;
+    repaint(0, 0, getWidth(), getHeight());
+  }
+  private double reticuleX = 0, reticuleY = 0;
+
+  private static Color colors[] = { Color.BLACK, new Color(150, 75, 0), Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.MAGENTA, Color.GRAY, Color.WHITE };
+
+  /** Définit une portion de code appellée à chaque modification du réticule.
+   * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().setRunnable(..)</tt>.
+   */
+  public CurveOutput setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+  private Runnable runnable = null;
+}
Index: src/org/javascool/widgets/PanelApplet.java
===================================================================
--- src/org/javascool/widgets/PanelApplet.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/PanelApplet.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,108 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to encapsulate a proglet
+import javax.swing.JApplet;
+import java.awt.BorderLayout;
+import java.awt.Component;
+import javax.swing.JLabel;
+import org.javascool.tools.Invoke;
+
+/** Définit une applet qui encapsule un objet graphique.
+ * <p>Permet de wrapper un objet graphique dans une page HTML avec une construction de la forme
+ * <div><tt>&lt;applet code="org.javascool.widgets.PanelApplet" archive="les-classes-java.jar" width="560" height="720"></tt></div>
+ * <div><tt>&lt;param name="panel" value="nom-complet-qualifé-de-l-objet-graphique"/></tt></div>
+ * <div><tt>&lt;param name="manual-start" value="true-ou-false"/></tt></div>
+ * <div><tt>&lt;/applet></tt></div>
+ * </p>
+ * <ul>
+ * <li>L'objet doit être un instance de <tt>java.awt.Component</tt> donc n'importe quel composant «swing» ou «awt».</li>
+ * <li>Si l'objet possède des méthodes <tt>init<tt>, , <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> elles sont invoquées par les méthodes correspondandes de l'applet.</li>
+ * <li>Si l'option <tt>manual-start</tt> est activée les méthodes <tt>start</tt>, <tt>stop</tt> ne sont invoquées par l'applet mais par un bouton utilisateuer.</li>
+ * </ul>
+ * @see <a href="PanelApplet.java.html">source code</a>
+ * @serial exclude
+ */
+public class PanelApplet extends JApplet {
+  private static final long serialVersionUID = 1L;
+
+  /** Definition programmatique des paramètres de l'applet.
+   * @param panel Le nom de la classe Java de l'objet graphique à afficher.
+   * @param manualStart Invocations manuelles si true des méthodes <tt>start/stop</tt> (par défaut), sinon elles sont invoquées au lancement.
+   * @return Cet objet, permettant de définir la construction <tt>new PanelApllet().reset(..)</tt>.
+   */
+  public PanelApplet reset(String panel, boolean manualStart) {
+    this.panel = panel;
+    this.manualStart = manualStart;
+    return this;
+  }
+  /**
+   * @see #reset(String, boolean)
+   */
+  public PanelApplet reset(String panel) {
+    return reset(panel, true);
+  }
+  private String panel = null;
+  private boolean manualStart = true;
+  @Override
+  public void init() {
+    if (pane != null)
+      throw new IllegalStateException("Impossible d'instancier deux PanelApplet dans une application");
+    try {
+      if(panel == null) {
+        panel = getParameter("panel");
+        manualStart = getParameter("manualStart") == null || getParameter("manualStart").toLowerCase().equals("true");
+      }
+    } catch(Exception e) {}
+    try {
+      getContentPane().add(pane = (Component) Class.forName(panel).newInstance(), BorderLayout.CENTER);
+    } catch(Exception e) {
+      System.err.println(e);
+      getContentPane().add(new JLabel("Pas d'applet à montrer.", JLabel.CENTER), BorderLayout.CENTER);
+      manualStart = false;
+    }
+    if(manualStart && Invoke.run(pane, "start", false)) {
+      getContentPane().add(new ToolBar().addTool("Démo de la proglet", "org/javascool/widgets/icons/play.png", new Runnable() { public void run() {
+	(new Thread() { public void run() {
+	  Invoke.run(pane, "start");
+	}}).start();
+      }}), BorderLayout.NORTH);
+    }
+    Invoke.run(pane, "init");
+  }
+  @Override
+  public void destroy() {
+    Invoke.run(pane, "init");
+  }
+  @Override
+  public void start() {
+    if(!manualStart)
+      Invoke.run(pane, "start");
+  }
+  @Override
+  public void stop() {
+    if(!manualStart)
+      Invoke.run(pane, "stop");
+  }
+ /** Renvoie le panneau graphique de la proglet courante.
+   * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
+   */
+  public static Component getPane() {
+    return pane;
+  }
+  static {
+    MainFrame.setLookAndFeel();
+  }
+  private static Component pane = null;
+  /** Lanceur dans une fenêtre principale d'une objet graphique.
+   * @param usage <tt>java org.javascool.widgets.PanelApplet nom-complet-qualifé-de-l-objet-graphique</tt>.
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 0)
+      new MainFrame().reset(new PanelApplet().reset(usage[0]));
+  }
+}
Index: src/org/javascool/widgets/package.html
===================================================================
--- src/org/javascool/widgets/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les widgets et routines que le formateur peut utiliser pour faire de nouvelles proglets.</body>
+
Index: src/org/javascool/widgets/ToolBar.java
===================================================================
--- src/org/javascool/widgets/ToolBar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/ToolBar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,119 @@
+package org.javascool.widgets;
+
+import javax.swing.JToolBar;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.util.HashMap;
+import javax.swing.Box;
+import javax.swing.JComponent;
+import javax.swing.AbstractButton;
+import javax.swing.JButton;
+import org.javascool.macros.Macros;
+
+/** Définit une barre d'outils avec intégration de la gestion des actions.
+ *
+ * @author Philippe Vienne
+ * @see <a href="ToolBar.java.html">code source</a>
+ * @serial exclude
+ */
+public class ToolBar extends JToolBar {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public ToolBar() {
+    setFloatable(false);
+  }
+  /** Table des boutons indexés par leurs noms. */
+  private HashMap<String, JComponent> buttons = new HashMap<String, JComponent>();
+  /** Table des actions associées au bouton. */
+  private HashMap<AbstractButton, Runnable> actions = new HashMap<AbstractButton, Runnable>();
+
+  /** Initialize la barre de boutons et efface tous les élements. */
+  @Override
+  public void removeAll() {
+    left = right = 0;
+    setVisible(false);
+    revalidate();
+    super.removeAll();
+    buttons.clear();
+    actions.clear();
+    setVisible(true);
+    revalidate();
+  }
+  /** Ajoute un bouton à la barre d'outils.
+   * @param label Nom du bouton. Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param icon  Icone du bouton. Si null le bouton est montré sans icone.
+   * @param action Action associée au bouton.
+   * @return Le bouton ajouté.
+   */
+  public final JButton addTool(String label, String icon, Runnable action) {
+    return addTool(label, icon, action, left++);
+  }
+  /**
+   * @see #addTool(String, String, Runnable)
+   */
+  public final JButton addTool(String label, Runnable action) {
+    return addTool(label, null, action);
+  }
+  /** Ajoute un bouton à une position précise de la barre d'outil
+   * @see #addTool(String, String, Runnable)
+   */
+  private JButton addTool(String label, String icon, Runnable action, int where) {
+    JButton button = icon == null ? new JButton(label) : new JButton(label, Macros.getIcon(icon));
+    button.addActionListener(new ActionListener() {
+                               @Override
+                               public void actionPerformed(ActionEvent e) {
+                                 actions.get((AbstractButton) e.getSource()).run();
+                               }
+                             }
+                             );
+    add(button, where);
+    if(buttons.containsKey(label)) throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
+    buttons.put(label, button);
+    actions.put(button, action);
+    revalidate();
+    return button;
+  }
+  /** Ajoute un composant à la barre d'outils.
+   * @param label Nom du composant (ce nom restera invisible). Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param component Le composant à ajouter.
+   */
+  public void addTool(String label, JComponent component) {
+    add(component, left++);
+    if(buttons.containsKey(label)) throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
+    buttons.put(label, component);
+    revalidate();
+  }
+  /** Efface un composant de la barre d'outils. */
+  public void removeTool(String label) {
+    if(buttons.containsKey(label)) {
+      JComponent c = buttons.get(label);
+      remove(c);
+      buttons.remove(label);
+      if(c instanceof AbstractButton && actions.containsKey((AbstractButton) c))
+        actions.remove((AbstractButton) c);
+      setVisible(false);
+      revalidate();
+      setVisible(true);
+      revalidate();
+    }
+  }
+  /** Ajoute un composant à la droite de la barre d'outil.
+   * @param label Nom du composant (ce nom restera invisible). Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param action Action associée au bouton.
+   * @return Le bouton ajouté.
+   */
+  public JButton addRightTool(String label, Runnable action) {
+    if(right == 0)
+      add(Box.createHorizontalGlue());
+    return addTool(label, null, action, left + (++right));
+  }
+  /** Ajoute un composant à la barre d'outils.
+   * @param component Le composant à ajouter.
+   */
+  public void addRightTool(JComponent component) {
+     if(right == 0)
+      add(Box.createHorizontalGlue());
+    add(component, left + (++right));
+  }
+  private int left = 0, right = 0;
+}
Index: src/org/javascool/widgets/IconOutput.java
===================================================================
--- src/org/javascool/widgets/IconOutput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/IconOutput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,251 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.util.HashMap;
+
+// Used to manipulate the image
+import java.awt.image.BufferedImage;
+import java.awt.Graphics2D;
+import java.awt.Dimension;
+import javax.imageio.ImageIO;
+import org.javascool.macros.Macros;
+import java.io.IOException;
+
+/** Panneau pour le tracé d'images pixeliques.
+ *
+ * @see <a href="IconOutput.java.html">source code</a>
+ * @serial exclude
+ */
+public class IconOutput extends JPanel {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public IconOutput() {
+    setBackground(Color.GRAY);
+    setPreferredSize(new Dimension(550, 550));
+    reset(550, 550);
+  }
+  /** Routine interne de tracé, ne pas utiliser.
+   *
+   */
+  @Override
+  public void paint(Graphics g) {
+    super.paint(g);
+    setBounds();
+    g.setPaintMode();
+    for(int j = 0; j < height; j++)
+      for(int i = 0; i < width; i++) {
+	int ij = i + j * width;
+	if (0 <= ij && ij < image.length) {
+	  g.setColor(image[ij]);
+	  g.fillRect(i0 + i * dij, j0 + j * dij, dij, dij);
+	}
+      }
+    Graphics2D g2d = (Graphics2D) g;
+    paint2D(g2d);
+  }
+  /** Cette routine est appellée à chaque tracé et permet de définir un tracé spécifique au dessus de l'image affichée. 
+   * - Pour utiliser cette foncctionnalité, il faut définir: <pre>
+   * class MyIconInput extends IconInput {
+   *   public void paint2D(Graphics2D g) {
+   *     // Ici ajouter les g.drawLine g.fillOval g.drawRect g.fillRect souhaité.
+   *   }
+   * }</pre>
+   * @param g2d L'environnement graphique 2D à utiliser pour peindre.
+   */
+  public void paint2D(Graphics2D g2d) {
+  }
+  private void setBounds() {
+    int di = width > 0 && getWidth() >= width && zoom ? getWidth() / width : 1;
+    int dj = height > 0 && getHeight() >= height && zoom ? getHeight() / height : 1;
+    dij = di < dj ? di : dj;
+    i0 = (getWidth() - width * dij) / 2;
+    j0 = (getHeight() - height * dij) / 2;
+  }
+  /**  Efface et initialize l'image.
+   * @param width Taille horizontale de l'image.
+   * @param height Taille verticale de l'image.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public final IconOutput reset(int width, int height, boolean zoom) {
+    if(width > 550 || height > 550 || width * height > 550 * 550) throw new IllegalArgumentException("Image size too big !");
+    this.zoom = zoom;
+    if (width <= 0)
+      width = 300;
+    if (height <= 0)
+      height = 300;
+    if(width % 2 == 0)
+      width++;
+    if(height % 2 == 0)
+      height++;
+    image = new Color[(this.width = width) * (this.height = height)];
+    for(int ij = 0; ij < this.width * this.height; ij++)
+      image[ij] = Color.WHITE;
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /**
+   * @see #reset(int, int, boolean)
+   */
+  public final IconOutput reset(int width, int height) {
+    return reset(width, height, true);
+  }
+  /** Initialize l'image à partir d'un fichier.
+   * @param location L'URL (Universal Resource Location) de l'image.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public IconOutput reset(String location, boolean zoom) throws IOException {
+    // Fait 2//3 essais sur l'URL si besoin
+    for (int n = 0; n < 3; n++) {
+      BufferedImage img = ImageIO.read(Macros.getResourceURL(location));
+      if(img != null)
+	return reset(img, zoom);
+    }
+    throw new IOException("Unable to load the image " + location);
+  }
+  /**
+   * @see #reset(String, boolean)
+   */
+  public final IconOutput reset(String location)  throws IOException {
+    return reset(location, true);
+  }
+  /** Initialize l'image à partir d'une image en mémoire.
+   * @param img L'image qui va initialiser le tracé.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public IconOutput reset(BufferedImage img, boolean zoom) {
+    reset(img.getWidth(), img.getHeight(), zoom);
+    for(int j = 0; j <  img.getHeight(); j++)
+      for(int i = 0; i < img.getWidth(); i++)
+	image[i + width * j] = new Color(img.getRGB(i, j));
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /**
+   * @see #reset(BufferedImage, boolean)
+   */
+  public final IconOutput reset(BufferedImage img) {
+    return reset(img, true);
+  }
+  /** Renvoie les dimensions de l'image. */
+  public Dimension getDimension() {
+    return new Dimension(width, height);
+  }
+  /** Renvoie une image dans laquelle le contenu de l'affichage est copié.
+   * @return Le contenu de l'affichage sous forme d'image.
+   */
+  public BufferedImage getImage() {
+    BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+    for(int j = 0; j < img.getHeight(); j++)
+      for(int i = 0; i < img.getWidth(); i++)
+	img.setRGB(i, j, image[i + width * j].getRGB());
+    return img;
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param  c Couleur: "black" (default), "blue", "cyan", "gray", "green", "magenta", "orange", "pink", "red", "white", "yellow".
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, String c) {
+    return set(x, y, getColor(c));
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param v L'intensité en niveau de gris du pixel de 0 (noir) à 255 (blanc).
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, int v) {
+    v = v < 0 ? 0 : v > 255 ? 255 : v;
+    return set(x, y, new Color(v, v, v));
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param c L'intensité en couleur du pixel.
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, Color c) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      setBounds();
+      int ij = x + y * width;
+      image[ij] = c;
+      repaint(i0 + x * dij, j0 + y * dij, dij, dij);
+      return true;
+    } else
+      return false;
+  }
+  /** Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return L'intensite du pixel entre 0 et 255 ou 0 si le pixel n'est pas dans l'image.
+   */
+  public int getIntensity(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return (c.getRed() + c.getGreen() + c.getBlue()) / 3;
+    } else
+      return 0;
+  }
+  /**  Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return La couleur du pixel ou "undefined" si le pixel n'est pas dans l'image.
+   */
+  public String getColor(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return colors.containsKey(c) ? colors.get(c) : c.toString();
+    } else
+      return "undefined";
+  }
+  /**  Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return La couleur du pixel ou black si le pixel n'est pas dans l'image.
+   */
+  public Color getPixelColor(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return c;
+    } else
+      return Color.BLACK;
+  }
+  private Color image[];
+  private int width, height, i0, j0, dij;
+  boolean zoom = true;
+
+  private static HashMap<Color, String> colors = new HashMap<Color, String>();
+  private static Color getColor(String color) {
+    try { return (Color) Class.forName("java.awt.Color").getField(color).get(null);
+    } catch(Exception e) {
+      return Color.BLACK;
+    }
+  }
+  private static void putColors(String color) {
+    colors.put(getColor(color), color);
+  }
+  static {
+    putColors("black");
+    putColors("blue");
+    putColors("cyan");
+    putColors("gray");
+    putColors("green");
+    putColors("magenta");
+    putColors("orange");
+    putColors("pink");
+    putColors("red");
+    putColors("white");
+    putColors("yellow");
+  }
+}
Index: src/org/javascool/widgets/Dialog.java
===================================================================
--- src/org/javascool/widgets/Dialog.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/Dialog.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,61 @@
+package org.javascool.widgets;
+
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import javax.swing.JDialog;
+import javax.swing.SwingUtilities;
+import org.javascool.macros.Macros;
+
+/** Définit un dialogue en popup qui gère l'aspect modal/non-modal.
+ * <p>Si le dialog est appelé de l'AWT il est non-modal (donc ne bloque pas l'AWT) sinon il est modal (il blqieu jusqu'à complétion du dialogue).
+ * <p>Son utilisation typique se fait à travers une construction de la forme:<pre>
+ * dialog = new NonModalDialog();
+ * dialog.add(.. le composant du dialogue ..);
+ * dialog.open(true);</pre></p>
+ * <p>Lorsque le composant du dialogue reçoit la réponse il ferme le dialogue, par exemple:<pre>
+ *  public void actionPerformed(ActionEvent e) {
+ *    ... report de la valeur fournie par l'utilisateur ...
+ *    messageDialog.close();
+ * }</pre></p>
+ */
+public class Dialog extends JDialog {
+  // @bean
+  public Dialog() {
+    super(MainFrame.getFrame());
+    addWindowListener(new WindowAdapter() {
+	@Override
+	  public void windowClosing(WindowEvent e) {
+	  pending = false;
+	}
+      }
+		      );
+  }
+  /** Ouvre le dialogue et entre en attente d'un retour de l'utilisateur. 
+   * @param modal Si true le dialogue est bloquant et attend la réponse de l'utilisateur, si false il est non-modal et renvoie la main AVANT que le dialogue soit complété.
+   * <p>Il ne faut pas appelé le dialogue en mode modal directement d'un gestionnaire d'événement (bouton, etc..) mais utiliser un Thread.</p>
+   */
+  public void open(boolean modal) {
+    setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
+    pack();
+    if (MainFrame.getFrame() != null)
+       setLocation((MainFrame.getFrame().getWidth() - getWidth()) / 2, (MainFrame.getFrame().getHeight() - getHeight()) / 2);
+    setVisible(true);
+    if (modal && SwingUtilities.isEventDispatchThread())
+      throw new IllegalStateException("Impossible d'utiliser un dialogue modal directement d'un événement de l'interface: créer un thread");
+    pending = modal;
+    while(pending) 
+      Macros.sleep(100);
+  }
+  /** Routine à appeler quand le dialogue à été achevé pour continuer le programme. */
+  public void close() {
+    dispose();
+    pending = false;
+  }
+  /** Teste si le dialogue est en cours ou achevé. 
+   * return La valeur true si le dialogue est en cours, sinon false.
+   */
+  public boolean isOpen() {
+    return pending;
+  }
+  private boolean pending = false;
+}
Index: src/org/javascool/widgets/Console.java
===================================================================
--- src/org/javascool/widgets/Console.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/Console.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,133 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+
+package org.javascool.widgets;
+
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import javax.swing.JLabel;
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+
+// redirectSystemStreams
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.io.IOException;
+import org.javascool.tools.FileManager;
+
+/** Définit une zone d'affichage qui permet de recevoir les messages de la console.
+ *
+ * @author Philippe Vienne
+ * @see <a href="Console.java.html">code source</a>
+ * @serial exclude
+ */
+public class Console extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  /** Zone d'affichage */
+  private JTextArea outputPane;
+  /** Barre de menu */
+  private ToolBar toolbar;
+  /** Zone d'affichage du statut. */
+  private JLabel status;
+
+  // @static-instance
+
+  /** Crée et/ou renvoie l'unique instance de console.
+   * <p>Une application ne peut définir qu'une seule console.</p>
+   */
+  public static Console getInstance() {
+    if(console == null)
+      console = new Console();
+    return console;
+  }
+  /** Renvoie true si la console a déjà été instanciée, false sinon. */
+  public static boolean isInstanced() {
+    return console != null;
+  }
+  private static Console console = null;
+  private Console() {
+    BorderLayout layout = new BorderLayout();
+    this.setLayout(layout);
+    // Construit la zone d'affichage
+    outputPane = new JTextArea();
+    outputPane.setEditable(false);
+    float[] bg = Color.RGBtoHSB(200, 200, 200, null);
+    outputPane.setBackground(Color.getHSBColor(bg[0], bg[1], bg[2]));
+    JScrollPane scrolledOutputPane = new JScrollPane(outputPane);
+    this.add(scrolledOutputPane, BorderLayout.CENTER);
+    // Construit la zone des bouttons
+    toolbar = new ToolBar();
+    toolbar.addTool("Effacer", "org/javascool/widgets/icons/erase.png", new Runnable() {
+                      @Override
+                      public void run() {
+                        clear();
+                      }
+                    }
+                    );
+    toolbar.addSeparator();
+    toolbar.addTool("status", status = new JLabel("                                         "));
+    this.add(toolbar, BorderLayout.NORTH);
+    // Finalise l'objet
+    redirectSystemStreams();
+    this.setVisible(true);
+  }
+  /** Redirige le System.out vers cet affichage */
+  private void redirectSystemStreams() {
+      final OutputStream oldOut = System.out;
+      OutputStream out = new OutputStream() {
+      @Override
+      public void write(int b) throws IOException {
+        print(String.valueOf((char) b));
+        oldOut.write(b);
+      }
+      @Override
+      public void write(byte[] b, int off, int len) throws IOException {
+        print(new String(b, off, len));
+        oldOut.write(b, off, len);
+      }
+      @Override
+      public void write(byte[] b) throws IOException {
+        write(b, 0, b.length);
+        oldOut.write(b);
+      }
+    };
+    System.setOut(new PrintStream(out, true));
+  }
+  /** Efface le contenu de la console. */
+  public void clear() {
+    outputPane.setText("");
+  }
+  /** Affiche une information dans la barre de statut.
+   * @param text Texte à afficher.
+   */
+  public void show(String text) {
+    status.setText(text);
+  }
+  /** Affiche du texte dans la console.
+   * @param text Le texte à afficher.
+   */
+  public void print(String text) {
+    outputPane.append(text);
+  }
+  /** Renvoie le contenu actuel de la console.
+   * @return Ce qui affiché dans la console.
+   */
+  public String getText() {
+    return outputPane.getText();
+  }
+  /** Renvoie la barre de menu de la console pour ajouter des éléments.
+   * @return La barre de menu de la console.
+   */
+  public ToolBar getToolBar() {
+    return toolbar;
+  }
+  /** Sauve ce qui est présentement écrit dans la console dans un fichierL.
+   * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.
+   */
+  public void saveConsoleOutput(String location) {
+    FileManager.save(location, getText());
+  }
+}
Index: src/org/javascool/widgets/HtmlDisplay.java
===================================================================
--- src/org/javascool/widgets/HtmlDisplay.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/HtmlDisplay.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,263 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2004.  All rights reserved.   *
+*********************************************************************************/
+package org.javascool.widgets;
+
+// Used to build the gui
+import java.net.MalformedURLException;
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.io.File;
+import java.io.IOException;
+import javax.swing.JButton;
+import javax.swing.JScrollPane;
+import javax.swing.JEditorPane;
+
+// Used to manage links
+import javax.swing.event.HyperlinkEvent;
+import javax.swing.event.HyperlinkListener;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.net.URLDecoder;
+import javax.swing.text.Document;
+import org.javascool.macros.Macros;
+
+// Used to manage keystroke
+import java.util.ArrayList;
+
+/** Definit un visualisateur de pages HTML3.
+ * <p><i>Note:</i> L'implémentation disponible ne rend utilisable que le "vieux" HTML-3.</p>
+ * <p><i>Conseil:</i> Ecrire les pages en <a href="http://javascool.gforge.inria.fr/v4/index.php?page=developers&action=doc-xml">HML</a> (en XHTML simplifié),
+ * la maintenance et polyvalence des pages en sera renforcée.</p>
+ * <div id="URLs"><p><b>Mécanismes d'affichage des contenus:</b><ul>
+ * <li>Les pages locales d'extension <tt>*.htm</tt> sont réputées être du HTML3 et sont affichées ici.</li>
+ * <li>Les autres pages <tt>http://</tt>, <tt>file://</tt>, etc.. sont visualiées dans le navigateur du système, extérieur à javascool.</li>
+ * <li>Il est possible d'ouvrir des pages dans une cible autre que ce visualisateur: <ul>
+ *   <li>Les liens de la forme <tt>http://editor/<i>location</i></tt> ouvrent le document dans l'éditeur de JavaScool. <br>
+ *     Il sont générés par un tag de la form <tt>&lt;l class="editor" ..</tt></li>
+ *   <li>Les liens de la forme <tt>http://newtab/<i>location</i></tt> ouvrent le document dans un autre onglet de JavaScool.<br>
+ *     Il sont générés par un tag de la form <tt>&lt;l class="newtab" ..</tt></li> </li>
+ * </ul> Il sont produits par les tags <tt>&lt;a target="editor" . . </tt> du XML.
+ * En cas d'échec les contenus sont dirigés vers le navigateur du système, extérieur à javascool.</li>
+ * <li>Les liens de la forme <tt>string://?value="text"</tt> permettent d'afficher directement du texte HTML3.</li>
+ * <li>Les autres liens font l'objet d'un appel à la méthode <tt>doBrowse()</tt> ce qui permet de définir des URI dépendant de l'application.</li>
+ * </ul></div>
+ *
+ * @see <a href="HtmlDisplay.java.html">source code</a>
+ * @serial exclude
+ */
+public class HtmlDisplay extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  /** Le panneau d'affichage du texte. */
+  private JEditorPane pane;
+  /** Les bottons de navigation. */
+  private JButton home, prev, next;
+
+  /** Définit le préfix pour une chaîne. */
+  static private final String stringPrefix = "http://string?";
+  /** Définit le préfix pour une ouverture dans l'éditeur. */
+  static private final String editorPrefix = "http://editor?";
+  /** Définit le préfix pour une ouverture dans un onglet. */
+  static private final String newtabPrefix = "http://newtab?";
+
+  // @bean
+  public HtmlDisplay() {
+    setLayout(new BorderLayout());
+    {
+      ToolBar bar = new ToolBar();
+      home = bar.addTool("Page initiale", "org/javascool/widgets/icons/refresh.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasHome())
+                               update(urls.getHome(), false);
+                           }
+                         }
+                         );
+      prev = bar.addTool("Page précédente", "org/javascool/widgets/icons/prev.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasPrev())
+                               update(urls.getPrev(), false);
+                           }
+                         }
+                         );
+      next = bar.addTool("Page suivante", "org/javascool/widgets/icons/next.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasNext())
+                               update(urls.getNext(), false);
+                           }
+                         }
+                         );
+      add(bar, BorderLayout.NORTH);
+    }
+    {
+      pane = new JEditorPane();
+      pane.setBackground(Color.WHITE);
+      pane.setEditable(false);
+      pane.setContentType("text/html; charset=utf-8");
+      pane.addHyperlinkListener(new HyperlinkListener() {
+                                  @Override
+                                  public void hyperlinkUpdate(HyperlinkEvent e) {
+                                    if(e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
+                                      update(e.getDescription(), true);
+                                  }
+                                }
+                                );
+      JScrollPane spane = new JScrollPane(pane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
+      add(spane, BorderLayout.CENTER);
+    }
+  }
+  /** Affiche une page de texte HTML3 dans le visualisateur.
+   * @param location L'URL de la page à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setPage(..)</tt>.
+   */
+  public HtmlDisplay setPage(String location) {
+    update(location, true);
+    return this;
+  }
+  public HtmlDisplay setPage(URL location) {
+    update(location, true);
+    return this;
+  }
+  /** Affiche un texte HTML3 dans le visualisateur.
+   * @param text Le texte à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setText(..)</tt>.
+   */
+  public HtmlDisplay setText(String text) {
+    try {
+      return setPage(stringPrefix + URLEncoder.encode(text, "utf-8"));
+    } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu: (" + e + ") c'est un bug Java !");
+    }
+  }
+  /** Met à jour les boutons selon l'état de la pile. */
+  private void updateButtons() {
+    home.setEnabled(urls.hasHome());
+    prev.setEnabled(urls.hasPrev());
+    next.setEnabled(urls.hasNext());
+  }
+  /** Définit une pile d'URL avec le mécanisme de home/prev/next. */
+  private class URLStack extends ArrayList<Object>{
+    private static final long serialVersionUID = 1L;
+    /** Index courant dans la pile. */
+    private int current = -1;
+    /** Ajoute un élément dans la pile. */
+    public void push(Object url) {
+      current++;
+      while(current < size())
+        remove(current);
+      add(url);
+    }
+    public Object getCurrent() {
+      return current >= 0 ? get(current) : null;
+    }
+    public boolean hasHome() {
+      return current >= 0;
+    }
+    public Object getHome() {
+      if(hasHome())
+        current = 0;
+      return getCurrent();
+    }
+    public boolean hasPrev() {
+      return current > 0;
+    }
+    public Object getPrev() {
+      if(hasPrev())
+        current--;
+      return getCurrent();
+    }
+    public boolean hasNext() {
+      return current < size() - 1;
+    }
+    public Object getNext() {
+      if(hasNext())
+        current++;
+      return getCurrent();
+    }
+    @Override
+    public String toString() {
+      String s = "";
+      for(int i = size() - 1; i >= 0; i--)
+        s += (i == current ? " * " : "   ") + get(i) + "\n";
+      return s;
+    }
+  }
+  private URLStack urls = new URLStack();
+
+  /** Implémentation du mécanisme de gestion des URL spécifiques.
+   * <p>Cette routine est appelée pour gérer des URL specifiques d'une application donnée.</p>
+   * @param location L'URL à traiter.
+   * @return Cette méthode doit retourner true si l'URL à été traité et false si l'URL n'a pas été reconnu ou traité.
+   */
+  public boolean doBrowse(String location) {
+    return false;
+  }
+  /** Gestion des URLs externes par le navigateur du système. */
+  private void browse(String location) {
+    try {
+      java.awt.Desktop.getDesktop().browse(new java.net.URI(location));
+    } catch(Exception e) {
+      setText("Cette page est à l'adresse internet: <tt>«" + location.replaceFirst("^(mailto):.*", "$1: ...") + "»</tt> (non accessible ici).");
+    }
+  }
+  /** Mécanisme de gestion des URL. */
+  private void update(String location, boolean push) {
+    // Gestion des contenus textuels
+    if(location.startsWith(stringPrefix)) { // Affichage de texte
+      try {
+        if(push)
+          urls.push(location);
+        pane.setText(URLDecoder.decode(location.substring(stringPrefix.length()), "utf-8"));
+      } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu : (" + e + ") c'est un bug Java !");
+      }
+    } else if(location.startsWith(editorPrefix)) {  // Affichage dans editeur JavaScool
+      org.javascool.gui.Desktop.getInstance().openFile(toURL(location.substring(editorPrefix.length())));
+    } else if(location.startsWith(newtabPrefix)) {    // Affichage dans browser JavaScool
+      URL url = toURL(location.substring(newtabPrefix.length()));
+      String name = new File(url.getPath()).getName().replaceFirst("\\.[^\\.]*$", "").replace('_', '.');
+      org.javascool.gui.Desktop.getInstance().openBrowserTab(url.toString(), name.substring(0, 1).toUpperCase()+name.substring(1));
+    } else if(location.matches("^(http|https|rtsp|mailto):.*$")) {    // Gestion des URL externes
+      browse(location);
+    } else if(location.matches(".*\\.htm$") || location.matches("^#.*")) {   // Gestion des URLs en HTML3 et des ancres
+      update(toURL(location), push);
+    } else if(!doBrowse(location))     // Délégation au client
+      setText("Le lien : <tt>«" + location + "»</tt> n'a pas pu être affiché");
+  }
+  private void update(URL url, boolean push) {
+    if(push)
+      urls.push(url);
+    pane.getDocument().putProperty(Document.StreamDescriptionProperty, null);
+    
+    try {
+      pane.setPage(url);
+    } catch(IOException e) {
+      setText("Le lien : <tt>«" + url + "»</tt> génère une erreur \"" + e.toString() + "\"");
+    }
+    updateButtons();
+  }
+  private void update(Object link, boolean push) {
+    if(link instanceof URL)
+      update((URL) link, push);
+    else
+      update(link.toString(), push);
+  }
+  private URL toURL(String location) {
+    try {
+      return urls.isEmpty() ? Macros.getResourceURL(location) :
+	urls.getCurrent() instanceof URL ? new URL((URL) urls.getCurrent(), location) :
+	new URL(location);
+    } catch(MalformedURLException e) {
+      try {
+      return new URL(stringPrefix+"Le lien : <tt>«" + location + "»</tt> est mal formé");
+      } catch(MalformedURLException ex) {
+          throw new IllegalStateException(ex);
+      }
+    }
+  }
+}
+
Index: src/org/javascool/widgets/StartStopButton.java
===================================================================
--- src/org/javascool/widgets/StartStopButton.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/StartStopButton.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,91 @@
+package org.javascool.widgets;
+
+import javax.swing.JPanel;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import org.javascool.macros.Macros;
+
+/** Définit un bouton de start/stop avec affichage du temps de calcul.
+ *
+ * @author Philippe Vienne
+ * @see <a href="StartStopButton.java.html">code source</a>
+ * @serial exclude
+ */
+public abstract class StartStopButton extends JPanel {
+  private static final long serialVersionUID = 1L;
+  /** Le bouton de start/stop .*/
+  private JButton startButton;
+  /** L'affichage du temps d'exécution. */
+  private JLabel execTime;
+
+  // @bean
+  public StartStopButton() {
+    this.setOpaque(false);
+    add(startButton = new JButton("Arrêter"));
+    startButton.addActionListener(new ActionListener() {
+                                    @Override
+                                    public void actionPerformed(ActionEvent e) {
+                                      new Thread(new Runnable() {
+                                                   public void run() {
+                                                     if(isStarting())
+                                                       doStop();
+                                                     else
+                                                       doStart();
+                                                   }
+                                                 }
+                                                 ).start();
+                                    }
+                                  }
+                                  );
+    add(execTime = new JLabel("  Temps d'exécution : 0 min 0 sec"));
+    doStop();
+  }
+  /** Lancement du programme et du compteur. */
+  private void doStart() {
+    if(isRunning())
+      stop();
+    execTime.setText("  Temps d'exécution : 0 min 0 sec");
+    startButton.setText("Arrêter");
+    startButton.setIcon(Macros.getIcon("org/javascool/widgets/icons/stop.png"));
+    revalidate();
+    new Thread(new Runnable() {
+                 @Override
+                 public void run() {
+                   for(int t = 0; isRunning(); t++) {
+                     execTime.setText("  Temps d'exécution : " + t / 60 + " min " + t % 60 + " sec");
+                     execTime.revalidate();
+                     Macros.sleep(1000);
+                   }
+                   doStop();
+                 }
+               }
+               ).start();
+    start();
+  }
+  /** Indique que l'interface à affiché le lancement. */
+  private boolean isStarting() {
+    return "Arrêter".equals(startButton.getText());
+  }
+  /** Arrêt du programme et du compteur. */
+  private void doStop() {
+    if(isRunning())
+      stop();
+    startButton.setText("Exécuter");
+    startButton.setIcon(Macros.getIcon("org/javascool/widgets/icons/play.png"));
+    revalidate();
+  }
+  /** Cette méthode est appelée au lancement demandé par l'utilisateur. */
+  abstract public void start();
+
+  /** Cette méthode est appelée à l'arrêt demandé par l'utilisateur. */
+  abstract public void stop();
+
+  /** Cette méthode est appellée par le compteur pour déterminer si le programme est terminé.
+   * <p>Par défaut l'indicateur est celui de l'appel à la méthode <tt>stop</tt>.</p>
+   */
+  public boolean isRunning() {
+    return isStarting();
+  }
+}
Index: src/org/javascool/widgets/icons/erase.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/erase.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/error.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/error.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/scripts.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/scripts.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo32.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo32.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/open.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/open.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/saveas.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/saveas.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo16.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo16.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/compile.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/compile.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/next.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/next.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/prev.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/prev.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/play.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/play.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo-builder.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo-builder.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/refresh.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/refresh.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/save.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/save.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/new.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/new.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/stop.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/stop.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/remove.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/remove.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/MainFrame.java
===================================================================
--- src/org/javascool/widgets/MainFrame.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/MainFrame.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,181 @@
+package org.javascool.widgets;
+
+// Used to set Win look and feel
+import javax.swing.UIManager.LookAndFeelInfo;
+import javax.swing.UIManager;
+
+import javax.swing.JFrame;
+import javax.swing.JRootPane;
+import java.applet.Applet;
+import java.awt.Component;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import javax.swing.ImageIcon;
+import org.javascool.macros.Macros;
+
+/** Définit une fenêtre principale pour lancer une application. */
+public class MainFrame extends JFrame {
+  private Component pane;
+  // @bean
+  public MainFrame() {}
+
+  /** Compte des fenêtres ouvertes pour gérer le exit. */
+  private static int frameCount = 0;
+
+  /** Définit le look and feel de l'application. */
+  static void setLookAndFeel() {
+    try {
+      for(LookAndFeelInfo info : UIManager.getInstalledLookAndFeels())
+        if("Nimbus".equals(info.getName())) {
+          UIManager.setLookAndFeel(info.getClassName());
+          break;
+        }
+    } catch(Exception e1) {
+      String os = System.getProperty("os.name");
+      if(os.startsWith("Windows")) {
+        try {
+          UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
+        } catch(Exception e2) {}
+      } else {
+        try {
+          UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        } catch(Exception e2) {
+          System.err.println("Note: Utilisaton du thème Java (et non du système)");
+        }
+      }
+    }
+  }
+  static {
+    setLookAndFeel();
+  }
+
+  /** Construit la fenêtre sans boutons de fermeture.
+   * <p>- Doit être appelé avant la méethode reset.</p>
+   * @return Cet objet, permettant de définir la construction <tt>new MainFrame().asPopup().reset(..)</tt>.
+   */
+  public MainFrame asPopup() {
+    // @todo voir sur mac si ca solde le pb du close intempestif
+    if (System.getProperty("os.name").toLowerCase().indexOf("mac") >= 0) {
+      setUndecorated(true);  
+      getRootPane().setWindowDecorationStyle(JRootPane.NONE);
+    } else if (System.getProperty("os.name").toLowerCase().indexOf("win") >= 0){
+      // Si besoin de faire qq chose sous windows
+    }
+    return this;
+  }
+
+  /** Construit et ouvre une fenêtre principale pour lancer une application.
+   * @param title Le titre de la fenêtre.
+   * @param icon L'icône de la fenêtre.
+   * @param width Largeur de la fenêtre. Si 0 on prend tout l'écran.
+   * @param height Hauteur de la fenêtre. Si 0 on prend tout l'écran.
+   * @param pane Le composant graphique à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new MainFrame().reset(..)</tt>.
+   */
+  public MainFrame reset(String title, String icon, int width, int height, Component pane) {
+    if (title != null)
+      setTitle(title);
+    if(System.getProperty("os.name").toUpperCase().contains("MAC")) {
+      try {
+        System.setProperty("com.apple.mrj.application.apple.menu.about.name", title);
+      } catch(Exception e2) {}
+    }
+    if (icon != null) {
+      ImageIcon image = Macros.getIcon(icon);
+      if(image != null)
+        setIconImage(image.getImage());
+      }
+    add(this.pane = pane);
+    if(pane instanceof Applet)
+      ((Applet) pane).init();
+    setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
+    addWindowListener(new WindowAdapter() {
+                        @Override
+                        public void windowClosing(WindowEvent e) {
+                            close();
+                        }
+                      }
+                      );
+    pack();
+    if((width > 0) && (height > 0))
+      setSize(width, height);
+    else
+      setExtendedState(JFrame.MAXIMIZED_BOTH);
+    setVisible(true);
+    if(pane instanceof Applet)
+      ((Applet) pane).start();
+    if(firstFrame == null)
+      firstFrame = this;
+    frameCount++;
+    return this;
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, int width, int height, Component pane) {
+    return reset(title, null, width, height, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, String icon, Component pane) {
+    return reset(title, icon, 0, 0, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, Component pane) {
+    return reset(title, null, 0, 0, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(int width, int height, Component pane) {
+    return reset(pane.getClass().toString(), null, width, height, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(Component pane) {
+    return reset(pane.getClass().toString(), null, 0, 0, pane);
+  }
+  /** Ferme la fenêtre principale à partir du programme.
+   * @param force Si true ferme la fenêter même si isClosable() renvoie false.
+   */
+  public void close(boolean force) {
+                          if(force || isClosable()) {
+                            if(MainFrame.this.pane instanceof Applet) {
+			      try {
+				((Applet) MainFrame.this.pane).stop();
+			      } catch (Throwable e1) { }
+			      try {
+				((Applet) MainFrame.this.pane).destroy();
+			      } catch (Throwable e2) { }
+                            }
+                            setVisible(false);
+                            dispose();
+                            frameCount--;
+                            if(frameCount == 0)
+                              System.exit(0);
+                          }
+  }
+  /**
+   * @see #close(boolean)
+   */
+  public void close() {
+      close(false);
+  }
+  /** Détermine si la fenêtre principale peut-être fermée.
+   * @return La valeur true si la fenêtre principale peut-être fermée, sinon false.
+   */
+  public boolean isClosable() {
+    return true;
+  }
+  /** Renvoie la frame principale ouverte.
+   * @return La frame principale ouverte comme parent des dialogues modaux.
+   */
+  public static JFrame getFrame() {
+    return firstFrame;
+  }
+  private static JFrame firstFrame = null;
+}
Index: src/org/javascool/widgets/TabbedPane.java
===================================================================
--- src/org/javascool/widgets/TabbedPane.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/TabbedPane.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,267 @@
+package org.javascool.widgets;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Cursor;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.ImageIcon;
+import javax.swing.JComponent;
+import javax.swing.JPanel;
+import javax.swing.JTabbedPane;
+
+import org.javascool.macros.Macros;
+
+/** Cre un JTabbedPane avec des onglets pouvant possder une croix.
+ * Cette classe a fonctionne comme un {@link JTabbedPane} mais lorsque un JComponent avec une proprit
+ * TAB_CLOSABLE  true alors il a une croix. Pour viter que de mauvaises proprits soit assign, une
+ * fonction static fait en sorte que le JComponent arborde une croix.
+ * Afin de vrifier si un onglet peut tre fermer, il vous faut faire un "overide" de la fonction 
+ * isTabClosable.
+ */
+public class TabbedPane extends JTabbedPane{
+
+	private static final long serialVersionUID = 2304963236664505495L;
+
+	/** ClientProperty pour un composant fermable. */
+	public static final String TAB_CLOSABLE="tab_closable";
+
+	/** L'UI destin  peindre les croix */
+	private TabCloseUI closeUI = new TabCloseUI(this);
+
+	/** Vrifie si le composant possde une croix pour la fermeture.
+	 * @param component Le composant  vrifier
+	 * @return True si il faut afficher la croix, false sinon.
+	 */
+	private static boolean isComponentClosable(Component component){
+		if(component instanceof JComponent)
+			if(((JComponent) component).getClientProperty(TAB_CLOSABLE)==Boolean.TRUE)
+				return true;
+		return false;
+	}
+
+	/** Paramtre un composant pour qu'il puisse avoir une croix de fermeture
+	 * @param component Le composant  configurer
+	 */
+	public static void setComponentClosable(JComponent component){
+		component.putClientProperty(TAB_CLOSABLE,Boolean.TRUE);
+	}
+
+	/** Ajout de la fonction de tracage des croix dans paint.
+	 */
+	public void paint(Graphics g){
+		super.paint(g);
+		closeUI.paint(g);
+	}
+
+	/**
+	 * @see JTabbedPane
+	 */
+	public void addTab(String title, Component component) {
+		if(isComponentClosable(component))
+			super.addTab(title+"    ", component);
+		else
+			super.addTab(title, component);
+	}
+
+	/**
+	 * @see JTabbedPane
+	 */
+	public void setTitleAt(int index, String title){
+		if(isComponentClosable(getComponentAt(index))&&getTabCount()>1)
+			title=title+"    ";
+		super.setTitleAt(index, title);
+	}
+
+	/** Retourne le nom du composant sans les espaces ncessaire  la croix. */
+	public String getTabTitleAt(int index) {
+		return super.getTitleAt(index).trim();
+	}
+
+	private class TabCloseUI implements MouseListener, MouseMotionListener {
+		private TabbedPane  tabbedPane;
+		private int closeX = 2 ,closeY = 2, meX = 0, meY = 0;
+		private int selectedTab;
+		private final int  width = 7, height = 7;
+		private Rectangle rectangle = new Rectangle(0,0,width, height);
+		public TabCloseUI(TabbedPane pane) {
+
+			tabbedPane = pane;
+			tabbedPane.addMouseMotionListener(this);
+			tabbedPane.addMouseListener(this);
+		}
+		public void mouseEntered(MouseEvent me) {}
+		public void mouseExited(MouseEvent me) {}
+		public void mousePressed(MouseEvent me) {}
+		public void mouseClicked(MouseEvent me) {}
+		public void mouseDragged(MouseEvent me) {}
+
+
+
+		public void mouseReleased(MouseEvent me) {
+			if(closeUnderMouse(me.getX(), me.getY())){
+				boolean isToCloseTab = isTabClosable(selectedTab);
+				if (isToCloseTab && selectedTab > -1){			
+					tabbedPane.removeTabAt(selectedTab);
+				}
+				selectedTab = tabbedPane.getSelectedIndex();
+			}
+		}
+
+		public void mouseMoved(MouseEvent me) {	
+			meX = me.getX();
+			meY = me.getY();			
+			if(mouseOverTab(meX, meY)){
+				controlCursor();
+				tabbedPane.repaint();
+			}
+		}
+
+		private void controlCursor() {
+			if(tabbedPane.getTabCount()>0)
+				if(closeUnderMouse(meX, meY)){
+					tabbedPane.setCursor(new Cursor(Cursor.HAND_CURSOR));
+				}
+				else{
+					tabbedPane.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
+				}	
+		}
+
+		private boolean closeUnderMouse(int x, int y) {		
+			rectangle.x = closeX;
+			rectangle.y = closeY;
+			return rectangle.contains(x,y);
+		}
+
+		public void paint(Graphics g) {
+
+			int tabCount = tabbedPane.getTabCount();
+			for(int j = 0; j < tabCount; j++)
+				if(isComponentClosable(getComponentAt(j))){			
+					int x = tabbedPane.getBoundsAt(j).x + tabbedPane.getBoundsAt(j).width -width-6;
+					int y = tabbedPane.getBoundsAt(j).y +7;
+					if(tabCount>1){
+						setTitleAt(j, getTabTitleAt(j));
+						drawClose(g,x,y);
+					} else {
+						setTitleAt(j, getTabTitleAt(j));
+					}
+				}
+		}
+
+		private void drawClose(Graphics g, int x, int y) {
+			if(tabbedPane != null && tabbedPane.getTabCount() > 0){
+				Graphics2D g2 = (Graphics2D)g;				
+				drawColored(g2, isUnderMouse(x,y)? Color.RED : Color.WHITE, x, y);
+			}
+		}
+
+		private void drawColored(Graphics2D g2, Color color, int x, int y) {
+			g2.setStroke(new BasicStroke(4));
+			g2.setColor(Color.BLACK);
+			g2.drawLine(x, y, x + width, y + height);
+			g2.drawLine(x + width, y, x, y + height);
+			g2.setColor(color);
+			g2.setStroke(new BasicStroke(2));
+			g2.drawLine(x, y, x + width, y + height);
+			g2.drawLine(x + width, y, x, y + height);
+
+		}
+
+		private boolean isUnderMouse(int x, int y) {
+			if(Math.abs(x-meX)<width && Math.abs(y-meY)<height )
+				return  true;		
+			return  false;
+		}
+
+		private boolean mouseOverTab(int x, int y) {
+			int tabCount = tabbedPane.getTabCount();
+			for(int j = 0; j < tabCount; j++)
+				if(tabbedPane.getBoundsAt(j).contains(meX, meY)&&(isComponentClosable(getComponentAt(j)))){
+					selectedTab = j;
+					closeX = tabbedPane.getBoundsAt(j).x + tabbedPane.getBoundsAt(j).width -width-6;
+					closeY = tabbedPane.getBoundsAt(j).y +7;					
+					return true;
+				}
+			return false;
+		}
+
+	}
+	
+	/** Add a tab with a JPanel
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The JPanel to show into the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, JPanel panel) {
+		return this.add(name, icon, panel, null);
+	}
+	/** Add a tab with an Applet
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The Applet to show into the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, Component panel) {
+		if(!icon.equalsIgnoreCase("")) {
+			ImageIcon logo = Macros.getIcon(icon);
+			this.addTab(name, logo, panel);
+		} else
+			this.addTab(name, null, panel);
+		this.revalidate();
+		return name;
+	}
+	/** Add a tab with a JPanel
+	 * @param name The tab name
+	 * @param icon The link to the icon, can be an empty String
+	 * @param panel The JPanel to show into the tab
+	 * @param tooltip An tooltip for the tab
+	 * @return The new id of your tab
+	 */
+	public String add(String name, String icon, JPanel panel, String tooltip) {
+		if(!icon.equalsIgnoreCase("")) {
+			ImageIcon logo = Macros.getIcon(icon);
+			this.addTab(name, logo, panel, tooltip);
+		} else
+			this.addTab(name, null, panel, tooltip);
+		this.revalidate();
+		return name;
+	}
+	/** Get a JPanel
+	 * @param name The id of JPanel
+	 * @return The JPanel
+	 */
+	public JPanel getPanel(String name) {
+		if(getComponentAt(indexOfTab(name)) instanceof JPanel)
+			return (JPanel) getComponentAt(indexOfTab(name));
+		return null;
+	}
+	/** Delete a tab
+	 * @param name The tab id
+	 */
+	public void del(String name) {
+		this.removeTabAt(this.indexOfTab(name));
+	}
+	/** Switch to a tab
+	 * @param name The id of the tab
+	 */
+	public void switchToTab(String name) {
+		this.setSelectedIndex(this.indexOfTab(name));
+	}
+
+	/** Say if a tab can be closed.
+	 * By default this function return true but it can be override.
+	 * This is in add of {@link ClosableComponent}.isClosable()
+	 */
+	public boolean isTabClosable(int tabIndex) {
+		return true;
+	}
+
+
+}
Index: src/org/javascool/widgets/NumberInput.java
===================================================================
--- src/org/javascool/widgets/NumberInput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/NumberInput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,123 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Dimension;
+import javax.swing.BorderFactory;
+
+// Used for the text field
+import javax.swing.JTextField;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+// Used for the slider
+import javax.swing.JSlider;
+import java.awt.Font;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+
+/** Panneau pour l'entrée de valeurs numériques.
+ * @see <a href="NumberInput.java.html">source code</a>
+ * @serial exclude
+ */
+public class NumberInput extends JPanel {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public NumberInput() {
+    setPreferredSize(new Dimension(400, 62));
+    field = new JTextField(12);
+    field.addActionListener(new ActionListener() {
+                              @Override
+                              public void actionPerformed(ActionEvent evt) {
+                                try { set(new Double(field.getText()).doubleValue(), 'T');
+                                } catch(NumberFormatException e) {}
+                              }
+                            }
+                            );
+    add(field);
+    slider = new JSlider();
+    slider.setFont(new Font("Dialog", Font.PLAIN, 0));
+    slider.addMouseListener(new MouseListener() {
+                              @Override
+                              public void mouseClicked(MouseEvent e) {}
+                              @Override
+                              public void mouseEntered(MouseEvent e) {}
+                              @Override
+                              public void mouseExited(MouseEvent e) {}
+                              @Override
+                              public void mousePressed(MouseEvent e) {}
+                              @Override
+                              public void mouseReleased(MouseEvent e) {
+                                set((NumberInput.this.max - NumberInput.this.min) / 100.0 * slider.getValue() + NumberInput.this.min, 'S');
+                              }
+                            }
+                            );
+    add(slider);
+    setText("");
+    setScale(0, 100, 1);
+    setValue(0);
+  }
+  private JTextField field;
+  private JSlider slider;
+  // Display the value
+  private void set(double value, char from) {
+    // Retrain value to be step by step and in the min-max interval
+    value = step <= 0 ? value : min + step *Math.rint((value - min) / step);
+    value = value<min ? min : value> max ? max : value;
+    this.value = value;
+    field.setText(new Double(value).toString().replaceFirst("(99999|00000).*$", "").replaceFirst(".0$", ""));
+    if(from != 'S')
+      slider.setValue((int) ((max > min) ? 100.0 * (value - min) / (max - min) : value));
+    if((from != ' ') && (runnable != null))
+      runnable.run();
+  }
+  /** Définit le nom de la valeur numérique.
+   * @param name Nom du paramètre.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
+   */
+  public final NumberInput setText(String name) {
+    setBorder(BorderFactory.createTitledBorder(name));
+    return this;
+  }
+  /** Définit le nom et les paramètres de la valeur numérique.
+   * @param min Valeur minimale à entrer. 0 par défaut.
+   * @param max Valeur maximale à entrer. 100 par défaut.
+   * @param step Précision de la valeur à entrer. 1 par défaut.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
+   */
+  public final NumberInput setScale(double min, double max, double step) {
+    this.min = min;
+    this.max = max;
+    this.step = step;
+    return this;
+  }
+  /**
+   * @see #setScale(double, double, double)
+   */
+  public final NumberInput setScale() {
+    return setScale(0, 100, 1);
+  }
+  /** Renvoie la valeur numérique. */
+  public double getValue() {
+    return value;
+  }
+  /** Définit la valeur numérique. */
+  public void setValue(double value) {
+    set(value, ' ');
+  }
+  /** Définit une portion de code appellée à chaque modification de la valeur.
+   * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setRunnable(..)</tt>.
+   */
+  public NumberInput setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+  private Runnable runnable = null;
+
+  private double min, max, step, value;
+}
Index: src/org/javascool/Build.java
===================================================================
--- src/org/javascool/Build.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/Build.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,51 @@
+package org.javascool;
+
+import java.io.File;
+import java.io.IOException;
+import org.javascool.builder.ProgletsBuilder;
+import org.javascool.tools.ErrorCatcher;
+import org.javascool.tools.Pml;
+
+/** Lanceur de l'application "formateur" qui permet de construire des «proglets».
+ *
+ * @see <a href="Build.java.html">code source</a>
+ * @serial exclude
+ */
+public class Build {
+
+    /** Logo de l'application. */
+    public static final String logo = "org/javascool/widgets/icons/logo-builder.png";
+
+    /** Lanceur de la conversion Jvs en Java.
+     * @param usage <tt>java org.javascool.Build  [-q [targetDir]]</tt>
+     */
+    public static void main(String[] usage) {
+        Pml args = new Pml().reset(usage);
+        ErrorCatcher.checkJavaVersion(6);
+        Core.setUncaughtExceptionAlert();
+        ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
+        if (args.getBoolean("h") || args.getBoolean("help")) {
+            System.out.println("Java's Cool Builder - Construit un jar avec les proglets souhaitées");
+            System.out.println("Usage : java -jar javascool-builder.jar [-q] [-w] [-v] [-target target-dir] [-proglets proglet-list]");
+            System.out.println("Options : ");
+            System.out.println("\t-q\tPermet de lancer l'application en console sur toutes les proglets disponibles et sans interface graphique.");
+            System.out.println("\t-w\tPermet de lancer l'application en console et génère les fichiers javadoc et jars des proglets.");
+            System.out.println("\t-v\tPermet de lancer l'application en mode verbose, toute les étapes sont affiché.");
+            System.out.println("\t-target target-dir\tLe répertoire cible dans lequel la construction se fait (c'est le répertoire temporaire .build par défaut).");
+            System.out.println("\t-proglets proglet-dir\tLes proglets à prendre en compte (elle le sont toutes part défaut).");
+      } else if (!(args.getBoolean("q") || args.getBoolean("w"))) {
+	org.javascool.builder.DialogFrame.startFrame();
+      } else {
+       try {
+	if (args.isDefined("target") && new File(".").getCanonicalPath().equals(new File(args.getString("target")).getCanonicalPath()))
+	  throw new IllegalArgumentException("Le répertoire du sketchbook et celui du build ne peuvent pas être identiques !!!");
+          } catch(IOException e) {
+           throw new IllegalArgumentException("Le répertoire du build n'est pas utilisable.");
+          }
+	ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
+        String target = args.isDefined("target") ? args.getString("target") : null;
+        String names[] = args.isDefined("proglets") ? args.getString("proglets").trim().split("[, \t]+") : null;
+	System.exit(ProgletsBuilder.build(ProgletsBuilder.getProglets(names), target, args.getBoolean("w")) ? 0 : -1);
+      }
+    }
+}
Index: src/org/javascool/tools/Sampler.java
===================================================================
--- src/org/javascool/tools/Sampler.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Sampler.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,122 @@
+/**************************************************************************
+*   vthierry@sophia.inria.fr, Copyright (C) 2004.  All rights reserved.   *
+**************************************************************************/
+
+package org.javascool.tools;
+
+// Used to catch exceptions
+import java.lang.RuntimeException;
+
+// Used for thread management
+import java.lang.Thread;
+import java.lang.Runnable;
+
+// Used for timer management
+import java.lang.System;
+import java.lang.InterruptedException;
+
+/** Defines the implementation of a periodic task.
+ * 
+ * <div>The periodic task is: <ul>
+ * <li><b>defined</b> by a runnable called at each iteration, and one parameter the <b><i>sampling-period</i></b>.</li>
+ * <li><b>controlled</b> by the start/stop method
+ *
+ * <li><a href="#start(int)">start()</a> (re)starting the iteration.
+ *  <div>User can overwrite the method with a construct of the form <tt>public void start() { &lt;specific-code> super.start(); }</tt></div></li>
+ *
+ * <li><a href="#stop()">stop()</a> which stops the iteration.
+ *  <div>User can overwrite the method with a construct of the form <tt>public void stop() { super.stop(); &lt;specific-code> }</tt></div></li>
+ *
+ * </ul></div>
+ *
+ */
+public class Sampler {
+  private Runnable runnable;
+  private int delay;
+
+  // @bean
+  public Sampler() { }
+ 
+  /** Sets the periodic task runnable.
+   * @param runnable The runnable to call periodically.
+   * @return this
+   */
+  public Sampler setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+
+  /** Sets the periodic task sampling-period.
+   * @param delay The periodic task delay in milli-seconds.
+   * @return this
+   */
+  public Sampler setDelay(int delay) {
+    this.delay = delay;
+    return this;
+  }
+
+  /** (Re)starts the sampling of the runnable.  */
+  public void start() {
+    error = null;
+    (thread = new Thread(new Runnable() {
+	// Loop with a time-period of samplingPeriod
+	public void run() {
+	  try {
+	    for (loop = resume = true; loop;) {
+	      long t = System.currentTimeMillis(); Thread.yield();
+	      if (resume) runnable.run();
+	      spareTime = delay - (int) (System.currentTimeMillis()-t);
+	      if (spareTime > 0) { try { Thread.sleep(spareTime); } catch(InterruptedException e) { } }
+	    }
+	  } catch(Throwable e) {
+	    error = e; 
+	  }
+	  loop = resume = false;
+	}
+      })).start();
+  }
+  // This flag is true during sampling loop
+  private boolean loop = false, resume = false;
+
+  /** Returns the iteraton thread.
+   * @return The thread with the periodic sampling or null if not running.
+   */
+  public Thread getThread() { return thread; }
+  private Thread thread = null;
+  
+  /** Pauses the iteration mechanism. 
+   */
+  public void pause() { resume = false; }
+
+  /** Resumes the iteration after a pause.
+   */
+  public void resume() { resume = true; }
+
+  /** Tests if the iteration is paused
+   * @return True if the iteration has been paused via <tt>pause()</tt> false if the iteration has been resumed via <tt>resumed()</tt> or never paused.
+   */
+  public boolean isPaused() { return !resume; }
+
+  /** Returns the runtime-exception thrown by the iteration runnable.
+   * @return The runtime-exception thrown by the iteration runnable if any, else null.
+   */
+  public Throwable getThrowable() {
+    return error;
+  }
+  private Throwable error = null;
+
+  /** Requires the sampling to stop.
+   * <div>The current iteration, if any, terminates before stopping.</div>
+   */
+  public void stop() { loop = resume = false; thread = null; }
+
+  /** Returns the spare-time between two samplings.
+   *
+   * @return The last spare-time between two samplings, in milliseconds: <ul>
+   *  <li> If negative, it indicates that the task overruns.</li> 
+   *  <li> It is equal to Integer.MIN_VALUE if no iteration has been completed. </li> 
+   *  <li> It depends on both the task execution time and other thread execution times.</li>
+   * </ul> 
+   */
+  public int getSpareTime() { return spareTime; } private int spareTime = -Integer.MIN_VALUE;
+}
Index: src/org/javascool/tools/Xml2Xml.java
===================================================================
--- src/org/javascool/tools/Xml2Xml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Xml2Xml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,147 @@
+/*******************************************************************************
+* They.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.tools;
+
+import java.util.HashMap;
+
+// Used for the sax interface
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Properties;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.transform.stream.StreamResult;
+
+/** Transforme une structure XML en une autre structure XML avec un XSLT.
+ *
+ * <p>Note: utilise <tt>saxon.jar</tt> qui doit être dans le CLASSPATH.</p>
+ * @see <a href="Xml2Xml.java.html">code source</a>
+ * @serial exclude
+ */
+public class Xml2Xml {
+  // @factory
+  private Xml2Xml() {}
+
+  /** Convertit une chaîne XML en une autre chaîne XML selon des règles XSL.
+   * @param xml Le nom de fichier ou la chaîne XML en entrée.
+   * @param xsl Le nom de fichier ou la chaîne avec les règles de transformation XSL.
+   * <p> - Si la chaîne commence par un <tt>&lt;</tt> elle est reconnue comme un texte XSLT.</p>
+   * <p> - Sinon elle est reconnue comme un non de fichier.</p>
+   * @param params Paramètres de la transformation. La valeur null indique qu'il n'y a pas de paramètres.
+   *
+   * @return La chaîne en sortie.
+   *
+   * @throws IllegalArgumentException Si une erreur de syntaxe est détecté.
+   * @throws RuntimeException  Si une erreur d'entrée-sortie s'est produite.
+   */
+  public static String run(String xml, String xsl, Properties params) {
+    // Compile la tranformation XSLT dans le cache des XSLT
+    try {
+      if(!tranformers.containsKey(xsl)) {
+        StreamSource xslSource = null;
+        if(xsl.trim().startsWith("<"))
+          xslSource = new StreamSource(new StringReader(xsl));
+        else {
+          xslSource = new StreamSource(xsl);
+          xslSource.setSystemId(xsl);
+        }
+        tranformers.put(xsl, tfactory.newTransformer(xslSource));
+      }
+    } catch(TransformerConfigurationException e) { 
+      throw new RuntimeException(e + " when compiling: " + xsl);
+    }
+    // Applique la transformation
+    try {
+      if(xml == null)
+        xml = "<null/>";
+      StringWriter writer = new StringWriter();
+      Transformer transformer = tranformers.get(xsl);
+      // Ajoute les paramètres de la transformation, si définis
+      {
+        transformer.clearParameters();
+        if(params != null)
+          for(String name : params.stringPropertyNames())
+            transformer.setParameter(name, params.getProperty(name));
+      }
+      StreamSource in = xml.trim().startsWith("<") ? new StreamSource(new StringReader(xml)) : new StreamSource(xml);
+      transformer.transform(in, new StreamResult(writer));
+      return writer.toString();
+    } catch(TransformerException e) { throw new IllegalArgumentException(e.getMessageAndLocation());
+    }
+  }
+  /**
+   * @see #run(String, String, Properties)
+   */
+  public static String run(String xml, String xsl) {
+    return run(xml, xsl, null);
+  }
+  /**
+   * @see #run(String, String, Properties)
+   */
+  public static String run(String xml, String xsl, String paramName, String paramValue) {
+    Properties params = new Properties();
+    params.setProperty(paramName, paramValue);
+    return run(xml, xsl, params);
+  }
+  // Cash mechanism
+  private static TransformerFactory tfactory;
+  private static HashMap<String, Transformer> tranformers = new HashMap<String, Transformer>();
+  static {
+    try {
+      System.setProperty("javax.xml.parsers.SAXParserFactory", "com.icl.saxon.aelfred.SAXParserFactoryImpl");
+      System.setProperty("javax.xml.transform.TransformerFactory", "com.icl.saxon.TransformerFactoryImpl");
+      System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.icl.saxon.om.DocumentBuilderFactoryImpl");
+      tfactory = TransformerFactory.newInstance();
+    } catch(Throwable e) {
+      System.err.println("Configuration error: " + e);
+    }
+  }
+
+  /** Convertit une chaîne en HTML en chaîne XHTML.
+   * <p>Elimine les entitées HTML connues (tout n'est pas implémenté) et passe à de l'accentuation liée au codage local,
+   * élimine les constructions (commentaires, instructions) qui ne sont pas structures logiques XML et
+   * ferme les balises pur avoir une syntaxe bien formée.</p>
+   * <p>C'est une commande "fragile" au sens où un text HTML mal formé ne sera pas correctement traduit.</p>
+   * @param htm La chaîne HTML en entrée.
+   * @return La chaîne XML en sortie.
+   */
+  public static String html2xhtml(String htm) {
+    return htm. // Elimine les accentuation HTML
+           replaceAll("&agrave;", "à").
+           replaceAll("&acirc;", "â").
+           replaceAll("&eacute;", "é").
+           replaceAll("&egrave;", "è").
+           replaceAll("&euml;", "ë").
+           replaceAll("&ecirc;", "ê").
+           replaceAll("&iuml;", "ï").
+           replaceAll("&icirc;", "î").
+           replaceAll("&ouml;", "ö").
+           replaceAll("&ocirc;", "ô").
+           replaceAll("&ldquo;", "&#8220;").
+           replaceAll("&rdquo;", "&#8221;").
+           replaceAll("&laquo;", "&#171;").
+           replaceAll("&raquo;", "&#172;;").
+           replaceAll("&ugrave;", "ù").
+           replaceAll("&ccedil;", "ç").
+           // Eliminate les constructions étranges
+           replaceAll("<[!?][^>]*>", "").
+           replaceAll("&nbsp;", "&#160;").
+           // Encapsule les constructions non XML
+           replaceAll("(<(meta|img|hr|br|link)[^>/]*)/?>", "$1/>");
+  }
+  /** Lanceur de la transformation XML -XSLT-> XML.
+   * @param usage <tt>java org.javascool.tools.Xml2Xml input-file XSL-file [output-file] [paramName paramValue]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length == 5)
+      FileManager.save(usage[2], run(FileManager.load(usage[0]), usage[1], usage[3], usage[4]));
+    else if(usage.length > 1)
+      FileManager.save(usage.length > 2 ? usage[2] : "stdout:", run(FileManager.load(usage[0]), usage[1]));
+  }
+}
Index: src/org/javascool/tools/ErrorCatcher.java
===================================================================
--- src/org/javascool/tools/ErrorCatcher.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/ErrorCatcher.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,97 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.tools;
+
+// Used to report a throwable
+
+// Used to frame a message
+import java.net.URLEncoder;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import org.javascool.macros.Macros;
+
+/** Détecte et rapporte de manière optimisée des erreurs lors de l'exécution.
+ *
+ * @see <a href="ErrorCatcher.java.html">code source</a>
+ * @serial exclude
+ */
+public class ErrorCatcher {
+  // @factory
+  private ErrorCatcher() {}
+
+  /** Ouvre une fenêtre d'alerte en cas d'exception intempestive et non prise en compte.
+   * <p> Installe un gestionnaire d'exception non interceptée qui recueille des informations sur:
+   * les versions des composants logiciels, le nom du process, la trace de la pile et
+   * l'affiche dans une fenêtre séparée afin d'être recueillies et communiquées par l'utilisateur.</p>
+   * @param header Un texte entête en HTML expliquant à l'utilisateur quoi faire avec cette sortie d'exception.
+   * @param revision Nom et/ou numéro de révision de l'application pour avoir une trace en cas d'erreur.
+   * @param keyword Si différent de null, le message n'est donné à l'utilisateur que si la trace de la pile contient le mot-clé (<tt>org.javascool</tt> par défaut)
+   */
+  public static void setUncaughtExceptionAlert(String header, String revision, String keyword) {
+    uncaughtExceptionAlertHeader = header;
+    uncaughtExceptionKeyword = keyword;
+    System.setProperty("application.revision", "" + revision);
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+                                                @Override
+                                                public void uncaughtException(Thread t, Throwable e) {
+                                                  String s = "", r = "";
+                                                  if(uncaughtExceptionAlertOnce <= 1) {
+                                                    s += uncaughtExceptionAlertHeader + "\n<hr><pre>";
+                                                    for(String p: new String[] { "application.revision", "java.version", "java.home", "os.name", "os.arch", "os.version", "user.name", "user.home", "user.dir" }
+                                                        )
+                                                      s += "> " + p + " = " + System.getProperty(p) + "\n";
+                                                  }
+                                                  try {
+                                                    s += "> localhost = "+ java.net.InetAddress.getLocalHost() + "\n";
+                                                  } catch(Exception er) {}
+                                                  s += "> thread.name = " + t.getName() + "\n";
+                                                  s += "> throwable = " + e + "\n";
+                                                  if(0 < uncaughtExceptionAlertOnce)
+                                                    s += "> count = " + uncaughtExceptionAlertOnce + "\n";
+                                                  s += "> stack-trace = «\n";
+                                                  for(int i = 0; i < t.getStackTrace().length; i++)
+                                                    r += e.getStackTrace()[i] + (i < t.getStackTrace().length - 1 ? "\n" : "»");
+                                                  boolean alert = uncaughtExceptionAlertOnce == 0 && 
+						    (uncaughtExceptionKeyword == null || r.indexOf(uncaughtExceptionKeyword) != -1) &&
+						    (e.toString().indexOf("java.util.ConcurrentModificationException") == -1);
+                                                  s += r + "</pre><hr>";
+						  System.err.println(s);
+                                                  try {
+                                                    s += FileManager.load("http://javascool.gforge.inria.fr?weberroreport="+URLEncoder.encode(s, "utf-8"));
+                                                  } catch(Exception er) {
+                                                    System.err.println("Impossible de lancer l'alerte à travers le web ("+er+")");
+                                                  }
+                                                  if(alert)
+                                                    Macros.message(s, true);
+                                                  uncaughtExceptionAlertOnce++;
+                                                }
+                                              }
+                                              );
+  }
+  public static void setUncaughtExceptionAlert(String header, String revision) {
+    setUncaughtExceptionAlert(header, revision, "org.javascool");
+  }
+  private static String uncaughtExceptionAlertHeader;
+  private static int uncaughtExceptionAlertOnce = 0;
+  private static String uncaughtExceptionKeyword = null;
+
+  /** Impose une version minimale de Java.
+   * <p>Si la version n'est pas correcte, l'application s'arrête et un téléchargement est proposé.</p>
+   * @param version Version de Java 5 pour 1.5, 6 pour 1.6.
+   */
+  public static void checkJavaVersion(int version) {
+    if(new Integer(System.getProperty("java.version").substring(2, 3)) < version) {
+      if(JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(
+           new JFrame(),
+           "<html>Vous n'avez pas une version suffisante de Java<br>"
+           + "cette application requiert Java 1." + version + " ou plus.<br>"
+           + "Voulez vous être redirigé vers le site de téléchargement ?",
+           "Confirmation",
+           JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE))
+        Macros.openURL("http://www.java.com/getjava");
+      System.exit(-1);
+    }
+  }
+}
Index: src/org/javascool/tools/UserConfig.java
===================================================================
--- src/org/javascool/tools/UserConfig.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/UserConfig.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ *           Philippe.Vienne, Copyright (C) 2011.  All rights reserved.         *
+ *******************************************************************************/
+package org.javascool.tools;
+
+import java.io.File;
+import java.util.Properties;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+/** Permet de stocker des informations dans un fichier de configuration de l'utilisateur.
+ *
+ * @author Philippe Vienne
+ * @see <a href="UserConfig.java.html">code source</a>
+ * @serial exclude
+ */
+public class UserConfig {
+    // @static-instance
+
+    private UserConfig(String applicationName) {
+        this.applicationName = applicationName;
+    }
+    /** Nom de l'application. */
+    private String applicationName;
+    /** Nom du fichier de configuration. */
+    private String configFile = "configuration.xml";
+    /** Table des propriétés de l'application. */
+    private Properties properties = null;
+
+    /** Renvoie le répertoire standard où stocker les données d'une application. */
+    public String getApplicationFolder() {
+        String OS = System.getProperty("os.name").toUpperCase();
+        if (OS.contains("WIN")) {
+            return System.getenv("APPDATA") + "\\" + applicationName + "\\";
+        } else if (OS.contains("MAC")) {
+            return System.getProperty("user.home") + "/Library/Application Support/" + applicationName + "/";
+        } else if (OS.contains("NUX")) {
+            return System.getProperty("user.home") + "/." + applicationName + "/";
+        } else {
+            throw new IllegalStateException("Impossible de définir un répertoire de configuration pour l'application " + applicationName + " sous le système d'exploitation «" + OS + "»");
+        }
+    }
+
+    /** Renvoie la liste de propriétés liées à cette application. */
+    private Properties getProperties() {
+        if (properties == null) {
+            properties = new Properties();
+            try {
+                properties.loadFromXML(new FileInputStream(getApplicationFolder() + configFile));
+            } catch (Exception e) {
+                System.err.println("Dysfonctionnement lors la lecture du fichier de configuration" + e);
+            }
+        }
+        return properties;
+    }
+
+    /** Lit une propriété liée à cette application.
+     * @param name Nom de la propriété.
+     * @param value Valeur par défaut.
+     * @return La valeur de la propriété, si elle définie, sinon null.
+     */
+    public String getProperty(String name, String value) {
+        return getProperties().getProperty(name, value);
+    }
+
+    /**
+     * @see #getProperty(String, String)
+     */
+    public String getProperty(String name) {
+        return getProperty(name, null);
+    }
+
+    /** Ecrit une propriété liée à cette application.
+     * @param name Nom de la propriété.
+     * @param value Valeur de la propriété.
+     * @return Cet objet, permettant de définir la construction <tt>getInstance(..).setProperty(..)</tt>.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la sauvergarde de la propriété.
+     */
+    public UserConfig setProperty(String name, String value) {
+        getProperties().setProperty(name, value);
+        try {
+            new File(getApplicationFolder()).mkdirs();
+            properties.storeToXML(new FileOutputStream(getApplicationFolder() + configFile), "JavaS'Cool user configuration");
+        } catch (Exception e) {
+            throw new RuntimeException("Erreur de la sauvegarde de la configuration de l'application " + applicationName + " dans le fichier " + getApplicationFolder() + configFile);
+        }
+        return this;
+    }
+
+    /** Crée et/ou renvoie l'unique instance de l'objet.
+     * <p>Une application ne peut définir qu'un seul objet de configuration.</p>
+     */
+    public static UserConfig getInstance(String applicationName) {
+        if (userConfig == null) {
+            return userConfig = new UserConfig(theApplicationName = applicationName);
+        } else if (theApplicationName.equals(applicationName)) {
+            return userConfig;
+        } else {
+            throw new IllegalArgumentException("Appel incohérent à la configuration de l'application avec deux noms différents " + theApplicationName + " puis " + applicationName);
+        }
+    }
+    private static String theApplicationName = null;
+    private static UserConfig userConfig = null;
+}
Index: src/org/javascool/tools/Pml.java
===================================================================
--- src/org/javascool/tools/Pml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Pml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,1038 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+package org.javascool.tools;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.regex.Pattern;
+
+import java.util.ArrayList;
+import java.util.Properties;
+
+/** Définit la syntaxe PML (Programmatic Markup Language) et son DOM (Data Object Model) Java.
+ *
+ * <p> Un contenu PML (pour «Programmatic Métadata Logicalstructure») et une structure-logique minimale (Parametric Minimal Logical-structure)
+ * qui permet de définir les paramètres d'un objet numérique (algorithme, web-service) ou d'interfacer entre des applications.
+ * C'est une forme minimale de structure à-la XML.</p>
+ *
+ * <p> Ses paramètres sont <ul>
+ *   <li>Son <i>tag</i>, c'est à dire le nom qui définit son type.</li>
+ *   <li>Des <i>attributs</i> c'est à dire des valeurs indexes par un nom.</li>
+ *   <li>Des <i>éléments</i> c'est à dire des valeurs indexees par un entier non-négatif <tt>>= 0</tt>.</li>
+ * </ul> Chaque valeur étant elle même un PML ou une chaîne de caractères. Rien de plus.</p>
+ *
+ * <p>La syntaxe est de la forme:
+ * <div style="margin-left: 40px"><tt>"{tag name = value .. element .. }"</tt></div> où <ul>
+ * <li>Les PML sont encapsules avec des accolades <tt>{</tt> .. <tt>}</tt>.</li>
+ * <li>Les String avec des espaces, <tt>{</tt> ou <tt>}</tt> sont encapsulés avec des double quotes <tt>'"'</tt> (en utilisant <tt>'\"'</tt> pour y échapper).</li>
+ * </ul>Cette syntaxe est minimale, proche des langages à accolades (<tt>C/C++, PHP, Java</tt>), facile à lire ou éditer et surtout complètement standar.</p>
+ *
+ * <p>L'analyse syntaxique de PML est <i>tolérante</i> au sens où une valeur est toujours obtenue sans générer d'erreur de syntaxe,
+ * en utilisant des valeurs par défaut: <ul>
+ *  <li> La construction <tt>"name = value .. "</tt> sans accolade sera vue comme une liste de valeur de tag <tt>null</tt>,</li>
+ *  <li> Un attribut sans valeur recevra la valeur <tt>true</tt>,</li>
+ * </ul> etc..</p>
+ *
+ * @see <a href="Pml.java.html">source code</a>
+ * @serial exclude
+ */
+public class Pml {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public Pml() {}
+
+  private HashMap<String, Object> data = new HashMap<String, Object>();
+
+  /** Initialise la PML en la lisant dans une chaîne de caractères.
+   * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(String value) {
+    // Initializes the Pml
+    data = new HashMap<String, Object>();
+    tag = "";
+    parent = null;
+    count = -1;
+    // Parses the string
+    new PmlReader().read(value, this);
+    return this;
+  }
+  /** Initialise la PML en la lisant dans une chaîne de caractères dans un format donné.
+   * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
+   * @param format Les formats possible sont: <div id="input-format"><ul>
+   * <li>"PML" (valeur par défaut).</li>
+   * <li>"XML" pour utiliser les structure-logiques XML de la forme <tt>&lt;tag name = value .. > &lt;element .. &lt;/tag></tt>
+   * <li>"HTM" pour utiliser les structure-logiques HTML.</li>
+   * </ul></div>
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(String value, String format) {
+    format = format.toLowerCase();
+    if("xml".equals(format))
+      return reset(Xml2Xml.run(value, xml2pml), "pml");
+    else if("htm".equals(format) || "html".equals(format))
+      return reset(Xml2Xml.run(Xml2Xml.html2xhtml(value), xml2pml), "pml");
+    else
+      reset(value);
+    return this;
+  }
+  /** Initialise la PML en en recopiant la PML en entrée.
+   * @param pml Le PML à copier.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
+   */
+  public Pml reset(Pml pml) {
+    // Initializes the Pml
+    data = new HashMap<String, Object>();
+    tag = "";
+    parent = null;
+    count = -1;
+    if(pml != null) {
+      setTag(pml.getTag());
+      for(String name : pml.attributes())
+        set(name, pml.getChild(name));
+      for(int i = 0; i < pml.getCount(); i++)
+        set(i, pml.getChild(i));
+    }
+    return this;
+  }
+  /** Initialise la PML à partir des arguments d'une ligne de commande.
+   * <p>La méthode s'utilise dans la construction: <pre>
+   * public static void main(String usage[]) {
+   *   Pml arguments = new Pml.reset(usage);
+   * ../..<pre></p>
+   * <p>Il respecte les conventions suivantes: <ul>
+   * <li><tt>-name</tt> définit un paramètre à la valeur true (la syntaxe <tt>--name</tt> est aussi acceptée),</li>
+   * <li><tt>-name value</tt> définit la valeur d'un paramètre,</li>
+   * <li><tt>file</tt> ajoute un élément de type string,</li>
+   * <li><tt>- file</tt> ajoute un élément de type string qui commence par un <tt>-</tt>.</li>
+   *</ul> Par exemple: <tt>command -quiet -level 123 input1 input2</tt> definit la PML <tt>{usage quiet=true level=123 input1 inpu2}</tt>.</p>
+   * @param usage Les éléments de la ligne de commande.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.   
+   */
+  public Pml reset(String[] usage) {
+    reset("{usage}");
+    for(int i = 0; i < usage.length; i++) {
+      if (!"-".equals(usage[i])) {
+	if (usage[i].startsWith("-") && (i == 0 || !"-".equals(usage[i-1]))) {
+	  String name = usage[i].replaceFirst("-+", "");
+	  if (i == usage.length - 1 || usage[i+1].startsWith("-"))
+	    set(name, true);
+	  else
+	    set(name, usage[++i]);
+	} else 
+	  add(usage[i]);
+      }
+    }
+    return this;
+  }
+  /** Retourne la PML sous forme de chaîne de caractères.
+   * @param format de sortie <div id="output-format"><ul>
+   * <li>"RAW" Retourne une chaîne 1D de longueur minimale (par défault).</li>
+   * <li>"TXT" Retourne une chaîne 2D formattée.</li>
+   * <li>"XML" Retourne une structure logique XML,
+   * en réduisant les tag et attributs à des nom XML valides et en considérant les PML sans attribut ni élément comme des chaînes.<li>
+   * <li>"PHP" Retourne un élément de code PHP de la forme:<tt>&lt;php $tag = array("_tag" = getTag(), . . "name" => "value", . . , "element");?></tt>.</li>
+   * <li>"JMF" Retourne un format de fichier de manifeste de JAR de la forme: <tt> name : value \n .. </tt> en omettant le tag et les éléments.</li>
+   * </ul></div>
+   * @return La chaîne qui représente la PML.
+   */
+  public String toString(String format) {
+    format = format.toLowerCase();
+    return "xml".equals(format) ? new XmlWriter().toString(this)
+           : "raw".equals(format) ? new PlainWriter().toString(this, 0)
+           : "php".equals(format) ? new PhpWriter().toString(this)
+           : "jmf".equals(format) ? new JmfWriter().toString(this)
+           : new PlainWriter().toString(this, 180);
+  }
+  @Override
+  public final String toString() {
+    return toString("raw");
+  }
+  /** Initialise la PML en la lisant dans un fichier donné.
+   * @param location  L'URL (Universal Resource Location) de chargement de <a href="FileManager.html#load-format">format standard</a>.
+   * @param format Le format de lecture parmi les <a href="#input-format">formats supportés</a>, par défaut donné par l'extension du fichier.
+   * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().load(..)</tt>.
+   */
+  public final Pml load(String location, String format, boolean utf8) {
+    if (format == null)
+        format = location.replaceAll("^.*\\.([A-Za-z]+)$", "$1");
+    return reset(FileManager.load(location, utf8), format);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location, String format) {
+    return load(location, format, false);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location, boolean utf8) {
+    return load(location, null, utf8);
+  }
+  /**
+   * @see #load(String, String, boolean)
+   */
+  public final Pml load(String location) {
+    return load(location, null, false);
+  }
+  /** Sauve la PML dans un fichier donné.
+   * @param location  L'URL (Universal Resource Location) d'écriture de <a href="FileManager.html#save-format">format standard</a>.
+   * @param format Le format d'écriture parmi les <a href="#output-format">formats supportés</a>, par défaut donné par l'extension du fichier.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().save(..)</tt>.
+   */
+  public final Pml save(String location, String format) {
+    FileManager.save(location, toString(format) + "\n");
+    return this;
+  }
+  /**
+   * @see #save(String, String)
+   */
+  public final Pml save(String location) {
+    return save(location, location.replaceAll("^.*\\.([A-Za-z]+)$", "$1"));
+  }
+  /** Definit l'analyseur lexical qui lit la chaîne mot à mot en normlisant les espaces et en titant le caractère '"'. */
+  protected static class TokenReader {
+    /** Definit un élément lexical. */
+    private static class token {
+      String string;
+      int line;
+
+      token(String s, int i0, int i1, int l) {
+        string = s.substring(i0, i1);
+        line = l;
+      }
+      @Override
+      public String toString() {
+        return "#" + line + " \"" + string + "\" ";
+      }
+    }
+    ArrayList<token> tokens;
+    int itoken;
+
+    /** Initialise le lecteur. */
+    public TokenReader reset(String string) {
+      // Initializes the buffer
+      tokens = new ArrayList<token>();
+      itoken = 0;
+      // Split the string into tokens
+      {
+        char[] chars = string.toCharArray();
+        for(int ichar = 0, ln = 0; ichar < chars.length;) {
+          // Skips spaces
+          while(ichar < chars.length && Character.isWhitespace(chars[ichar])) {
+            if(chars[ichar] == '\n')
+              ln++;
+            ichar++;
+          }
+          if(ichar < chars.length) {
+            int ichar0 = ichar;
+            // Detects a quoted string taking "{" "}" and \" constructs into account
+            if(chars[ichar0] == '"') {
+              while(ichar < chars.length && (ichar == ichar0 || chars[ichar] != '"' || chars[ichar - 1] == '\\'))
+                ichar++;
+              ichar++;
+              int ichar1;
+              if((ichar == ichar0 + 3) && ((chars[ichar0 + 1] == '{') || (chars[ichar0 + 1] == '}')))
+                ichar1 = ichar;
+              else {
+                ichar0++;
+                ichar1 = ichar - 1;
+              }
+              tokens.add(new token(string, ichar0, ichar1, ln));
+              // Detects a name
+            } else if(Character.isLetter(chars[ichar0]) || (chars[ichar0] == '_')) {
+              while(ichar < chars.length && (Character.isLetterOrDigit(chars[ichar]) || chars[ichar0] == '_'))
+                ichar++;
+              tokens.add(new token(string, ichar0, ichar, ln));
+              // Detects a number
+            } else if(Character.isDigit(chars[ichar0]) || (chars[ichar0] == '.')) {
+              while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                ichar++;
+              if((ichar < chars.length) && (chars[ichar] == '.')) {
+                ichar++;
+                while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                  ichar++;
+              }
+              if((ichar < chars.length) && ((chars[ichar] == 'E') || (chars[ichar] == 'e'))) {
+                ichar++;
+                if((ichar < chars.length) && ((chars[ichar] == '+') || (chars[ichar] == '-')))
+                  ichar++;
+                while(ichar < chars.length && Character.isDigit(chars[ichar]))
+                  ichar++;
+              }
+              tokens.add(new token(string, ichar0, ichar, ln));
+              // Detects operators and punctuation
+            } else if(isOperator(chars[ichar0])) {
+              while(ichar < chars.length && isOperator(chars[ichar]))
+                ichar++;
+              tokens.add(new token(string, ichar0, ichar, ln));
+            } else
+              tokens.add(new token(string, ichar0, ++ichar, ln));
+          }
+        }
+      }
+      itoken = 0;
+      return this;
+    }
+    private static boolean isOperator(char c) {
+      switch(c) {
+      case '+':
+      case '-':
+      case '*':
+      case '/':
+      case '%':
+      case '&':
+      case '|':
+      case '^':
+      case '=':
+      case '!':
+      case '<':
+      case '>':
+      case '.':
+      case ':':
+        return true;
+      default:
+        return false;
+      }
+    }
+    /** Renvoie un des éléments.
+     * @param next Si 0 renvoie l'élément courant. Si 1 renvoie l'élément à suivre, etc..
+     * @return L'élément ou '}' à l afin du fichier.
+     */
+    public String getToken(int next) {
+      String current = itoken + next < tokens.size() ? tokens.get(itoken + next).string : "}";
+      return current;
+    }
+    /** Teste si il y reste des éléments. */
+    public boolean isNext() {
+      return itoken < tokens.size();
+    }
+    /** Avance à un élément suivant.
+     * @param next Si 1 avance d'un élément, etc..
+     */
+    public void next(int next) {
+      itoken += next;
+    }
+    /** Renvoie la fin de la chaîne. */
+    public String trailer() {
+      String t = "";
+      while(itoken < tokens.size())
+        t += " " + tokens.get(itoken++).string;
+      return t.trim();
+    }
+    /** Teste une condition de syntaxe. */
+    public void check(boolean ok, String message) {
+      if(!ok)
+        System.out.println("Erreur de syntaxe \"" + message + "\", ligne " + (itoken < tokens.size() ? "" + tokens.get(itoken).line + " vers \"" + getToken(0) + "\"" : "finale"));
+    }
+    @Override
+    public String toString() {
+      String s = "[";
+      for(int i = 0; i < tokens.size(); i++)
+        s += (i == itoken ? " ! " : " ") + "\"" + tokens.get(i).string + "\"#" + tokens.get(i).line;
+      return s + " ]";
+    }
+  }
+
+  /** Définit un lecteur de PML. */
+  private static class PmlReader extends TokenReader {
+    /** Lit la chaîne et en affecte les valeurs du PML. */
+    public void read(String string, Pml pml) {
+      reset(string);
+      // Parses the string
+      parse(pml);
+      // Detects the trailer if any
+      String trailer = trailer();
+      if(trailer.length() > 0) {
+        Pml p = new Pml();
+        p.setTag(trailer);
+        pml.set("string_trailer", p);
+      }
+    }
+    /** Effectue l'analyse syntaxique récursive. */
+    private Pml parse(Pml pml) {
+      String b = getToken(0);
+      // Parses a { } Pml construct
+      if("{".equals(b)) {
+        next(1);
+        for(boolean start = true; true; start = false) {
+          String t = getToken(0);
+          if("}".equals(t)) {
+            next(1);
+            break;
+            // Adds an element
+          } else if("{".equals(t)) {
+            Pml p = new Pml();
+            parse(p);
+            pml.add(p);
+            // Adds an attribute
+          } else if("=".equals(getToken(1))) {
+            next(2);
+            if("}".equals(getToken(0)))
+              pml.set(t, "true");
+            else {
+              Pml p = new Pml();
+              parse(p);
+              pml.set(t, p);
+            }
+            // Adds an attribute tag
+          } else if(start) {
+            next(1);
+            pml.setTag(t);
+            // Adds an atomic element
+          } else {
+            Pml p = new Pml();
+            parse(p);
+            pml.add(p);
+          }
+        }
+        // Considers the Pml as a list of name=value
+      } else if("=".equals(getToken(1)))
+        while("=".equals(getToken(1))) {
+          String t = getToken(0);
+          next(2);
+          if("}".equals(getToken(0)))
+            pml.set(t, "true");
+          else {
+            Pml p = new Pml();
+            parse(p);
+            pml.set(t, p);
+          }
+        }
+      // Considers the Pml as a simple string
+      else {
+        pml.setTag(b);
+        next(1);
+      }
+      return pml;
+    }
+  }
+
+  /** Définit le convertisseur de XML en PML. */
+  private static String xml2pml =
+    "<?xml version='1.0' encoding='utf-8'?>\n"
+    + "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n"
+    + "  <xsl:output method='xml' encoding='utf-8' omit-xml-declaration='yes'/>\n"
+    + "  <xsl:template match='*'>\n"
+    + "  {<xsl:value-of select='name(.)'/><xsl:text> </xsl:text>\n"
+    + "    <xsl:for-each select='@*'><xsl:value-of select='name(.)'/>=\"<xsl:value-of select=\"translate(., '&quot;','¨')\"/>\"<xsl:text> </xsl:text></xsl:for-each>\n"
+    + "    <xsl:apply-templates/>\n"
+    + "  }</xsl:template>\n"
+    + "</xsl:stylesheet>";
+
+  /** Définit le convertisseur de PML en chaîne de caractères. */
+  private static class PlainWriter {
+    private StringBuffer string;
+    int width, l;
+
+    /** Convertit la PML en chaîne.
+     * @param pml Le PML à convertir.
+     * @param width si width == 0 retourne une chaîne 1D de longueur minimale, sinon retourne une chaîne 2D de la largeur donnée.
+     * @return La chaîne générée.
+     */
+    public String toString(Pml pml, int width) {
+      if(pml == null)
+        return "null";
+      // Initializes the variables
+      string = new StringBuffer();
+      if(width == 0)
+        write1d(pml);
+      else {
+        this.width = width;
+        l = 0;
+        write2d(pml, 0, 0);
+      }
+      return string.toString();
+    }
+    private void write1d(Pml pml) {
+      if(pml == null) {
+        string.append(" {null} ");
+        return;
+      }
+      string.append("{").append(quote(pml.getTag()));
+      for(String name : pml.attributes()) {
+        string.append(" ").append(quote(name)).append("=");
+        write1d(pml.getChild(name));
+      }
+      for(int n = 0; n < pml.getCount(); n++) {
+        string.append(" ");
+        write1d(pml.getChild(n));
+      }
+      string.append("}");
+    }
+    private boolean write2d(Pml pml, int n, int tab) {
+      if(pml == null) {
+        string.append(" {null} ");
+        return false;
+      }
+      if(pml.getSize() == 0) {
+        boolean ln = n >= 0 && (n == 0 || (pml.getParent() != null&& pml.getParent().getChild(n - 1) != null&& pml.getParent().getChild(n - 1).getSize() > 0));
+        writeln(ln, tab);
+        write(quote(pml.getTag()), tab);
+        return ln;
+      } else {
+        boolean ln = pml.getTag().length() > 1 || "p".equals(pml.getTag());
+        writeln(n >= 0 && ln, tab);
+        write("{" + quote(pml.getTag()), tab);
+        ln = false;
+        for(String name : pml.attributes()) {
+          write(" " + quote(name) + " =", tab);
+          ln |= write2d(pml.getChild(name), -1, tab + 1);
+        }
+        for(int i = 0; i < pml.getCount(); i++)
+          ln |= write2d(pml.getChild(i), i, tab + 2);
+        writeln(ln, tab);
+        write("}", tab);
+        return ln;
+      }
+    }
+    private void writeln(boolean ln, int tab) {
+      if(ln) {
+        string.append("\n");
+        for(int t = 0; t < tab; t++)
+          string.append(" ");
+        l = tab;
+      } else
+        string.append(" ");
+    }
+    private void write(String word, int tab) {
+      if(l + word.length() > width)
+        writeln(false, tab + 1);
+      string.append(word);
+      l += word.length();
+    }
+    /** Retourne la chaîne en tenant compte des "{" "}" et \". */
+    private static String quote(String string) {
+      return string == null ? "null" :
+             string.matches("[a-zA-Z_][a-zA-Z0-9_]*") || "\"{\"".equals(string) || "\"}\"".equals(string) ? string :
+             "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
+    }
+  }
+
+  /** Définit le convertisseur de PML en XMl. */
+  private static class XmlWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en chaîne XML 1D. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "<null/>";
+      write(pml);
+      return string.toString();
+    }
+    private void write(Pml pml) {
+      if(pml.getSize() == 0)
+        string.append(" ").append(pml.getTag().replaceFirst("^\"([{}])\"$", "$1").replaceAll("&", "&amp;").replaceAll("<", "&lt;"));
+      else {
+        string.append(" <").append(toName(pml.getTag()));
+        for(String name : pml.attributes())
+          string.append(" ").append(toName(name)).append("=\"").append(pml.getChild(name).toString().replaceFirst("^\\{(.*)\\}$", "$1").replaceFirst("^\"(.*)\"$", "$1").
+                                                                       replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll("\"", "&quot;")).append("\"");
+        if(pml.getCount() > 0) {
+          string.append(">");
+          for(int n = 0; n < pml.getCount(); n++)
+            write(pml.getChild(n));
+          string.append("</").append(toName(pml.getTag())).append(">");
+        } else
+          string.append("/>");
+      }
+    }
+  }
+
+  /**  Définit le convertisseur de PML en PHP. */
+  private static class PhpWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en tableau PHP. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "<?php $pml = array(); ?>";
+      else {
+	String tag = toName(pml.getTag());
+	if (tag.length() == 0)
+	  tag = "pml";
+        string.append("<?php $").append(tag).append(" = array(\"_tag\" => ").append(quote(pml.getTag()));
+        for(String name : pml.attributes())
+          string.append(", ").append(quote(name)).append(" => ").append(quote(pml.getChild(name)));
+        for(int n = 0; n < pml.getCount(); n++)
+          string.append(", ").append(quote(pml.getChild(n)));
+        string.append("); ?>");
+      }
+      return string.toString();
+    }
+    /** Prends en compte les \". */
+    private static String quote(String string) {
+      return "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
+    }
+    private static String quote(Pml pml) {
+      return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
+    }
+  }
+
+  /**  Définit le convertisseur de PML en JMF. */
+  private static class JmfWriter {
+    private StringBuffer string;
+
+    /** Convertit la PML en fichier JMF. */
+    public String toString(Pml pml) {
+      string = new StringBuffer();
+      if(pml == null)
+        return "";
+      else
+        for(String name : pml.attributes())
+          string.append(name).append(": ").append(quote(pml.getChild(name))).append("\n");
+      return string.toString();
+    }
+    /** Elimine les \n. */
+    private static String quote(String string) {
+      return string.replaceAll("\n", " ");
+    }
+    private static String quote(Pml pml) {
+      return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
+    }
+  }
+
+  private static String toName(String string) {
+    if(string.length() > 0) {
+      String c_0 = string.substring(0, 1);
+      String name = c_0.matches("[_-]") || Character.isLetter(c_0.charAt(0)) ? "" : "_";
+      for(int i = 0; i < string.length(); i++) {
+        String c_i = string.substring(i, i + 1);
+        name += c_i.matches("_-") || Character.isLetterOrDigit(c_i.charAt(0)) ? c_i : "_";
+      }
+      return name;
+    } else
+      return string;
+  }
+  /** Renvoie le type de ce PML.
+   * @return The tag définit lors de l'initialisation, sinon le nom de la classe du PML.
+   */
+  public final String getTag() {
+    return tag;
+  }
+  protected final Pml setTag(String value) {
+    tag = value;
+    return this;
+  }
+  private String tag = getClass().getName();
+
+  /** Renvoie le parent du PML si défini.
+   * @return Si ce PML est un sous-partie d'un PML renvoie son parent, sinon renvoie null.
+   */
+  public final Pml getParent() {
+    return parent;
+  }
+  private void setParent(Pml value) {
+    if(parent == null)
+      parent = value;
+  }
+  private Pml parent = null;
+
+  /** Teste si un paramètre de ce PML est défini.
+   * <p>Cet appel est formellement équivalent à <tt>getChild(name) != null</tt></p>
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return True si le paramètre est défini, false sinon.
+   */
+  public final boolean isDefined(String name) {
+    return data.containsKey(name);
+  }
+  /**
+   * @see #isDefined(String)
+   */
+  public final boolean isDefined(int index) {
+    return isDefined(Integer.toString(index));
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML.
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return La valeur du paramètre, ou null si indéfini.
+   */
+  public Pml getChild(String name) {
+    Object o = data.get(name);
+    return o == null ? null : o instanceof Pml ? (Pml) o : new Pml().reset("{\"" + o.toString() + "\"}");
+  }
+  /**
+   * @see #getChild(String)
+   */
+  public final Pml getChild(int index) {
+    return getChild(Integer.toString(index));
+  }
+  /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
+   * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return La valeur du paramètre, ou null si indéfini en tant que paramètre.
+   */
+  public Object getObject(String name) {
+    return data.get(name);
+  }
+  /**
+   * @see #getObject(String)
+   */
+  public final Object getObject(int index) {
+    return getObject(Integer.toString(index));
+  }
+  /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
+   *
+   *  /** Renvoie la valeur d'un paramètre de ce PML en tant que chaîne.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final String getString(String name, String value) {
+    if(data.get(name) == null)
+      return "";
+    String v = data.get(name).toString();
+    if(v.matches("[{]\".*\"[}]"))
+      v = v.substring(2, v.length() - 2);
+    if(v.matches("[{].*[}]"))
+      v = v.substring(1, v.length() - 1);
+    return v != null ? v : value != null ? value : "";
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(int index, String value) {
+    return getString(Integer.toString(index), value);
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(String name) {
+    return getString(name, null);
+  }
+  /**
+   * @see #getString(String, String)
+   */
+  public final String getString(int index) {
+    return getString(index, null);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant que décimal.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "0".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final double getDecimal(String name, double value) {
+    try {
+      return Double.parseDouble(getString(name));
+    } catch(NumberFormatException e) {
+      return value;
+    }
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(int index, double value) {
+    return getDecimal(Integer.toString(index), value);
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(String name) {
+    return getDecimal(name, 0);
+  }
+  /**
+   * @see #getDecimal(String, double)
+   */
+  public final double getDecimal(int index) {
+    return getDecimal(index, 0);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant qu'entier.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon "0".
+   * @return La valeur de ce paramètre, si défini, sinon sa valeur par défaut.
+   */
+  public final int getInteger(String name, int value) {
+    try {
+      return Integer.parseInt(getString(name));
+    } catch(NumberFormatException e) {
+      return value;
+    }
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(int index, int value) {
+    return getInteger(Integer.toString(index), value);
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(String name) {
+    return getInteger(name, 0);
+  }
+  /**
+   * @see #getInteger(String, int)
+   */
+  public final int getInteger(int index) {
+    return getInteger(index, 0);
+  }
+  /** Renvoie la valeur d'un paramètre de ce PML en tant que boolean.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur par défaut, sinon false.
+   * @return La valeur true ou false si le paramètre est égal à "true" ou "false" indépendamment de la casse, la valeur par défaut sinon.int
+   */
+  public final boolean getBoolean(String name, boolean value) {
+    String v = getString(name);
+    if(v != null) {
+      if("true".equals(v.toLowerCase()))
+        return true;
+      if("false".equals(v.toLowerCase()))
+        return false;
+    }
+    return value;
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(int index, boolean value) {
+    return getBoolean(Integer.toString(index), value);
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(String name) {
+    return getBoolean(name, false);
+  }
+  /**
+   * @see #getBoolean(String, boolean)
+   */
+  public final boolean getBoolean(int index) {
+    return getBoolean(index, false);
+  }
+  /** Définit la valeur d'un paramètre de ce PML.
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @param value La valeur du paramètre (en tant que PML, object Java, entier, décimal ou entier). Si null efface la valeur précédente.
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
+   */
+  public Pml set(String name, Object value) {
+    // Deletes the attribute value
+    if(value == null) {
+      try {
+        // Shifts removed elements to avoid "null wholes"
+        int i = Integer.parseInt(name), l = getCount() - 1;
+        if((0 <= i) && (i <= l)) {
+          for(int j = i; j < l; j++)
+            data.put(Integer.toString(j), data.get(Integer.toString(j + 1)));
+          data.remove(Integer.toString(l));
+        } else
+          data.remove(name);
+      } catch(NumberFormatException e) {
+        data.remove(name);
+      }
+      // Adds the parameter value
+    } else {
+      data.put(name, value);
+      if(value instanceof Pml)
+        ((Pml) value).setParent(this);
+    }
+    count = -1;
+    return this;
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, Object value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, String value) {
+    if (value == null) {
+      return set(name, (Object) null);
+    } else {
+      Pml v = new Pml();
+      v.reset("\"" + value.replaceAll("\"", "\\\"") + "\"");
+      return set(name, v);
+    }
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, String value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, double value) {
+    return set(name, Double.toString(value));
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, double value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, int value) {
+    return set(name, Integer.toString(value));
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, int value) {
+    return set(Integer.toString(index), value);
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(String name, boolean value) {
+    return set(name, value ? "true" : "false");
+  }
+  /**
+   * @see #set(String, Object)
+   */
+  public final Pml set(int index, boolean value) {
+    return set(Integer.toString(index), value);
+  }
+  /** Elimine la valeur d'un paramètre de ce PML.
+   * <p>Cet appel est formellement équivalent à <tt>set(name, null);</tt></p>
+   * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().del(..)</tt>.
+   */
+  public Pml del(String name) {
+    return set(name, (Pml) null);
+  }
+  /**
+   * @see #del(String)
+   */
+  public final Pml del(int index) {
+    return set(Integer.toString(index), (Pml) null);
+  }
+  /** Ajoute un élément à ce PML.
+   * <p>Cet appel est formellement équivalent à <tt>set(getCount(), value);</tt></p>
+   * @param value La valeur du paramètre (en tant que PML, entier, décimal ou entier).
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().add(..)</tt>.
+   */
+  public final Pml add(Pml value) {
+    int c = getCount();
+    set(c, value);
+    count = ++c;
+    return this;
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(String value) {
+    Pml v = new Pml();
+    v.reset(value);
+    return add(v);
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(double value) {
+    return add(Double.toString(value));
+  }
+  /**
+   * @see #add(String)
+   */
+  public final Pml add(int value) {
+    return add(Integer.toString(value));
+  }
+  /**  Définit la valeur de paramètres de ce PML.
+   * @param pml La structure dont on copie les paramètres
+   * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
+   */
+  public final Pml set(Pml pml) {
+    for(String name : pml.attributes())
+      set(name, pml.getObject(name));
+    for(int n = 0; n < pml.getCount(); n++)
+      set(n, pml.getObject(n));
+    return this;
+  }
+  /**
+   * @see #set(Pml)
+   */
+  public final Pml set(Properties pml) {
+    for(String name : pml.stringPropertyNames())
+      set(name, pml.getProperty(name));
+    return this;
+  }
+  /** Renvoie le nombre d'éléments de ce PML.
+   * @return Le nombre d'éléments (indépendamment des attributs), les éléments null étant éliminés
+   */
+  public int getCount() {
+    if(count < 0) {
+      count = 0;
+      for(String key : data.keySet())
+        if(isIndex(key))
+          count = Math.max(Integer.parseInt(key) + 1, count);
+    }
+    return count;
+  }
+  private int count = -1;
+
+  /** Renvoie le nombre de paramètres de ce PML.
+   * @return Le nombre d'attributs et d'éléments. Si 0, ce PML correspond uniquement à une chaîne: son tag.
+   */
+  public int getSize() {
+    return data.size();
+  }
+  /** Définir un itérateur sur les attributs de ce PML.
+   * <p>- Les attributes sont énumérés avec une construction de la forme: <tt>for(String name : pml.attributes()) { Pml value = pml.getChild(name); .. }</tt>.</p>
+   * <p>- Les éléments sont énumérés avec une construction de la forme:  <tt>for(int n = 0; n &lt; pml.getCount(); n++) { Pml value = pml.getChild(n); .. }</tt>.</p>
+   */
+  public final Iterable<String> attributes() {
+    return new Iterable<String>() {
+             @Override
+             public Iterator<String> iterator() {
+               return new Iterator<String>() {
+                        Iterator<String> keys = data.keySet().iterator();
+                        String key;
+
+                        {
+                          nextKey();
+                        }
+
+                        private void nextKey() {
+                          for(key = null; keys.hasNext() && isIndex(key = keys.next()); key = null) {}
+                        }
+                        @Override
+                        public String next() {
+                          String value = key;
+                          nextKey();
+                          return value;
+                        }
+                        @Override
+                        public boolean hasNext() {
+                          return key != null;
+                        }
+                        @Override
+                        public void remove() { throw new UnsupportedOperationException();
+                        }
+               };
+             }
+    };
+  }
+  // @return true if the name is an index
+  private static boolean isIndex(String name) {
+    return index.matcher(name).matches();
+  }
+  static Pattern index = Pattern.compile("[0-9]+");
+
+  /** Renvoie les paramètres de cette PML sous forme de Properties.
+   * @return Une structure Properties contenant attributs et éléments sous forme de chaîne de caractère.
+   */
+  public final Properties toProperties() {
+    Properties properties = new Properties();
+    for(String name : attributes())
+      properties.setProperty(name, getObject(name).toString());
+    for(int n = 0; n < getCount(); n++)
+      properties.setProperty("" + n, getObject(n).toString());
+    return properties;
+  }
+  /** Lanceur du mécanisme de vérification/conversion d'une PML.
+   * @param usage <tt>java org.javascool.tools.Pml input-file [output-file.(pml|xml|php|jmf)]</tt>
+   */
+  public static void main(String[] usage) {
+    if(usage.length > 0)
+      new Pml().load(usage[0]).save(usage.length > 1 ? usage[1] : "stdout:", (usage.length > 1 && usage[1].matches(".*\\.(pml|php|xml|jmf)")) ? usage[1].replaceFirst(".*\\.", "") : "pml");
+  }
+}
Index: src/org/javascool/tools/FileManager.java
===================================================================
--- src/org/javascool/tools/FileManager.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/FileManager.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+ *******************************************************************************/
+package org.javascool.tools;
+
+// Used for URL formation
+import java.net.URL;
+import java.util.Arrays;
+import org.javascool.macros.Macros;
+import java.io.File;
+import java.io.IOException;
+
+// Used for URL read
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
+
+// Used for URL write
+import java.net.URLConnection;
+import java.io.OutputStreamWriter;
+import java.io.FileOutputStream;
+
+// Used for list/exists
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.jar.JarFile;
+import java.util.jar.JarEntry;
+import java.util.Enumeration;
+
+/** Met à disposition des fonctions de gestion de fichiers locaux et distants.
+ * <p>Lit/Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.</p>
+ *
+ * @see <a href="FileManager.java.html">code source</a>
+ * @serial exclude
+ */
+public class FileManager {
+    // @factory
+
+    private FileManager() {
+    }
+
+    /** Lit un contenu textuel local ou distant en tenant compte de l'encodage local.
+     *
+     * @param location Une URL (Universal Resource Location) de la forme: <div id="load-format"><table align="center">
+     * <tr><td><tt>http:/<i>path-name</i></tt></td><td>pour aller chercher le contenu sur un site web</td></tr>
+     * <tr><td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td><td>pour le récupérer sous forme de requête HTTP</td></tr>
+     * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour le charger du système de fichier local ou en tant que ressource Java dans le CLASSPATH</td></tr>
+     * <tr><td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td><td>pour le charger d'une archive
+     *  <div>(exemple:<tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>)</div></td></tr>
+     * </table></div>
+     * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static String load(String location, boolean utf8) {
+        try {
+            BufferedReader reader = new BufferedReader(new InputStreamReader(Macros.getResourceURL(location, true).openStream(), 
+                        utf8 ? Charset.forName("utf-8") : Charset.defaultCharset()), 10240);
+            StringBuilder buffer = new StringBuilder();
+            char chars[] = new char[10240];
+            while (true) {
+                int l = reader.read(chars);
+                if (l == -1) {
+                    break;
+                }
+                buffer.append(chars, 0, l);
+            }
+            return buffer.toString();
+
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when loading: " + location);
+        }
+    }
+    /**
+     * * @see #load(String, boolean)
+     */
+     public static String load(String location) {
+        return load(location, false);
+     }
+    /** Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.
+     *
+     * @param location @optional<"stdout:"> Une URL (Universal Resource Location) de la forme: <div id="save-format"><table>
+     * <tr><td><tt>ftp:/<i>path-name</i></tt></td><td>pour sauver sur un site FTP.</td></tr>
+     * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour sauver dans le système de fichier local (le <tt>file:</tt> est optionnel).</td></tr>
+     * <tr><td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td><td>pour envoyer un courriel avec le texte en contenu.</td></tr>
+     * <tr><td><tt>stdout:/</tt></td><td>pour l'imprimer dans la console.</td></tr>
+     * </table></div>
+     * @param string Le texte à sauvegarder.
+     * @param backup Si true, dans le cas d'un fichier, crée une sauvegarde d'un fichier existant. Par défaut false.
+     * * <p>Le fichier sauvegardé est doté d'un suffixe numérique unique.</p>
+     * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static void save(String location, String string, boolean backup, boolean utf8) {
+        if (location.startsWith("stdout:")) {
+            System.out.println("\n" + location + " " + string);
+            return;
+        }
+        location = Macros.getResourceURL(location, false).toString();
+        try {
+            if(location.startsWith("file:") && new File(location.substring(5)).getParentFile() != null)
+	      new File(location.substring(5)).getParentFile().mkdirs();
+            if (backup && !location.startsWith("file:")) {
+                throw new IllegalArgumentException("Impossible de procéder à un backup pour l'URL «" + location + "»");
+            }
+            OutputStreamWriter writer = location.startsWith("file:") ? getFileWriter(location.substring(5), backup, utf8) : getUrlWriter(location, utf8);
+            for (int i = 0; i < string.length(); i++) {
+                writer.write(string.charAt(i));
+            }
+            writer.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when saving: " + location);
+        }
+    }
+
+    /**
+     * @see #save(String, String, boolean, boolean)
+     */
+    public static void save(String location, String string, boolean backup) {
+        save(location, string, backup, false);
+    }
+   /**
+     * @see #save(String, String, boolean, boolean)
+     */
+    public static void save(String location, String string) {
+        save(location, string, false, false);
+    }
+
+    /** Met en place le writer dans le cas d'une URL. */
+    private static OutputStreamWriter getUrlWriter(String location, boolean utf8) throws IOException {
+        URL url = new URL(location);
+        URLConnection connection = url.openConnection();
+        connection.setDoOutput(true);
+        OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), 
+                    utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
+        if (url.getProtocol().equals("mailto")) {
+            int i = url.toString().indexOf("?subject=");
+            if (i != -1) {
+                writer.write("Subject: " + url.toString().substring(i + 9) + "\n");
+            }
+        }
+        return writer;
+    }
+
+    /** Mets en place le writer dans le cas d'un fichier. */
+    private static OutputStreamWriter getFileWriter(String location, boolean backup, boolean utf8) throws IOException {
+        File file = new File(location), parent = file.getParentFile();
+        if ((parent != null) && (!parent.isDirectory())) {
+            parent.mkdirs();
+        }
+        if (backup && file.exists())
+            backup(file);
+        return new OutputStreamWriter(new FileOutputStream(location), utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
+    }
+    /** Mécanisme de backup. */
+    private static void backup(File file) {
+      File backup = new File(file.getAbsolutePath()+"~");
+      if (backup.exists())
+        backup(backup);
+      file.renameTo(backup);
+    }
+
+    /** Détecte si une URL existe.
+     * @param location Une URL (Universal Resource Location).
+     * @return Renvoie true si l'URL existe et est lisible, false sinon.
+     */
+    public static boolean exists(String location) {
+        if (location.matches("(ftp|http|https|jar):.*")) {
+            try {
+                return exists(new URL(location));
+            } catch (IOException e) {
+                return false;
+            }
+        } else {
+            if (location.matches("file:.*")) {
+                location = location.substring(5);
+            }
+            return new File(location).canRead();
+        }
+    }
+
+    /**
+     * @see #exists(String)
+     */
+    public static boolean exists(URL location) {
+        try {
+            location.openStream().close();
+            return true;
+        } catch (IOException e) {
+            return false;
+        }
+    }
+
+    /** Renvoie les fichiers d'un répertoire ou d'un jar.
+     * @param folder Le nom du répertoire ou du fichier jar (fichier d'extension ".jar").
+     * @param pattern Une regex qui définit le type de fichier (ex : <tt>".*\.java"</tt>). Par défaut tous les fichiers.
+     * @param depth Dans le cas d'un répertoire, profondeur: 0 (défaut) pour lire dans le répertoire, 1: répertoire et sous-répertoire, etc..
+     * @return Une énumération des fichiers listés: le path canonique est renvoyé. Si le répertoire ou le jar ne peut être lu, renvoie une liste vide dans erreur.
+     *
+     * @throws IllegalArgumentException Si l'URL ne peut pas être listée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+  public static String[] list(String folder, String pattern, int depth) {
+        if (folder.matches("(ftp|http|https|jar):.*")) {
+            throw new IllegalArgumentException("Impossible de lister le contenu d'un URL de ce type: " + folder);
+        }
+        if (folder.matches("file:.*")) {
+            folder = folder.substring(5);
+        }
+        ArrayList<String> files = new ArrayList<String>();
+        if (folder.matches(".*\\.jar")) {
+            try {
+                for (Enumeration<JarEntry> e = new JarFile(folder).entries(); e.hasMoreElements();) {
+                    String file = e.nextElement().getName();
+                    if ((pattern == null) || file.matches(pattern)) {
+                        files.add("jar:" + folder + "!" + file);
+                    }
+                }
+            } catch(IOException e) {
+                throw new IllegalArgumentException(e);
+            }
+        } else if (new File(folder).isDirectory() && depth >= 0) {
+            try {
+                for (File file : new File(folder).listFiles()) {
+                    if ((pattern == null) || file.getName().matches(pattern)) {
+                        files.add(file.getCanonicalPath());
+                    }
+                }
+		if (depth > 0) {
+		  for (File file : new File(folder).listFiles()) 
+		    if (file.isDirectory()) 
+		      files.addAll(Arrays.asList(list(file.getCanonicalPath(), pattern, depth - 1)));
+		}
+            } catch(IOException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+        return files.toArray(new String[files.size()]);
+    }
+
+    /**
+     * @see #list(String, String, int)
+     */
+    public static String[] list(String folder, String pattern) {
+      return list(folder, pattern, 0);
+    }
+
+
+    /**
+     * @see #list(String, String, int)
+     */
+    public static String[] list(String folder)  {
+      return list(folder, null, 0);
+    }
+
+    /** Crée un répertoire temporaire dans le répertoire temporaire de la machine.
+     * @param prefix Prefix du répertoire.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static File createTempDir(String prefix) {
+        try {
+	  File d = File.createTempFile(prefix, "");
+	  d.delete();
+	  d.mkdirs();
+	  return d;
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when creating temporary directory");
+        }
+    }
+}
Index: src/org/javascool/tools/Invoke.java
===================================================================
--- src/org/javascool/tools/Invoke.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/Invoke.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,33 @@
+package org.javascool.tools;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/** Invoque une méthode sur un objet Java.
+ */
+public class Invoke {
+  /** Invoke une méthode sans argument sur un objet.
+   * @param object L'objet sur lequel on invoque la méthode.
+   * @param method La méthode sans argument à invoquer, souvent : <tt>init</tt>, <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> ou <tt>run</tt>.
+   * @param run Si true (par défaut) appelle la méthode, si false teste simplement son existence.
+   * @return La valeur true si la méthode est invocable, false sinon.
+   * @throws RuntimeException si la méthode génère une exception lors de son appel.
+   */
+  public static boolean run(Object object, String method, boolean run) {
+    try {
+      Method m = object.getClass().getDeclaredMethod(method);
+      if(run)
+        m.invoke(object);
+    } catch(InvocationTargetException e) { throw new RuntimeException(e.getCause());
+    } catch(Throwable e) {
+      return false;
+    }
+    return true;
+  }
+  /**
+   * @see #run(Object, String, boolean)
+   */
+  public static boolean run(Object object, String method) {
+    return run(object, method, true);
+  }
+}
Index: src/org/javascool/tools/package.html
===================================================================
--- src/org/javascool/tools/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/tools/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient des petits utilitaires de base pour JavaS'Cool, réutilisables pour d'autres applications.</body>
+
Index: src/org/javascool/macros/Stdin.java
===================================================================
--- src/org/javascool/macros/Stdin.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Stdin.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,289 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.macros;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import org.javascool.widgets.Dialog;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Stdin.java.html">code source</a>
+ * @serial exclude
+ */
+public class Stdin {
+  // @factory
+  private Stdin() {}
+
+  /** Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La chaîne lue.
+   */
+  public static String readString(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popString();
+    inputQuestion = question;
+    inputString = null;
+    inputDialog = new Dialog();
+    inputDialog.setTitle("Java's Cool read");
+    inputDialog.add(new JPanel() {
+                      {
+                        add(new JLabel(inputQuestion + " "));
+                        add(new JTextField(40) {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = ((JTextField) e.getSource()).getText();
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                      }
+                    }
+                    );
+    inputDialog.open(true);
+    return inputString == null ? "" : inputString;
+  }
+  private static Dialog inputDialog;
+  private static String inputQuestion, inputString;
+
+  /**
+   * @see #readString(String)
+   */
+  public static String readString() {
+    return readString("Entrez une chaîne :");
+  }
+  /** Lit un nombre entier dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static int readInteger(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popInteger();
+    String s = readString(question);
+    try {
+      return Integer.decode(s);
+    } catch(Exception e) {
+      if(!question.endsWith(" (Merci d'entrer un nombre entier)"))
+        question = question + " (Merci d'entrer un nombre entier)";
+      if(s.equals(""))
+        return 0;
+      return readInteger(question);
+    }
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInteger() {
+    return readInteger("Entrez un nombre entier : ");
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInt(String question) {
+    return readInteger(question);
+  }
+  /**
+   * @see #readInteger(String)
+   */
+  public static int readInt() {
+    return readInteger();
+  }
+  /** Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static double readDecimal(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popDecimal();
+    String s = readString(question);
+    try {
+      return Double.parseDouble(s);
+    } catch(Exception e) {
+      if(!question.endsWith(" (Merci d'entrer un nombre)"))
+        question = question + " (Merci d'entrer un nombre)";
+      if(s.equals(""))
+        return 0;
+      return readDecimal(question);
+    }
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDecimal() {
+    return readDecimal("Entrez un nombre décimal : ");
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDouble(String question) {
+    return readDecimal(question);
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readDouble() {
+    return readDecimal();
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readFloat(String question) {
+    return readDecimal(question);
+  }
+  /**
+   * @see #readDecimal(String)
+   */
+  public static double readFloat() {
+    return readDecimal();
+  }
+  /** Lit une valeur booléenne dans une fenêtre présentée à l'utilisateur.
+   * @param question Une invite qui décrit la valeur à entrer (optionel).
+   * @return La valeur lue.
+   */
+  public static boolean readBoolean(String question) {
+    if(inputBuffer.isPopable())
+      return inputBuffer.popBoolean();
+    inputQuestion = question;
+    inputString = null;
+    inputDialog = new Dialog();
+    inputDialog.setTitle("Java's Cool read");
+    inputDialog.add(new JPanel() {
+                      {
+                        add(new JLabel(inputQuestion + " "));
+                        add(new JButton("OUI") {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = "OUI";
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                        add(new JButton("NON") {
+                              {
+                                addActionListener(new ActionListener() {
+                                                    @Override
+                                                    public void actionPerformed(ActionEvent e) {
+                                                      inputString = "NON";
+                                                      inputDialog.close();
+                                                    }
+                                                  }
+                                                  );
+                              }
+                            }
+                            );
+                      }
+                    }
+                    );
+    inputDialog.open(true);
+    return "OUI".equals(inputString);
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static boolean readBoolean() {
+    return readBoolean("Entrez une valeur booléenne (oui/non) : ");
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static Boolean readBool(String question) {
+    return readBoolean(question);
+  }
+  /**
+   * @see #readBoolean(String)
+   */
+  public static Boolean readBool() {
+    return readBoolean();
+  }
+  /** Charge une chaine de caractère pour que son contenu serve d'entrée à la console.
+   * @param string La chaine de caractère à ajouter.
+   */
+  public static void addConsoleInput(String string) {
+    inputBuffer.add(string);
+  }
+  /** Charge le contenu d'un fichier pour que son contenu serve d'entrée à la console.
+   * @param location La localisation (chemin du fichier ou localisation internet) d'où charger le texte.
+   */
+  public static void loadConsoleInput(String location) {
+    addConsoleInput(org.javascool.tools.FileManager.load(location));
+  }
+  /** Définit une zone tampon qui permet de substituer un fichier aux lectures au clavier. */
+  private static class InputBuffer {
+    String inputs = new String();
+
+    /** Ajoute une chaîne en substitution d'une lecture au clavier.
+     * @param string Le texte à ajouter.
+     */
+    public void add(String string) {
+      inputs += string.trim() + "\n";
+    }
+    /** Teste si il y une chaîne disponible.
+     * @return La valeur true si il y une entrée disponible.
+     */
+    public boolean isPopable() {
+      return inputs.length() > 0;
+    }
+    /** Récupére une chaîne en substitution d'une lecture au clavier.
+     * @return Le texte suivant à considérer. Ou la chaîne vide si le tampon est vide.
+     */
+    public String popString() {
+      Macros.sleep(500);
+      int i = inputs.indexOf("\n");
+      if(i != -1) {
+        String input = inputs.substring(0, i);
+        inputs = inputs.substring(i + 1);
+        return input;
+      } else
+        return "";
+    }
+    /**
+     * @see #popString(String)
+     */
+    public int popInteger() {
+      try {
+        return Integer.decode(popString());
+      } catch(Exception e) {
+        return 0;
+      }
+    }
+    /**
+     * @see #popString(String)
+     */
+    public double popDecimal() {
+      try {
+        return Double.parseDouble(popString());
+      } catch(Exception e) {
+        return 0;
+      }
+    }
+    /**
+     * @see #popString(String)
+     */
+    public boolean popBoolean() {
+      // Renvoie vrai si [t]rue [y]es [v]rai [o]ui 1
+      return popString().toLowerCase().matches("[tyvo1].*");
+    }
+  }
+  private static InputBuffer inputBuffer = new InputBuffer();
+}
+
Index: src/org/javascool/macros/Stdout.java
===================================================================
--- src/org/javascool/macros/Stdout.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Stdout.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,142 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.macros;
+
+import org.javascool.gui.Desktop;
+import org.javascool.widgets.Console;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Stdout.java.html">code source</a>
+ * @serial exclude
+ */
+public class Stdout {
+  // @factory
+  private Stdout() {}
+
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
+   * - Cette fonction ne change pas le focus de javascool.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   * @see #println(String)
+   */
+  public static void echo(String string) {
+      Console.getInstance().print(string+"\n");
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(int string) {
+    echo("" + string);
+  } 
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(char string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(double string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(boolean string) {
+    echo("" + string);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void echo(Object string) {
+    echo("" + string);
+  }
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
+   * - Cette fonction ramène le focus de javascool sur la console.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   * @see #echo(String)
+   */
+  public static void println(String string) {
+    Desktop.getInstance().focusOnConsolePanel();
+    System.err.println("printing : \""+string+"\"");
+      Console.getInstance().print(string+"\n");
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(int i) {
+    println("" + i);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(char i) {
+    println("" + i);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(double d) {
+    println("" + d);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(boolean b) {
+    println("" + b);
+  }
+  /**
+   * @see #echo(String)
+   */
+  public static void println(Object o) {
+    println("" + o);
+  }
+  /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console sans retour à la ligne.
+   * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
+   */
+  public static void print(String string) {
+    System.out.print(string);
+    System.out.flush();
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(int i) {
+    print("" + i);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(double d) {
+    print("" + d);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(boolean b) {
+    print("" + b);
+  }
+  /**
+   * @see #print(String)
+   */
+  public static void print(Object o) {
+    print("" + o);
+  }
+  /** Efface tout ce qui est écrit dans la console. */
+  public static void clear() {
+    Console.getInstance().clear();
+  }
+  /** Sauve ce qui est présentement écrit dans la console dans un fichier.
+   * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.
+   */
+  public static void saveConsoleOutput(String location) {
+    Console.getInstance().saveConsoleOutput(location);
+  }
+}
Index: src/org/javascool/macros/Macros.java
===================================================================
--- src/org/javascool/macros/Macros.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/Macros.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,336 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.macros;
+
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.Desktop;
+import java.awt.Dimension;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.net.URISyntaxException;
+
+import java.util.Calendar;
+import javax.swing.ImageIcon;
+
+import org.javascool.tools.Sampler;
+import org.javascool.core.ProgletEngine;
+
+import java.net.URL;
+import java.io.File;
+import java.io.IOException;
+import javax.swing.JButton;
+import javax.swing.JEditorPane;
+import org.javascool.core.ProgletEngine;
+import org.javascool.widgets.Dialog;
+import javax.swing.SwingUtilities;
+import org.javascool.widgets.PanelApplet;
+
+/** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
+ * <p>Elle permet de définir des fonctions plus facile d'utilisation que les appels Java usuels.</p>
+ * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
+ *
+ * @see <a href="Macros.java.html">code source</a>
+ * @serial exclude
+ */
+public class Macros {
+    // @factory
+
+    private Macros() {
+    }
+
+    /** Renvoie un nombre entier aléatoire uniformément distribué entre deux valeurs (maximum inclus).
+     */
+    public static int random(int min, int max) {
+        return (int) Math.floor(min + (max - min) * Math.random());
+    }
+
+    /** Renvoie true si deux chaînes de caratères sont égales, faux sinon.
+     * @param string1 L'une des chaînes à comparer.
+     * @param string2 L'autre des chaînes à comparer.
+     */
+    public static boolean equal(String string1, String string2) {
+        return string1.equals(string2);
+    }
+
+    /** Renvoie le temps actuel en milli-secondes.
+     * @return Renvoie la différence, en millisecondes, entre le temps actuel et celui du 1 Janvier 2000, minuit, en utilisant le temps universel coordonné.
+     */
+    public static double now() {
+        return System.currentTimeMillis() - offset;
+    }
+    private static long offset;
+
+    static {
+        Calendar ref = Calendar.getInstance();
+        ref.set(2000, 0, 1, 0, 0, 0);
+        offset = ref.getTimeInMillis();
+    }
+
+    /** Temporise une durée fixée.
+     * Cela permet aussi de mettre à jour l'affichage.
+     * @param delay Durée d'attente en milli-secondes.
+     */
+    public static void sleep(int delay) {
+        try {
+            if (delay > 0) {
+                Thread.sleep(delay);
+            } else {
+                Thread.sleep(0, 10000);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException("Programme arrêté !");
+        }
+    }
+
+  /** Excécute une routine à un intervalle régulier.
+   * Exemple d'usage (impression de 10 messages à interval d'1 sec. puis arrêt):<pre>
+   * sample(1000, new Runnable() { public void run() {
+   *    if (count &lt; 10) {
+   *      println("Et de "+(++count)+" !");	
+   *    } else throw new RuntimeException("done!"); 
+   *  }
+   *  int count = 0;
+   * });</pre>
+   * <p> Noter que le runnable doit être interrompu par le jet d'une exception, sinon il tournera sans relâche jusqu'à la fermeture de javascool.
+   * @param delay Période d'échantillonage en milli-secondes.
+   * @param runnable Le code à exécuter à chaque appel.
+   */
+  public static void sample(int delay, Runnable runnable) {
+    Sampler sampler = new Sampler().setDelay(delay).setRunnable(runnable);
+    sampler.start();
+  }
+
+  /** Vérifie une assertion et arrête le code si elle est fausse.
+   * Le diagnoctic apparait sous la forme:
+   *<pre>Arrêt du programme :{
+   *  L'assertion(«<i>message</i>») est fausse.
+   *  Pile d'exécution: {
+   *   <i>fonctions appellées et ligne de code correspondant</i>
+   *  }
+   *  Objet en cause:{
+   *     class = «<i>type de l'objet</i>»
+   *     value = «<i>valeur de l'objet</i>»
+   *  }
+   *}</pre>
+   * @param condition Si la condition n'est pas vérifiée, le code JavaScool va s'arrêter.
+   * @param message Un message s'imprime sur la console pour signaler l'erreur.
+   * @param object Si l'objet n'est pas null, donne des renseignements sur l'objet
+   */
+  public static void assertion(boolean condition, String message, Object object) {
+    System.err.println("#" + condition + " : " + message +" ::"+object);
+    if (!condition) {
+      System.out.println("Arrêt du programme :{\n  L'assertion(«"+message+"») est fausse.\n  Pile d'exécution: {");
+      // Sortie de la pile,
+      // - moins les deux appels getStackTrace() et assertion() et
+      // - moins les trois appels run() du bas de pile qui ont lancés la proglet
+      {
+	StackTraceElement where[] = Thread.currentThread().getStackTrace();
+	for(int i = 2; i < where.length -3; i++)
+	  System.out.println("     "+where[i].toString().replaceAll("JvsToJavaTranslated[0-9]+\\.", "").replaceAll("java:([0-9]+)", "ligne : $1"));
+      }
+      System.out.println("  }");
+      if (object != null)
+	System.out.println("  Objet en cause:{\n    class = «"+object.getClass()+"»\n    value = «"+object+"»\n  }");
+      System.out.println("}");
+      org.javascool.core.ProgletEngine.getInstance().doStop();
+      Macros.sleep(500);
+    }
+  }
+    /**
+     * @see #assertion(boolean, String, Object)
+     */
+  public static void assertion(boolean condition, String message) {
+    assertion(condition, message, null);
+  }
+
+    /** Affiche un message dans une fenêtre présentée à l'utilisateur.
+     * <p>Le message s'affiche sous une forme "copiable" pour que l'utilisateur puisse le copier/coller.</p>
+     * @param text Le message à afficher.
+     * @param html Mettre à true si le texte est en HTML, false sinon (valeur par défaut)
+     */
+    public static void message(String text, boolean html) {
+        JEditorPane p = new JEditorPane();
+        p.setEditable(false);
+        p.setOpaque(false);
+        if (html)
+            p.setContentType("text/html; charset=utf-8");
+        p.setText(text);
+        p.setBackground(new java.awt.Color(200, 200, 200, 0));
+        messageDialog = new Dialog();
+        messageDialog.setTitle("Java's Cool message");
+	messageDialog.setMinimumSize(new Dimension(300, 100));
+        messageDialog.add(p);
+        messageDialog.add(new JButton("OK") {
+        {
+           addActionListener(new ActionListener() {
+                    @Override
+                    public void actionPerformed(ActionEvent e) {
+                        messageDialog.close();
+                    }
+                });
+            }
+        }, BorderLayout.SOUTH);
+        messageDialog.open(!SwingUtilities.isEventDispatchThread());
+    }
+    private static Dialog messageDialog;
+
+    /**
+     * @see #message(String, boolean)
+     */
+    public static void message(String text) {
+        message(text, false);
+    }
+
+    /** Renvoie une icone stockée dans le JAR de l'application.
+     * @param path Emplacement de l'icone, par exemple <tt>"org/javascool/widget/icons/play.png"</tt>
+     * @return L'icone chargée ou null si elle n'existe pas.
+     */
+    public static ImageIcon getIcon(String path) {
+      URL icon = getResourceURL(path); // Thread.currentThread().getContextClassLoader().getResource(path);
+        if (icon == null) {
+            System.err.println("Warning : getIcon(" + path + ") not found");
+        }
+        return icon == null ? null : new ImageIcon(icon);
+    }
+
+    /** Ouvre une URL (Universal Resource Location) dans un navigateur extérieur.
+     * @param location L'URL à afficher.
+     *
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
+     */
+    public static void openURL(String location) {
+        try {
+          if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
+            Desktop.getDesktop().browse(new java.net.URI(location));
+            System.err.println("Note: Ouverture de " + location + " dans un navigateur externe");
+          } else {
+              openURL2(location);
+          }
+        } catch (Throwable th) {
+            openURL2(location);
+        }
+    }
+    // Procédure de secours pour ouvrir une URL
+    private static void openURL2(String location) {
+     System.err.println("Note: Ouverture de " + location + " dans un browser navigateur (methode de secours)");
+                String url = location;
+                String os = System.getProperty("os.name").toLowerCase();
+                Runtime rt = Runtime.getRuntime();
+                try {
+                    if (os.indexOf("win") >= 0) {
+                        rt.exec("rundll32 url.dll,FileProtocolHandler " + url);
+                    } else if (os.indexOf("mac") >= 0) {
+                        rt.exec("open " + url);
+                    } else if (os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0) {
+                        // Do a best guess on unix until we get a platform independent way
+                        // Build a list of browsers to try, in this order.
+                        String[] browsers = {"epiphany", "firefox", "mozilla", "konqueror",
+                            "netscape", "opera", "links", "lynx"};
+                        // Build a command string which looks like "browser1 "url" || browser2 "url" ||..."
+                        StringBuilder cmd = new StringBuilder();
+                        for (int i = 0; i < browsers.length; i++) {
+                            cmd.append(i == 0 ? "" : " || ").append(browsers[i]).append(" \"").append(url).append("\" ");
+                        }
+                        rt.exec(new String[]{"sh", "-c", cmd.toString()});
+                    } else {
+                        throw new RuntimeException("Erreur (pas d'OS détecté) à l'ouverture dans un navigateur de " + location);
+                    }
+            } catch (Exception e) {
+                throw new RuntimeException("Erreur (" + e + ") à l'ouverture dans un navigateur de " + location);
+            }
+    }
+    /** Renvoie une URL (Universal Resource Location) normalisée, dans le cas du système de fichier local ou d'une ressource.
+     * <p>La fonction recherche l'existence du fichier:
+     * (i) par rapport au répertoire de base qui est donné,
+     * (ii) par rapport au dossier de travaul "user.dir",
+     * (iii) par rapport à la racine des fichier "user.home",
+     * (iv) dans les ressources du CLASSPATH.</p>
+     * @param location L'URL à normaliser.
+     * @param base     Un répertoire de réference pour la normalisation. Par défaut null.
+     * @param reading  Précise si nous sommes en lecture (true) ou écriture (false). Par défaut en lecture.
+     * @throws IllegalArgumentException Si l'URL est mal formée.
+     */
+    public static URL getResourceURL(String location, String base, boolean reading) {
+        if (base != null) {
+            location = base + "/" + location;
+        }
+        try {
+            // @patch : ceci blinde un bug sur les URL jar
+            if (location.matches("jar:[^!]*!.*")) {
+                String res = location.replaceFirst("[^!]*!/", "");
+                URL url = Thread.currentThread().getContextClassLoader().getResource(res);
+                if (url != null) {
+                    return url;
+                } else {
+                    throw new IllegalArgumentException("Unable to find " + res + " from " + location + " as a classpath resource");
+                }
+            }
+            if (location.matches("(ftp|http|https|jar|mailto|stdout):.*")) {
+                return new URL(location).toURI().normalize().toURL();
+            }
+            if (location.startsWith("file:")) {
+                location = location.substring(5);
+            }
+            if (reading) {
+                File file = new File(location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                file = new File(System.getProperty("user.dir"), location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                file = new File(System.getProperty("user.home"), location);
+                if (file.exists()) {
+                    return new URL("file:" + file.getCanonicalPath());
+                }
+                URL url = Thread.currentThread().getContextClassLoader().getResource(location);
+                if (url != null) {
+                    return url;
+                }
+            }
+            return new URL("file:" + location);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+        }
+    }
+
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location, String base) {
+        return getResourceURL(location, base, true);
+    }
+
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location, boolean reading) {
+        return getResourceURL(location, null, reading);
+    }
+    /**
+     * @see #getResourceURL(String, String, boolean)
+     */
+    public static URL getResourceURL(String location) {
+        return getResourceURL(location, null, true);
+    }
+    /** Renvoie le panneau graphique de la proglet courante.
+     * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
+     */
+    public static < T extends Component> T getProgletPane() {
+        Component c = null;
+        try {
+            c = ProgletEngine.getInstance().getProglet().getProgletPane();
+        } catch (Throwable e) {
+            c = PanelApplet.getPane();
+        }
+        return (T) c;
+    }
+}
Index: src/org/javascool/macros/memo-macros.htm
===================================================================
--- src/org/javascool/macros/memo-macros.htm	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/memo-macros.htm	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,257 @@
+
+<!DOCTYPE html
+  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+   <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+   
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+      <title>Memorandum des constructions et instructions</title>
+   </head>
+   <body>
+      <h1>Memorandum des constructions et instructions.</h1>
+      
+      <div align="right" class="margin">Dominique Larrieu, lyc&eacute;e Simone Veil, Valbonne</div>
+        
+      <div>
+         <h2>Programme principal.</h2>Il se note <b><font color="#990000"><b>void main</b></font>{ }</b> avec les instructions d&eacute;finies entre <b>{ }</b>.
+      </div>
+        
+      <div>
+         <h2>Type de donn&eacute;es utilis&eacute;es.</h2>
+         <ul class="ul">
+                
+            <li><font color="#990000"><b>String</b></font> Cha&icirc;ne de caract&egrave;res (ex: <b><font color="#990000"><b>String</b></font> nom = <font color="#008000">"Dupond"</font>;</b>).
+            </li>
+                
+            <li><font color="#990000"><b>int</b></font> Entier positif ou n&eacute;gatif, de environ -2 &agrave; +2 milliards (ex: <b><font color="#990000"><b>int</b></font> n = <font color="#008000">"8"</font>;</b>).
+            </li>
+                
+            <li><font color="#990000"><b>double</b></font> Nombre d&eacute;cimal, comme sur une calculette (ex:<b><font color="#990000"><b>double</b></font> pi = 3.1416;</b>).
+               <div class="code">
+                  <table witdh="90%" border="1" align="center">
+                     <tr>
+                        <td>
+                           <div class="code">
+                                  
+                              <p><tt><font color="#202080"><big>//</big>&nbsp;Les nombres d&eacute;cimaux se notent avec un "." point et non une virgule !</font></tt></p>
+                                  
+                              <p><tt><font color="#202080"><big>//</big>&nbsp;Les nombres en notation scientifique (par exemple 6.023 1023) se note avec un "e" (pour exposant) : ici <tt>6.023e23</tt></font></tt></p>
+                                  
+                           </div>
+                        </td>
+                     </tr>
+                  </table>
+               </div>
+            </li>
+                
+            <li><font color="#990000"><b>boolean</b></font> Valeur vraie ou fausse, utilis&eacute;e dans les tests (ex:<b><font color="#990000"><b>boolean</b></font> b = x &gt; 0;</b>).
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Quelques fonctions utilis&eacute;es..</h2>
+         <ul class="ul">
+                
+            <li><b>sleep(1000);</b> Arr&ecirc;te l'ex&eacute;cution du programme pendant 1000 milli-secondes.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> x = random();</b> Renvoie dans la variable <b>x</b> un nombre al&eacute;atoire d&eacute;cimal compris entre 0 et 1.
+            </li>
+                
+            <li><b><font color="#990000"><b>int</b></font> n = random(1, 6);</b> Renvoie dans la variable <b>n</b> un nombre al&eacute;atoire entier entre 1 et 6.
+            </li>
+                
+            <li><b><font color="#990000"><b>boolean</b></font> y = equal("Dupond", "Dupont");</b> Compare les deux cha&icirc;nes de carat&egrave;res &laquo;&nbsp;Dupond&nbsp;&raquo; et &laquo;&nbsp;Dupont&nbsp;&raquo; et renvoie dans la variable <b>y</b> la valeur <b>false</b>.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> z = pow(x, 2);</b> Renvoie dans la variable <b>y</b> le carr&eacute; <b>x&sup2;</b>.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> x = sqrt(x);</b> Renvoie dans la variable <b>x</b> la racine de <b>x</b>.
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Fonctions de lecture/&eacute;criture:.</h2>
+         <ul class="ul">
+                
+            <li><b>clear();</b> Efface l&#8217;affichage.
+            </li>
+                
+            <li><b><font color="#990000"><b>String</b></font> prenom = readString();</b> Lit une cha&icirc;ne de carat&egrave;res dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b><font color="#990000"><b>int</b></font> age = readInteger();</b> Lit un nombre entier dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b><font color="#990000"><b>double</b></font> taille = readDouble();</b> Lit un nombre d&eacute;cimal dans la ligne d'entr&eacute;e au clavier.
+            </li>
+                
+            <li><b>println("Oh");</b> Ecrit &laquo;Oh&raquo; dans la fen&ecirc;tre de sortie.
+            </li>
+                
+            <li><b>println("Oh," + age + " ans , est un bel &acirc;ge !");</b> Ecrit &laquo;&nbsp;Oh, 20 ans, est un bel &acirc;ge&nbsp;!&nbsp;&raquo; (quand age=20).
+            </li>
+              
+         </ul>
+      </div>
+        
+      <div>
+         <h2>Bloc de s&eacute;quences d'instructions.</h2> Un bloc se note entre <b>{ }</b> et englobe un ensemble de d&eacute;clarations et d'instructions s&eacute;par&eacute;es par un <b>;</b>.
+      </div>
+        
+      <div>
+         <h2>Op&eacute;rateurs.</h2>
+         <p>
+            <table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee" class="table">
+                   
+               <tr>
+                  <td valign="top"><tt>=</tt></td>
+                  <td valign="top">Affectation d'une valeur &agrave; une variable (ex: <b>x = 0;</b>)
+                  </td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>||</tt> <tt>&amp;&amp;</tt> <tt>!</tt></td>
+                  <td valign="top">Op&eacute;rateur logique OU, ET et NON</td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>==</tt> <tt>!=</tt> <tt>&lt;=</tt> <tt>&lt;</tt> <tt>&gt;=</tt> <tt>&gt;</tt> 
+                  </td>
+                  <td valign="top">Op&eacute;rateur &eacute;galit&eacute;, diff&eacute;rence et comparaison num&eacute;rique</td>
+               </tr>
+                   
+               <tr>
+                  <td valign="top"><tt>+</tt> <tt>-</tt> <tt>*</tt> <tt>/</tt> <tt>%</tt> 
+                  </td>
+                  <td valign="top">Addition, soustraction, multiplication, division, reste (appel&eacute; aussi modulo).</td>
+               </tr>
+                 
+            </table><br></p>
+      </div>
+        
+      <div>
+         <h2>Instruction conditionnelle.</h2>
+             
+         <div><b><font color="#990000"><b>if</b></font> (expressionBooleenne) { BlocD'InstructionsSiVrai } <font color="#990000"><b>else</b></font> { BlocD'InstructionsSiFaux }</b></div>
+             
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                               
+                           <div><font color="#990000"><b>if</b></font>(temp&eacute;rature&nbsp;&lt;&nbsp;15) {
+                           </div>
+                               
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"allumer chauffage"</font>);
+                           </div>
+                               
+                           <div>}&nbsp;<font color="#990000"><b>else</b></font>&nbsp;{
+                           </div>
+                               
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"ne rien faire"</font>);
+                           </div>
+                               
+                           <div>}</div>
+                             
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+        
+      <div>
+         <h2>Boucle.</h2>
+             
+         <div><b><font color="#990000"><b>while</b></font> (expressionBool&eacute;enne) { BlocD'Instructions }</b></div>
+             
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                            &nbsp;     
+                           <div><font color="#990000"><b>while</b></font>( n &lt; 10) {
+                           </div>
+                               &nbsp;&nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>println</b></font>(<font color="#008000">"Hello World !"</font>);
+                           </div>
+                               &nbsp;&nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              n = n + 1;
+                           </div>
+                           &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 
+                           <div>}</div>
+                              
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+         
+      <div>
+         <h2>D&eacute;claration de fonction.</h2>
+              
+         <div><b>TypeDuResultat NomDeLaFonction (TypeParametre1 NomParametre1, ...) { BlocD'Instructions }</b></div> 
+              
+         <div>
+            <h3>Exemple:.</h3>
+            <div class="code">
+               <table witdh="90%" border="1" align="center">
+                  <tr>
+                     <td>
+                        <div class="code">
+                                  
+                           <div><font color="#990000"><b>int</b></font> max(int x, int y) {
+                           </div>
+                                  
+                           <div><font color="#990000"><b>if</b></font> (x &gt; y) {
+                           </div>
+                                &nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>return</b></font> x;
+                           </div> 
+                                  
+                           <div>}&nbsp;<font color="#990000"><b>else</b></font>&nbsp;{
+                           </div>     &nbsp;
+                                &nbsp;&nbsp;
+                           <div>
+                              &nbsp;&nbsp;&nbsp;
+                              <font color="#990000"><b>return</b></font> y;
+                           </div> 
+                                  
+                           <div>} }</div>
+                              
+                        </div>
+                     </td>
+                  </tr>
+               </table>
+            </div>
+         </div>
+      </div>
+      
+   </body>
+</html>
\ No newline at end of file
Index: src/org/javascool/macros/package.html
===================================================================
--- src/org/javascool/macros/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les fonctions statiques qui servent de macros aux programmes Jvs.</body>
+
Index: src/org/javascool/macros/memo-macros.xml
===================================================================
--- src/org/javascool/macros/memo-macros.xml	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/macros/memo-macros.xml	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,63 @@
+<div title="Memorandum des constructions et instructions">
+  <div class="margin">Dominique Larrieu, lycée Simone Veil, Valbonne</div>
+  <div title="Programme principal">Il se note <b><r>void main</r>{ }</b> avec les instructions définies entre <b>{ }</b>.</div>
+  <div title="Type de données utilisées"><div class="ul">
+    <div><r>String</r> Chaîne de caractères (ex: <b><r>String</r> nom = <v>Dupond</v>;</b>).</div>
+    <div><r>int</r> Entier positif ou négatif, de environ -2 à +2 milliards (ex: <b><r>int</r> n = <v>8</v>;</b>).</div>
+    <div><r>double</r> Nombre décimal, comme sur une calculette (ex:<b><r>double</r> pi = 3.1416;</b>).<div class="code">
+    <m>Les nombres décimaux se notent avec un "." point et non une virgule !</m>
+    <m>Les nombres en notation scientifique (par exemple 6.023 1023) se note avec un "e" (pour exposant) : ici <c>6.023e23</c></m>
+    </div></div>
+    <div><r>boolean</r> Valeur vraie ou fausse, utilisée dans les tests (ex:<b><r>boolean</r> b = x > 0;</b>).</div>
+  </div></div>
+  <div title="Quelques fonctions utilisées."><div class="ul">
+    <p><b>sleep(1000);</b> Arrête l'exécution du programme pendant 1000 milli-secondes.</p>
+    <p><b><r>double</r> x = random();</b> Renvoie dans la variable <b>x</b> un nombre aléatoire décimal compris entre 0 et 1.</p>
+    <p><b><r>int</r> n = random(1, 6);</b> Renvoie dans la variable <b>n</b> un nombre aléatoire entier entre 1 et 6.</p>
+    <p><b><r>boolean</r> y = equal("Dupond", "Dupont");</b> Compare les deux chaînes de caratères « Dupond » et « Dupont » et renvoie dans la variable <b>y</b> la valeur <b>false</b>.</p>
+    <p><b><r>double</r> z = pow(x, 2);</b> Renvoie dans la variable <b>y</b> le carré <b>x²</b>.</p>
+    <p><b><r>double</r> x = sqrt(x);</b> Renvoie dans la variable <b>x</b> la racine de <b>x</b>.</p>
+  </div></div>
+  <div title="Fonctions de lecture/écriture:"><div class="ul">
+    <p><b>clear();</b> Efface l’affichage.</p>
+    <p><b><r>String</r> prenom = readString();</b> Lit une chaîne de caratères dans la ligne d'entrée au clavier.</p>
+    <p><b><r>int</r> age = readInteger();</b> Lit un nombre entier dans la ligne d'entrée au clavier.</p>
+    <p><b><r>double</r> taille = readDouble();</b> Lit un nombre décimal dans la ligne d'entrée au clavier.</p>
+    <p><b>println("Oh");</b> Ecrit «Oh» dans la fenêtre de sortie.</p>
+    <p><b>println("Oh," + age + " ans , est un bel âge !");</b> Ecrit « Oh, 20 ans, est un bel âge ! » (quand age=20).</p>
+  </div></div>
+  <div title="Bloc de séquences d'instructions"> Un bloc se note entre <b>{ }</b> et englobe un ensemble de déclarations et d'instructions séparées par un <b>;</b>.</div>
+  <div title="Opérateurs"><div class="table">
+    <div><div><c>=</c></div><div>Affectation d'une valeur à une variable (ex: <b>x = 0;</b>)</div></div>
+    <div><div><c>||</c> <c>&amp;&amp;</c> <c>!</c></div><div>Opérateur logique OU, ET et NON</div></div>
+    <div><div><c>==</c> <c>!=</c> <c>&lt;=</c> <c>&lt;</c> <c>&gt;=</c> <c>&gt;</c> </div><div>Opérateur égalité, différence et comparaison numérique</div></div>
+    <div><div><c>+</c> <c>-</c> <c>*</c> <c>/</c> <c>%</c> </div><div>Addition, soustraction, multiplication, division, reste (appelé aussi modulo).</div></div>
+  </div></div>
+  <div title="Instruction conditionnelle">
+    <p><b><r>if</r> (expressionBooleenne) { BlocD'InstructionsSiVrai } <r>else</r> { BlocD'InstructionsSiFaux }</b></p>
+    <div title="Exemple:"><div class="code">
+    <p><r>if</r>(température &lt; 15) {</p>
+    <p><T/><r>println</r>(<v>allumer chauffage</v>);</p>
+    <p>} <r>else</r> {</p>
+    <p><T/><r>println</r>(<v>ne rien faire</v>);</p>
+    <p>}</p>
+  </div></div></div>
+  <div title="Boucle">
+    <p><b><r>while</r> (expressionBooléenne) { BlocD'Instructions }</b></p>
+    <div title="Exemple:"><div class="code">
+       <p><r>while</r>( n &lt; 10) {</p>
+       <p><T/><r>println</r>(<v>Hello World !</v>);</p>
+       <p><T/>n = n + 1;</p>
+       <p>}</p>
+   </div></div></div>
+   <div title="Déclaration de fonction">
+     <p><b>TypeDuResultat NomDeLaFonction (TypeParametre1 NomParametre1, ...) { BlocD'Instructions }</b></p> 
+     <div title="Exemple:"><div class="code">
+       <p><r>int</r> max(int x, int y) {</p>
+       <p><r>if</r> (x > y) {</p>
+       <p><T/><r>return</r> x;</p> 
+       <p>} <r>else</r> {</p>      
+       <p><T/><r>return</r> y;</p> 
+       <p>} }</p>
+   </div></div></div>
+</div>
Index: src/org/javascool/gui/JVSStartPanel.java
===================================================================
--- src/org/javascool/gui/JVSStartPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSStartPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,118 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.javascool.gui;
+
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.GridLayout;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import javax.swing.Box;
+import javax.swing.BoxLayout;
+import javax.swing.ImageIcon;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.ToolTipManager;
+import org.javascool.core.ProgletEngine;
+import org.javascool.macros.Macros;
+
+/** Ecran d'accueil de Java's cool
+ * Il présente toutes les activités présentes dans le jar sous la forme d'un
+ * panneau d'icones avec le nom des proglets respectives.
+ * @see org.javascool.core.ProgletEngine
+ */
+class JVSStartPanel extends JScrollPane {
+
+    private static final long serialVersionUID = 1L;
+    private static JVSStartPanel jvssp;
+
+    public static JVSStartPanel getInstance() {
+        if (jvssp == null) {
+            jvssp = new JVSStartPanel(JVSStartPanel.shortcutPanel());
+        }
+        return jvssp;
+    }
+
+    private JVSStartPanel(JPanel panel) {
+        super(panel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
+        ToolTipManager.sharedInstance().setInitialDelay(75);
+    }
+
+    /** Dessine le JPanel en listant les proglets
+     * @see ProgletEngine
+     * @return Le JPanel dessiné
+     */
+    private static JPanel shortcutPanel() {
+        JPanel shortcuts = new JPanel();
+        int i=0;
+        for (ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets()) {
+            i++;
+        }
+        shortcuts.setLayout(new GridLayout(0, (i/3)==0?1:(i/3)));
+        for (ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets()) {
+            shortcuts.add(JVSStartPanel.createShortcut(Macros.getIcon(proglet.getIcon()), proglet.getName(), proglet.getTitle(), new ProgletLoader(proglet.getName())));
+        }
+        return shortcuts;
+    }
+
+    /** Cette classe permet de lançer une Proglet */
+    private static
+            class ProgletLoader implements Runnable {
+
+        private String proglet;
+
+        ProgletLoader(String proglet) {
+            this.proglet = proglet;
+        }
+
+        @Override
+        public void run() {
+            JVSPanel.getInstance().loadProglet(proglet);
+        }
+    }
+
+    /** Créer un pannel avec un bouton capâble de lançer la Proglet */
+    private static JPanel createShortcut(ImageIcon icon, String name, String title, final Runnable start) {
+        JPanel panel = new JPanel();
+        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
+        panel.add(Box.createVerticalGlue());
+        JButton label = new JButton(name, icon);
+        // Affichage du titre dans le charset de l'ordinateur
+        label.setToolTipText(title);
+        label.setPreferredSize(new Dimension(160, 160));
+        label.setVerticalTextPosition(JLabel.BOTTOM);
+        label.setHorizontalTextPosition(JLabel.CENTER);
+        label.setAlignmentX(Component.CENTER_ALIGNMENT);
+        label.setAlignmentY(Component.CENTER_ALIGNMENT);
+        panel.add(label);
+        panel.add(Box.createVerticalGlue());
+        label.addMouseListener(new MouseListener() {
+
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                start.run();
+            }
+
+            @Override
+            public void mousePressed(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseReleased(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseEntered(MouseEvent e) {
+            }
+
+            @Override
+            public void mouseExited(MouseEvent e) {
+            }
+        });
+        return panel;
+    }
+}
\ No newline at end of file
Index: src/org/javascool/gui/JVSPanel.java
===================================================================
--- src/org/javascool/gui/JVSPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,405 @@
+package org.javascool.gui;
+
+import java.awt.BorderLayout;
+import java.io.Console;
+import java.io.File;
+import java.util.HashMap;
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.UIManager;
+import org.javascool.core.ProgletEngine;
+import org.javascool.tools.UserConfig;
+
+/** The main panel for Java's cool
+ * This class wich is very static contain all that we need to run Java's cool like save and open file command.
+ * This class can only be called by JVSPanel on instance otherwise it can throw very big errors
+ *
+ * @author Philippe Vienne
+ */
+class JVSPanel extends JPanel {
+    // Empeche de pouvoir renommer itempestivement des folder
+    static {
+    UIManager.put("FileChooser.readOnly", Boolean.TRUE);
+    }
+
+    private static final long serialVersionUID = 1L;
+    /** This HashMap say if a file has to be saved */
+    HashMap<String, Boolean> haveToSave = new HashMap<String, Boolean>();
+    private Boolean noFileEdited = true;
+
+    /** Access to the unique instance of the JVSPanel object. */
+    public static JVSPanel getInstance() {
+        if (desktop == null) {
+            desktop = new JVSPanel();
+        }
+        return desktop;
+    }
+    private static JVSPanel desktop = null;
+
+    private JVSPanel() {
+        setVisible(true);
+        setLayout(new BorderLayout());
+        add(JVSStartPanel.getInstance());
+        this.revalidate();
+    }
+
+    public void closeProglet() {
+        if (closeAllFiles()) {
+            this.removeAll();
+            this.setOpaque(true);
+            this.repaint();
+            this.validate();
+            this.repaint();
+            add(JVSStartPanel.getInstance());
+            this.repaint();
+            this.revalidate();
+            this.repaint();
+        if (ProgletEngine.getInstance().getProglet() != null)
+           ProgletEngine.getInstance().getProglet().stop();
+        }
+    }
+
+    /** Open a new file in the editor
+     * @see JVSFileTabs
+     */
+    public void newFile() {
+        String fileId = JVSFileTabs.getInstance().openNewFile();
+        haveToSave.put(fileId, false);
+    }
+
+    /** Compile file in the editor
+     * @see JVSFileTabs
+     */
+    public void compileFile() {
+        JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).removeLineSignals();
+        if (JVSFileTabs.getInstance().saveCurrentFile()) {
+            JVSWidgetPanel.getInstance().focusOnConsolePanel();
+            if (JVSFileTabs.getInstance().compileFile(JVSFileTabs.getInstance().getCurrentFileId())) {
+                JVSToolBar.getInstance().enableStartStopButton();
+            } else {
+                JVSToolBar.getInstance().disableStartStopButton();
+            }
+        }
+    }
+
+    /** Open a file
+     * Start a file chooser and open selected file
+     * @see JFileChooser
+     * @see JVSFileTabs
+     */
+    public void openFile() {
+        final JFileChooser fc = new JFileChooser();
+        if (UserConfig.getInstance("javascool").getProperty("dir") != null) {
+            fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool").getProperty("dir")));
+        } else if (System.getProperty("os.name").toLowerCase().contains("nix") || System.getProperty("os.name").toLowerCase().contains("nux")) {
+            fc.setCurrentDirectory(new File(System.getProperty("user.dir")));
+        } else if (System.getProperty("home.dir") != null) {
+            fc.setCurrentDirectory(new File(System.getProperty("home.dir")));
+        }
+        int returnVal = fc.showOpenDialog(Desktop.getInstance().getFrame());
+        if (returnVal == JFileChooser.APPROVE_OPTION) {
+            String path = fc.getSelectedFile().getAbsolutePath();
+            if(!fc.getSelectedFile().exists()){
+                Dialog.error("Erreur", "Le fichier indiqué n'existe pas !!!");
+                return;
+            }
+            UserConfig.getInstance("javascool").setProperty("dir", fc.getSelectedFile().getParentFile().getAbsolutePath());
+            if (noFileEdited) {
+                noFileEdited = false;
+            }
+            String fileId = JVSFileTabs.getInstance().open(path);
+            haveToSave.put(fileId, false);
+        } else {
+        }
+    }
+
+    /** Save the current file
+     * @see JVSFileTabs
+     * @see JVSFile
+     */
+    public boolean saveFile() {
+        if (JVSFileTabs.getInstance().saveCurrentFile()) {
+            haveToSave.put(JVSFileTabs.getInstance().getCurrentFileId(), false);
+            return true;
+        }
+        return false;
+    }
+
+    /** Save the current file
+     * @see JVSFileTabs
+     * @see JVSFile
+     */
+    public boolean saveAsFile() {
+        if (JVSFileTabs.getInstance().saveAsCurrentFile()) {
+            haveToSave.put(JVSFileTabs.getInstance().getCurrentFileId(), false);
+            return true;
+        }
+        return false;
+    }
+
+    /** Close the current file
+     * @see JVSFileTabs
+     */
+    public void closeFile() {
+        if (haveToSave.get(JVSFileTabs.getInstance().getCurrentFileId())) {
+            if (saveFileIdBeforeClose(JVSFileTabs.getInstance().getCurrentFileId()) == 1) {
+                JVSFileTabs.getInstance().closeFile(JVSFileTabs.getInstance().getCurrentFileId());
+            }
+        } else {
+            JVSFileTabs.getInstance().closeFile(JVSFileTabs.getInstance().getCurrentFileId());
+        }
+        if (JVSFileTabs.getInstance().getOppenedFileCount() == 0) {
+            newFile();
+        }
+    }
+
+    /** Update haveToSave for a file
+     * Set it to true
+     * @param fileId The file id
+     */
+    public void mustSave(String fileId) {
+        noFileEdited = false;
+        haveToSave.put(fileId, true);
+    }
+
+    /** Update haveToSave for a file
+     * Set it to true
+     * @param fileId The file id
+     */
+    public void haveNotToSave(String fileId) {
+        haveToSave.put(fileId, false);
+    }
+
+    public Boolean getHasToSave(String fileId) {
+        return haveToSave.get(fileId);
+    }
+
+    /** Show a compile error for an human
+     * Open a dialog with compile error explains and hightlight the error line
+     * @param line The line error
+     * @param explication Human explain for that error
+     * @see Console
+     */
+    public void reportCompileError(int line, String explication) {
+        org.javascool.widgets.Console.getInstance().clear();
+        JVSWidgetPanel.getInstance().focusOnConsolePanel();
+        if (JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()) != null) {
+            JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).signalLine(line);
+        }
+    }
+
+    /** Handle the close application task
+     * Check if all files are saved and if the user want to close the application
+     * @return True mean that app can be close and false that app can NOT be closed
+     */
+    public Boolean close() {
+        String id = "";
+        Boolean[] can_close = new Boolean[haveToSave.keySet().toArray().length];
+        int i = 0;
+        int j = 0;
+        for (Object fileId : haveToSave.keySet().toArray()) {
+            if (haveToSave.get((String) fileId)) {
+                j++;
+            }
+        }
+        // If user no have dialog to stop close, we create one
+        if (j == 0) {
+            final int n = JOptionPane.showConfirmDialog(
+                    Desktop.getInstance().getFrame(),
+                    "Voulez vous vraiment quitter Java's cool ?",
+                    "Confirmation",
+                    JOptionPane.YES_NO_OPTION);
+            if (n == JOptionPane.YES_OPTION) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+        j = 0;
+        // Check save for each file
+        for (Object fileId : haveToSave.keySet().toArray()) {
+            id = (String) fileId;
+            if (haveToSave.get(id)) {
+                // File has to be saved
+                // For number see saveFileIdBeforeClose() documentation about return
+                switch (saveFileIdBeforeClose(id)) {
+                    case 1:
+                        can_close[i] = true;
+                        break;
+                    case 0:
+                        can_close[i] = false;
+                        break;
+                    case -1:
+                        return false;
+                }
+                j++;
+            } else // If file has not to be saved it's good
+            {
+                can_close[i] = true;
+            }
+            if (can_close[i]) // If we can close this file, we close the tab
+            {
+                JVSFileTabs.getInstance().closeFile(id);
+            }
+            i++;
+        }
+        // Check if a file is not save, if yes we can not close the application
+        for (Boolean can_close_r : can_close) {
+            if (can_close_r == false) {
+                return false;
+            }
+        }
+        // We return true if all is good
+        return true;
+    }
+
+    /** Handle the close file task
+     * Check if all files are saved and if the user want to continue
+     * @return True meen that app can be close and false that app can NOT be closed
+     */
+    public Boolean closeAllFiles() {
+        String id = "";
+        Boolean[] can_close = new Boolean[haveToSave.keySet().toArray().length];
+        int i = 0;
+        int j = 0;
+        for (Object fileId : haveToSave.keySet().toArray()) {
+            if (haveToSave.get((String) fileId)) {
+                j++;
+            } else {
+                JVSFileTabs.getInstance().closeFile((String) fileId);
+            }
+        }
+        // If user no have dialog to stop close, we create one
+        if (j == 0) {
+            final int n = JOptionPane.showConfirmDialog(
+                    Desktop.getInstance().getFrame(),
+                    "Voulez vous vraiment continuer ?",
+                    "Confirmation",
+                    JOptionPane.YES_NO_OPTION);
+            if (n == JOptionPane.YES_OPTION) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+        j = 0;
+        // Check save for each file
+        for (Object fileId : haveToSave.keySet().toArray()) {
+            id = (String) fileId;
+            if (haveToSave.get(id)) {
+                // File has to be saved
+                // For number see saveFileIdBeforeClose() documentation about return
+                switch (saveFileIdBeforeClose(id)) {
+                    case 1:
+                        can_close[i] = true;
+                        break;
+                    case 0:
+                        can_close[i] = false;
+                        break;
+                    case -1:
+                        return false;
+                }
+                j++;
+            } else // If file has not to be saved it's good
+            {
+                can_close[i] = true;
+            }
+            if (can_close[i]) // If we can close this file, we close the tab
+            {
+                JVSFileTabs.getInstance().closeFile(id);
+            }
+            i++;
+        }
+        // Check if a file is not save, if yes we can not close the application
+        for (Boolean can_close_r : can_close) {
+            if (can_close_r == false) {
+                return false;
+            }
+        }
+        // We return true if all is good
+        return true;
+    }
+
+    /** Ask to user to save a file before it close
+     * @param fileId The file id
+     * @return 1 meen that file is saved or that user not want to save the file. 0 meen that there was an error during the save of file. -1 meen that user want to stop all that happend (Cancel option).
+     */
+    public int saveFileIdBeforeClose(String fileId) {
+        JVSFile file = JVSFileTabs.getInstance().getFile(fileId);
+        int result = JOptionPane.showConfirmDialog(
+                Desktop.getInstance().getFrame(),
+                "Voulez vous enregistrer " + file.getName() + " avant de continuer ?");
+        if (result == JOptionPane.YES_OPTION) {
+            if (JVSFileTabs.getInstance().saveFile(fileId)) {
+                haveToSave.put(fileId, false);
+                return 1;
+            } else {
+                return 0;
+            }
+        } else if (result == JOptionPane.NO_OPTION) {
+            return 1;
+        } else {
+            haveToSave.put(fileId, true);
+            return -1;
+        }
+    }
+
+    /** Charge une nouvelle proglet dans l'interface utilisateur.
+     * @param name Le nom de code de la proglet (ex:abcdAlgos)
+     * @see org.javascool.core.ProgletEngine
+     */
+    public void loadProglet(String name) {
+        System.gc();
+        this.removeAll();
+        JVSToolBar.getInstance().disableDemoButton();
+        this.revalidate();
+        this.add(JVSToolBar.getInstance(), BorderLayout.NORTH);
+        this.add(JVSCenterPanel.getInstance(), BorderLayout.CENTER);
+        this.revalidate();
+        JVSCenterPanel.getInstance().revalidate();
+        JVSCenterPanel.getInstance().setDividerLocation(getWidth() / 2);
+        JVSCenterPanel.getInstance().revalidate();
+        JVSWidgetPanel.getInstance().setProglet(name);
+        if (ProgletEngine.getInstance().getProglet().hasDemo()) {
+            JVSToolBar.getInstance().enableDemoButton();
+        } else {
+            JVSToolBar.getInstance().disableDemoButton();
+        }
+        this.newFile();
+    }
+
+    public void reportRuntimeBug(String ex) {
+        StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+        int line = 0;
+        for (StackTraceElement elem : stack) {
+            if (elem.getFileName().startsWith("JvsToJavaTranslated")) {
+                line = elem.getLineNumber();
+            } else {
+                System.err.println(elem.getClassName());
+            }
+        }
+        if (JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()) != null) {
+            JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).signalLine(line);
+        }
+        ProgletEngine.getInstance().doStop();
+        Dialog.error("Erreur du logiciel à la ligne " + line, ex);
+    }
+
+    public void reportApplicationBug(String ex) {
+        Dialog.error("Erreur dans Java's Cool", ex);
+    }
+
+    public static class Dialog {
+
+        /** Show a success dialog */
+        public static void success(String title, String message) {
+            JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(), message, title, JOptionPane.INFORMATION_MESSAGE);
+        }
+
+        /** Show an error dialog */
+        public static void error(String title, String message) {
+            JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(), message, title, JOptionPane.ERROR_MESSAGE);
+        }
+    }
+}
Index: src/org/javascool/gui/JVSFile.java
===================================================================
--- src/org/javascool/gui/JVSFile.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSFile.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,156 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.javascool.gui;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import org.javascool.tools.FileManager;
+
+final class JVSFile {
+  public static String defaultCode = "void main(){\n"
+                                     + "\t\n"
+                                     + "}";
+  private String fileContent;
+  /** The text content of file */
+  private String code;
+  /** The name of the file */
+  private String name;
+  /** The path to the file */
+  private String path;
+  /** The file instance */
+  private File file;
+  /** Proglet liked to this document */
+  private String proglet;
+
+  /** Open a new empty file */
+  public JVSFile() {
+    this("");
+  }
+  /** Open a new file from a text
+   * @param text The text of new file
+   */
+  public JVSFile(String text) {
+    this(text, false);
+  }
+  /** Open a file from an url
+   * Don't forget to put fromurl to true
+   * @param url The url of file
+   * @param fromurl  True for open from an url
+   */
+  public JVSFile(String url, Boolean fromurl) {
+    if(!fromurl) {
+      this.code = url;
+      this.name = "Nouveau fichier";
+      this.path = "";
+      this.proglet = "default";
+      try {
+        this.file = File.createTempFile("JVS_TMPFILE_", ".jvs");
+        this.file.deleteOnExit();
+        this.path = this.file.getAbsolutePath();
+      } catch(IOException ex) { throw new RuntimeException(ex);
+      }
+    } else {
+      File file_to_open = new File(url);
+      this.name = file_to_open.getName();
+      this.path = file_to_open.getAbsolutePath();
+      this.fileContent = FileManager.load(path);
+      if(fileContent.matches("^[ \\t\\n\\r]*@proglet:[A-Za-z]*[\\n\\r]*"))
+        this.proglet = fileContent.replaceAll("^[ \\t\\n\\r]*@proglet:([A-Za-z]*)[\\n\\r]*.*", "$1");
+      this.code = this.fileContent;
+      this.file = file_to_open;
+    }
+    this.refreshData();
+  }
+  /** Check if file is in tempory memory */
+  public Boolean isTmp() {
+    return this.file.getName().startsWith("JVS_TMPFILE_");
+  }
+  /** Save file */
+  public Boolean save() {
+    try {
+      this.refreshData();
+      FileManager.save(this.getPath(), this.code);
+      return true;
+    } catch(Exception e) {
+      return false;
+    }
+  }
+  /** Get the file name
+   * @return the name
+   */
+  public String getName() {
+    return name;
+  }
+  /** Set the file name
+   * @param name the name to set
+   */
+  public void setName(String name) {
+    this.name = name;
+  }
+  /** Get the path to file
+   * @return the path
+   */
+  public String getPath() {
+    return path;
+  }
+  /** Set a new path for the file
+   * Use save() to write the file into the new path
+   * @param path the path to set
+   */
+  public void setPath(String path) {
+    this.path = path;
+    this.file = new File(path);
+  }
+  /** Get the file Instance in memory
+   * @return the file
+   */
+  public File getFile() {
+    return file;
+  }
+  /**
+   * @return the proglet
+   */
+  public String getProglet() {
+    if(this.proglet.equals("default"))
+      return "";
+    return proglet;
+  }
+  /**
+   * @param proglet the proglet to set
+   */
+  public void setProglet(String proglet) {
+    this.proglet = proglet;
+    this.refreshData();
+  }
+  /** Get the code in the file
+   * @return the code
+   */
+  public String getCode() {
+    return code;
+  }
+  /** Set the code
+   * !! WARNING !! It no write the text to the file, it just save it into the object use save() insted.
+   * @param code the text to set
+   */
+  public void setCode(String code) {
+    this.code = code;
+    this.refreshData();
+  }
+  /** Refresh the data to save file */
+  private void refreshData() {
+    String fileToSave = "";
+    fileToSave += this.getCode();
+    this.fileContent = fileToSave;
+  }
+  /** Read a file */
+  public static String readFileAsString(String filePath) throws java.io.IOException {
+    byte[] buffer = new byte[(int) new File(filePath).length()];
+    BufferedInputStream f = new BufferedInputStream(new FileInputStream(filePath));
+    f.read(buffer);
+    return new String(buffer);
+  }
+}
Index: src/org/javascool/gui/JVSCenterPanel.java
===================================================================
--- src/org/javascool/gui/JVSCenterPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSCenterPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,30 @@
+package org.javascool.gui;
+
+import javax.swing.JSplitPane;
+
+/** Le double pannau central de Java's cool
+ * Le JVSCenterPanel est utilisé pour plaçer correctemment le JVSWidgetPanel à
+ * droite et le JVSFileTabs à gauche
+ * @see org.javascool.gui.JVSFileTabs
+ * @see org.javascool.gui.JVSWidgetPanel
+ */
+class JVSCenterPanel extends JSplitPane {
+  private static final long serialVersionUID = 1L;
+  /** L'instance en cour de cette classe */
+  private static JVSCenterPanel jvssplitpane;
+
+  /** Retourne l'instance actuelle de la classe */
+  public static JVSCenterPanel getInstance() {
+    if(jvssplitpane == null)
+      jvssplitpane = new JVSCenterPanel();
+    return jvssplitpane;
+  }
+  /** Constructeur de la classe */
+  private JVSCenterPanel() {
+    super(JSplitPane.HORIZONTAL_SPLIT);
+    this.setLeftComponent(JVSFileTabs.getInstance());
+    this.setRightComponent(JVSWidgetPanel.getInstance());
+    this.setVisible(true);
+    this.validate();
+  }
+}
Index: src/org/javascool/gui/JVSToolBar.java
===================================================================
--- src/org/javascool/gui/JVSToolBar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSToolBar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,160 @@
+package org.javascool.gui;
+
+import org.javascool.core.ProgletEngine;
+
+import org.javascool.widgets.ToolBar;
+import javax.swing.JButton;
+import org.javascool.About;
+import org.javascool.builder.DialogFrame;
+import org.javascool.widgets.StartStopButton;
+import org.javascool.builder.ProgletsBuilder;
+
+/** La barre d'outils de Java's cool
+ * Elle est placée en haut de l'interface. Elle contient les boutons de gestion
+ * des fichiers, de compilation et d'éxecution.
+ * @see org.javascool.widgets.StartStopButton
+ * @see org.javascool.gui.JVSPanel
+ */
+class JVSToolBar extends ToolBar {
+
+    private static final long serialVersionUID = 1L;
+    /** Boutons de l'interface. */
+    private JButton compileButton;
+    private JButton demoButton;
+    private StartStopButton runButton;
+    /** Instance de la classe */
+    private static JVSToolBar jvstb;
+
+    public static JVSToolBar getInstance() {
+        if (jvstb == null) {
+            jvstb = new JVSToolBar();
+        }
+        return jvstb;
+    }
+
+    private JVSToolBar() {
+        setName("Java's cool ToolBar");
+        init();
+    }
+
+    /** Initialize la barre d'outils en créant les bouttons */
+    private void init() {
+        addTool("Nouvelle activité", "org/javascool/widgets/icons/new.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().closeProglet();
+            }
+        });
+        addTool("Nouveau fichier", "org/javascool/widgets/icons/new.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().newFile();
+            }
+        });
+        addTool("Ouvrir un fichier", "org/javascool/widgets/icons/open.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().openFile();
+            }
+        });
+        addTool("Sauver", "org/javascool/widgets/icons/save.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().saveFile();
+            }
+        });
+        addTool("Sauver sous", "org/javascool/widgets/icons/saveas.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().saveAsFile();
+            }
+        });
+
+        compileButton = addTool("Compiler", "org/javascool/widgets/icons/compile.png", new Runnable() {
+
+            @Override
+            public void run() {
+                JVSPanel.getInstance().compileFile();
+            }
+        });
+
+        addTool("Executer", runButton = new StartStopButton() {
+
+            private static final long serialVersionUID = 1L;
+
+            @Override
+            public void start() {
+                JVSWidgetPanel.getInstance().focusOnProgletPanel();
+                ProgletEngine.getInstance().doRun();
+            }
+
+            @Override
+            public void stop() {
+                ProgletEngine.getInstance().doStop();
+            }
+
+            @Override
+            public boolean isRunning() {
+                return ProgletEngine.getInstance().isRunning();
+            }
+        });
+        runButton.setVisible(false);
+        this.demoButton=addTool("Demo", "org/javascool/widgets/icons/play.png", new Runnable() {
+
+                @Override
+                public void run() {
+                    JVSWidgetPanel.getInstance().focusOnProgletPanel();
+                    ProgletEngine.getInstance().getProglet().doDemo();
+                }
+            });
+        demoButton.setVisible(false);
+        // Crée le menu de construction de proglets si pertinent
+        if (ProgletsBuilder.canBuildProglets()) {
+            pbutton = addRightTool("Proglet Builder", new Runnable() {
+
+                @Override
+                public void run() {
+                    DialogFrame.startFrame();
+                }
+            });
+        }
+        this.add(About.getAboutMessage(), 0);
+    }
+    // @ inner-class-variable
+    private JButton pbutton;
+
+    public void enableCompileButton() {
+        compileButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableCompileButton() {
+        compileButton.setVisible(false);
+        revalidate();
+    }
+    
+    public void enableDemoButton() {
+        demoButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableDemoButton() {
+        demoButton.setVisible(false);
+        revalidate();
+    }
+
+    public void enableStartStopButton() {
+        runButton.setVisible(true);
+        revalidate();
+    }
+
+    public void disableStartStopButton() {
+        runButton.setVisible(false);
+        revalidate();
+    }
+}
Index: src/org/javascool/gui/JVSWidgetPanel.java
===================================================================
--- src/org/javascool/gui/JVSWidgetPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSWidgetPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,87 @@
+package org.javascool.gui;
+
+import org.javascool.Core;
+import org.javascool.core.ProgletEngine;
+import org.javascool.core.ProgletEngine.Proglet;
+import org.javascool.macros.Macros;
+import org.javascool.widgets.Console;
+import org.javascool.widgets.HtmlDisplay;
+
+/** Le panneau contenant les widgets
+ * Les widgets de Java's cool sont disposés dans des onglets. Certain onglets de
+ * navigation web peuvent être fermés par une croix.
+ * @see org.javascool.widgets.Console
+ * @see org.javascool.widgets.HtmlDisplay
+ * @see org.javascool.widgets
+ */
+class JVSWidgetPanel extends JVSTabs {
+
+    private static final long serialVersionUID = 1L;
+    private String progletTabId;
+    /** Instance du JVSWidgetPanel */
+    private static JVSWidgetPanel jwp;
+
+    public static JVSWidgetPanel getInstance() {
+        if (jwp == null) {
+            jwp = new JVSWidgetPanel();
+        }
+        return jwp;
+    }
+
+    private JVSWidgetPanel() {
+        super();
+        this.add("Console", "", Console.getInstance());
+    }
+
+    /** Charge les tabs de la proglet
+     * Charge le tab de la proglet (Panel) et l'HTMLDisplay avec le fichier d'aide.
+     * @param name Le nom du package de la proglet
+     */
+    public void setProglet(String name) {
+        this.removeAll();
+        this.add("Console", "", Console.getInstance());
+        Proglet proglet = ProgletEngine.getInstance().setProglet(name);
+        if (proglet.getPane() != null) {
+            this.progletTabId = this.add("Proglet " + name, "", proglet.getPane());
+        }
+        if (proglet.getHelp() != null) {
+            this.add("Aide de la proglet", "", new HtmlDisplay().setPage(Macros.getResourceURL(proglet.getHelp())));
+            this.switchToTab("Aide de la proglet");
+        }
+        HtmlDisplay memo = new HtmlDisplay();
+        memo.setPage(ClassLoader.getSystemResource(Core.help));
+        this.add("Mémo", "", memo);
+    }
+
+    /** Affiche l'onglet de la Proglet si il existe */
+    public void focusOnProgletPanel() {
+        if (progletTabId != null) {
+            this.switchToTab(progletTabId);
+        }
+    }
+
+    /** Affiche la console */
+    public void focusOnConsolePanel() {
+        this.setSelectedIndex(this.indexOfTab("Console"));
+    }
+
+    /** Ouvre un nouvel onglet web
+     * Ouvre un nouveau HTMLDisplay dans un onglet. Cet onglet peut être fermer à
+     * l'aide de la croix qui se situe à droite du titre de l'onglet.
+     * @param url L'url de la page à charger
+     * @param tabName Le titre du tab à ouvrir
+     * @see org.javascool.widgets.HtmlDisplay
+     * @see String
+     */
+    public void openWebTab(String url, String tabName) {
+        if(this.indexOfTab(tabName)>=0){
+            this.switchToTab(tabName);
+            return;
+        }
+        HtmlDisplay memo = new HtmlDisplay();
+        memo.setPage(url);
+        this.add(tabName, "", memo);
+        this.setTabComponentAt(this.indexOfTab(tabName), new TabPanel(this));
+        this.setSelectedComponent(memo);
+    }
+}
Index: src/org/javascool/gui/TabPanel.java
===================================================================
--- src/org/javascool/gui/TabPanel.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/TabPanel.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
+ */
+package org.javascool.gui;
+
+import javax.swing.*;
+import javax.swing.plaf.basic.BasicButtonUI;
+import java.awt.*;
+import java.awt.event.*;
+
+/**
+ * Component to be used as tabComponent;
+ * Contains a JLabel to show the text and
+ * a JButton to close the tab it belongs to
+ */
+class TabPanel extends JPanel {
+
+    private static final long serialVersionUID = 1L;
+    private final JTabbedPane pane;
+    private final String file;
+
+    public TabPanel(final JTabbedPane pane) {
+        this(pane, "");
+    }
+
+    public TabPanel(final JTabbedPane pane, String fileId) {
+        // unset default FlowLayout' gaps
+        super(new FlowLayout(FlowLayout.LEFT, 0, 0));
+        this.file = fileId;
+        if (pane == null) {
+            throw new NullPointerException("TabbedPane is null");
+        }
+        this.pane = pane;
+        setOpaque(false);
+
+        // make JLabel read titles from JTabbedPane
+        JLabel label = new JLabel() {
+
+            private static final long serialVersionUID = 1L;
+
+            @Override
+            public String getText() {
+                int i = pane.indexOfTabComponent(TabPanel.this);
+                if (i != -1) {
+                    return pane.getTitleAt(i);
+                }
+                return null;
+            }
+        };
+
+        add(label);
+        // add more space between the label and the button
+        label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
+        // tab button
+        JButton button = new TabButton();
+        add(button);
+        // add more space to the top of the component
+        setBorder(BorderFactory.createEmptyBorder(2, 0, 0, 0));
+    }
+
+    private class TabButton extends JButton implements ActionListener {
+
+        private static final long serialVersionUID = 1L;
+
+        public TabButton() {
+            int size = 17;
+            setPreferredSize(new Dimension(size, size));
+            setToolTipText("close this tab");
+            // Make the button looks the same for all Laf's
+            setUI(new BasicButtonUI());
+            // Make it transparent
+            setContentAreaFilled(false);
+            // No need to be focusable
+            setFocusable(false);
+            setBorder(BorderFactory.createEtchedBorder());
+            setBorderPainted(false);
+            // Making nice rollover effect
+            // we use the same listener for all buttons
+            addMouseListener(buttonMouseListener);
+            setRolloverEnabled(true);
+            // Close the proper tab by clicking the button
+            addActionListener(this);
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent e) {
+            if(pane.getTabCount()<=1){
+                return;
+            }
+            if (confirmClose()) {
+                int i = pane.indexOfTabComponent(TabPanel.this);
+                if (i != -1) {
+                    pane.remove(i);
+                }
+            }
+        }
+        // we don't want to update UI for this button
+
+        @Override
+        public void updateUI() {
+        }
+        // paint the cross
+
+        @Override
+        protected void paintComponent(Graphics g) {
+            if(pane.getTabCount()<=1){
+                this.setVisible(false);
+                this.revalidate();
+                return;
+            } else {
+                this.setVisible(true);
+                this.revalidate();
+            }
+            super.paintComponent(g);
+            Graphics2D g2 = (Graphics2D) g.create();
+            // shift the image for pressed buttons
+            if (getModel().isPressed()) {
+                g2.translate(1, 1);
+            }
+            g2.setStroke(new BasicStroke(2));
+            g2.setColor(Color.BLACK);
+            if (getModel().isRollover()) {
+                g2.setColor(Color.WHITE);
+            }
+            int delta = 6;
+            g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight() - delta - 1);
+            g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight() - delta - 1);
+            g2.dispose();
+        }
+
+        private boolean confirmClose() {
+            if (pane instanceof JVSFileTabs) {
+                if (!JVSPanel.getInstance().getHasToSave(file)) {
+                    JVSFileTabs.getInstance().closeFile(file);
+                    return true;
+                }
+                if (JVSPanel.getInstance().saveFileIdBeforeClose(file) == 1) {
+                    JVSFileTabs.getInstance().closeFile(file);
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+            if(pane.getTabCount()<=1){
+                return false;
+            }
+            return true;
+        }
+    }
+    private final static MouseListener buttonMouseListener = new MouseAdapter() {
+
+        @Override
+        public void mouseEntered(MouseEvent e) {
+            Component component = e.getComponent();
+            if (component instanceof AbstractButton) {
+                AbstractButton button = (AbstractButton) component;
+                button.setBorderPainted(false);
+            }
+        }
+
+        @Override
+        public void mouseExited(MouseEvent e) {
+            Component component = e.getComponent();
+            if (component instanceof AbstractButton) {
+                AbstractButton button = (AbstractButton) component;
+                button.setBorderPainted(false);
+            }
+        }
+    };
+}
Index: src/org/javascool/gui/Desktop.java
===================================================================
--- src/org/javascool/gui/Desktop.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/Desktop.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,197 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.gui;
+
+import java.io.File;
+import java.net.URL;
+import javax.swing.JFrame;
+import org.javascool.About;
+import org.javascool.core.ProgletEngine;
+import org.javascool.macros.Macros;
+import org.javascool.tools.FileManager;
+import org.javascool.widgets.MainFrame;
+import org.javascool.widgets.ToolBar;
+
+// Used to define the frame
+/** Définit les functions d'interaction avec l'interface graphique de JavaScool.
+ *
+ * @see <a href="Desktop.java.html">code source</a>
+ * @serial exclude
+ */
+public class Desktop {
+    // @static-instance
+
+    /** Crée et/ou renvoie l'unique instance du desktop.
+     * <p>Une application ne peut définir qu'un seul desktop.</p>
+     */
+    public static Desktop getInstance() {
+        if (desktop == null) {
+            desktop = new Desktop();
+        }
+        return desktop;
+    }
+    private static Desktop desktop = null;
+
+    private Desktop() {
+    }
+
+    /** Renvoie la fenêtre racine de l'interface graphique. */
+    public JFrame getFrame() {
+        if (frame == null) {
+            frame = (new MainFrame() {
+
+                @Override
+                public boolean isClosable() {
+                    return org.javascool.gui.Desktop.getInstance().isClosable();
+                }
+            }).reset(About.title, About.logo, JVSPanel.getInstance());
+        }
+        return frame;
+    }
+    private MainFrame frame;
+
+    /** Retourne la bare d'outils de Java's cool */
+    public ToolBar getToolBar() {
+        return (ToolBar) JVSToolBar.getInstance();
+    }
+
+    /** Demande la fermeture du desktop à la fin du programme.
+     * @return La valeur true si le desktop peut être fermé sans dommage pour l'utilisateur, sinon la valeur fausse.
+     */
+    public boolean isClosable() {
+        boolean close = JVSPanel.getInstance().close();
+            if (close && ProgletEngine.getInstance().getProglet() != null)
+                ProgletEngine.getInstance().getProglet().stop();
+        return close;
+    }
+
+    /** Crée un nouveau fichier.
+     * @return  La valeur true si le fichier est bien créé.
+     */
+    public boolean openNewFile() {
+        try {
+            JVSPanel.getInstance().newFile();
+            return true;
+        } catch (Throwable th) {
+	  System.out.println("Aie impossible de créer un nouveau fichier "+th);
+	  return false;
+        }
+    }
+
+    /** Ouvre un fichier
+     * Demande à l'utilisateur de choisir un fichier et l'ouvre
+     * @param file Le fichier à ouvrir. 
+     * <p>-Avec la valeur null une boîte de dialogue le demandera à l'utilisateur.</p>
+     * <p>- Si le fichier est une URL, une copie locale du fichier (avec sauvegarde du fichier existant) est effectuée avant ouverture.</p>
+     */
+    public boolean openFile(File file) {
+        try {
+            if (file == null) {
+                JVSPanel.getInstance().openFile();
+            } else {
+                JVSFileTabs.getInstance().open(file.getAbsolutePath());
+            }
+            return true;
+        } catch (Throwable th) {
+	  System.out.println("Aie impossible d'ouvrir le fichier "+th);
+            return false;
+        }
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile(URL url) {
+        try{
+            System.err.println(url.getProtocol());
+            if(url.getProtocol().equals("jar")){
+                JVSFileTabs.getInstance().openFile(new JVSFile(FileManager.load(url.toExternalForm())));
+                return true;
+            }
+            return openFile(new File(url.toURI()));
+        }catch(Exception ex){
+ 	  System.out.println("Aie impossible d'ouvrir le fichier "+ex);
+            System.err.println("Error : ");
+            ex.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile(String file) {
+        return openFile(Macros.getResourceURL(file));
+    }
+
+    /**
+     * @see #openFile(File)
+     */
+    public boolean openFile() {
+        return openFile((File) null);
+    }
+
+    /** Demande à l'utilisateur de sauvegarder le fichier courant.
+     * @return La valeur true si le fichier est bien sauvegardé.
+     */
+    public boolean saveCurrentFile() {
+        return JVSPanel.getInstance().saveFile();
+    }
+
+    /** Ferme le fichier en cours d'édition. */
+    public void closeFile() {
+        JVSPanel.getInstance().closeFile();
+    }
+
+    /** Compile le fichier en cours d'édition. */
+    public void compileFile() {
+        JVSPanel.getInstance().compileFile();
+    }
+
+    /** Ferme la proglet en cours d'édition. */
+    public void closeProglet() {
+        JVSPanel.getInstance().closeProglet();
+    }
+
+    /** Ouvre une proglet
+     * @param proglet Le nom de code de la Proglet
+     * @return True si tous les fichier ont été sauvegardé et la proglet sauvegardé
+     */
+    public boolean openProglet(String proglet) {
+        if (JVSPanel.getInstance().closeAllFiles()) {
+            JVSPanel.getInstance().loadProglet(proglet);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /** Ouvre un nouvel onglet de navigation
+     * Ouvre un onglet HTML3 dans le JVSWidgetPanel, cet onglet peut être fermé
+     * @param url L'adresse à ouvrir sous forme de chaîne de caractères ou d'URL.
+     * @param name Le titre du nouvel onglet
+     */
+    public void openBrowserTab(URL url, String name) {
+        openBrowserTab(url.toString(), name);
+    }
+
+    /**
+     * @see #openBrowserTab(URL, String)
+     */
+    public void openBrowserTab(String url, String name) {
+        JVSWidgetPanel.getInstance().openWebTab(url, name);
+    }
+
+    /** Affiche la console. */
+    public void focusOnConsolePanel() {
+      JVSWidgetPanel.getInstance().focusOnConsolePanel();
+    }
+    
+    /** Affiche la console. */
+    public void focusOnProgletPanel() {
+       JVSWidgetPanel.getInstance().focusOnProgletPanel();
+    }
+}
Index: src/org/javascool/gui/JVSEditor.java
===================================================================
--- src/org/javascool/gui/JVSEditor.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSEditor.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,236 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.javascool.gui;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Event;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.imageio.ImageIO;
+import javax.swing.AbstractAction;
+import javax.swing.ImageIcon;
+import javax.swing.JButton;
+import javax.swing.JPanel;
+import javax.swing.KeyStroke;
+import javax.swing.ToolTipManager;
+import javax.swing.text.BadLocationException;
+import org.fife.ui.autocomplete.AutoCompletion;
+import org.fife.ui.autocomplete.CompletionProvider;
+import org.fife.ui.autocomplete.DefaultCompletionProvider;
+import org.fife.ui.autocomplete.LanguageAwareCompletionProvider;
+import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
+import org.fife.ui.rtextarea.Gutter;
+import org.fife.ui.rtextarea.RTextScrollPane;
+import org.fife.ui.rtextarea.ToolTipSupplier;
+import org.javascool.core.ProgletEngine;
+import org.javascool.widgets.ToolBar;
+
+/** Define a JVSEditor
+ * Use JVSEditor to edit jvs files, it can be used as a panel
+ * @author Philippe VIENNE
+ */
+class JVSEditor extends JPanel {
+
+    private static final long serialVersionUID = 1L;
+    private boolean completion= false;
+    /** The editor */
+    private RSyntaxTextArea TextPane;
+    /** The scroll pane */
+    private RTextScrollPane scrollPane;
+    /** La ToolBar */
+    private ToolBar toolBar;
+
+    /** Create a new JVSEditor
+     * Common setup
+     */
+    public JVSEditor() {
+        this.setLayout(new BorderLayout());
+        toolBar = new ToolBar();
+        TextPane = this.createTextArea();
+        TextPane.setSyntaxEditingStyle(org.fife.ui.rsyntaxtextarea.SyntaxConstants.SYNTAX_STYLE_JAVA);
+        JVSAutoCompletionProvider jacp = new JVSAutoCompletionProvider(TextPane);
+
+        scrollPane = new RTextScrollPane(TextPane, true);
+        Gutter gutter = scrollPane.getGutter();
+        gutter.setBorderColor(Color.BLUE);
+        toolBar.addTool("Reformater le code", new Runnable() {
+
+            @Override
+            public void run() {
+                setText(org.javascool.core.JvsBeautifier.run(getText()));
+            }
+        });
+        final JButton completionButton=new JButton();
+        completionButton.setText("Activer la complétion");
+        completionButton.addActionListener(new ActionListener(){
+
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                if(JVSEditor.this.completion){
+                    JVSEditor.this.completion=false;
+                    completionButton.setText("Activer la complétion");
+                } else {
+                    JVSEditor.this.completion=true;
+                    completionButton.setText("Désactiver la complétion");
+                }
+            }
+        });
+        toolBar.addTool("Activer/Désactiver la complétion", completionButton);
+        this.add(toolBar, BorderLayout.NORTH);
+        this.add(scrollPane, BorderLayout.CENTER);
+        this.setVisible(true);
+    }
+
+    /** TextArea initialization
+     * Creates the text area for this application.
+     * @return The text area.
+     */
+    private RSyntaxTextArea createTextArea() {
+        RSyntaxTextArea textArea = new RSyntaxTextArea(25, 70);
+        textArea.setCaretPosition(0);
+        // textArea.addHyperlinkListener(this);
+        textArea.requestFocusInWindow();
+        textArea.setMarkOccurrences(true);
+        textArea.setTextAntiAliasHint("VALUE_TEXT_ANTIALIAS_ON");
+        textArea.setText("");
+
+        KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_S, Event.CTRL_MASK);
+        if (isMac()) {
+            key = KeyStroke.getKeyStroke(KeyEvent.VK_S, Event.META_MASK);
+        }
+        KeyStroke copy_key = KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.CTRL_MASK);
+        if (isMac()) {
+            copy_key = KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.META_MASK);
+        }
+        textArea.getInputMap().put(key,
+                "save");
+        textArea.getActionMap().put("save",
+                new AbstractAction() {
+
+                    private static final long serialVersionUID = 1L;
+
+                    @Override
+                    public void actionPerformed(ActionEvent e) {
+                        JVSPanel.getInstance().saveFile();
+                    }
+                });
+
+        return textArea;
+    }
+
+    /** Tests if on mac. */
+    private static boolean isMac() {
+        return System.getProperty("os.name").toUpperCase().contains("MAC");
+    }
+
+    /** Get text into the TextArea
+     * @return The code
+     */
+    public String getText() {
+        return TextPane.getText();
+    }
+
+    /** Set the text
+     * @param text The text to write on screen
+     */
+    public void setText(String text) {
+        TextPane.setText(text);
+    }
+
+    /** Get the RSyntaxTextArea */
+    public RSyntaxTextArea getRTextArea() {
+        return TextPane;
+    }
+
+    /** Retourne le RTextScrollPane de l'éditeur */
+    public RTextScrollPane getScrollPane() {
+        return scrollPane;
+    }
+
+    public void removeLineSignals() {
+        getScrollPane().getGutter().removeAllTrackingIcons();
+    }
+
+    public void signalLine(int line) {
+        Gutter gutter = getScrollPane().getGutter();
+        gutter.setBookmarkingEnabled(true);
+        ImageIcon icon = null;
+        BufferedImage img;
+        try {
+            img = ImageIO.read(ClassLoader.getSystemResourceAsStream("org/javascool/widgets/icons/error.png"));
+            icon = new ImageIcon(img);
+        } catch (IOException ex1) {
+	  // @todo : ici une erreur passée sous le tapis
+	  System.err.println("Dysfonctionnement innatendu ici "+ex1);
+        }
+        try {
+            getRTextArea().setCaretPosition(getRTextArea().getLineStartOffset(line - 1));
+            getScrollPane().getGutter().addLineTrackingIcon(line - 1, icon);
+        } catch (BadLocationException ex) {
+	  // @todo : ici une erreur géree par le Logger . . 
+	  System.err.println("Dysfonctionnement innatendu ici "+ex);
+	  // Logger.getLogger(JVSEditor.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+
+    private class JVSAutoCompletionProvider extends AutoCompletion {
+
+        public JVSAutoCompletionProvider(RSyntaxTextArea TextPane) {
+            super(createCodeCompletionProvider());
+            setShowDescWindow(true);
+            //setParameterAssistanceEnabled(true);
+            install(TextPane);
+            TextPane.setToolTipSupplier((ToolTipSupplier) this.getCompletionProvider());
+            ToolTipManager.sharedInstance().registerComponent(TextPane);
+            TextPane.addKeyListener(new KeyListener() {
+
+                @Override
+                public void keyTyped(KeyEvent e) {
+                    int ch = e.getKeyChar();
+                    if (ch>33&&ch!=127&&ch!=129&&ch!=141&&ch!=143&&ch!=144&&ch!=157&&ch!=160&&JVSEditor.this.completion) {
+                        showPopupWindow();
+                    } else {
+                        hideChildWindows();
+                    }
+                }
+
+                @Override
+                public void keyPressed(KeyEvent e) {
+                }
+
+                @Override
+                public void keyReleased(KeyEvent e) {
+                }
+            });
+        }
+
+        public void showPopupWindow() {
+            this.refreshPopupWindow();
+            return;
+        }
+    }
+
+    /**
+     * Returns the provider to use when editing code.
+     *
+     * @return The provider.
+     */
+    public static CompletionProvider createCodeCompletionProvider() {
+        DefaultCompletionProvider cp = new DefaultCompletionProvider();
+        if(!ProgletEngine.getInstance().getProglet().getCompletion().equals("")) {
+            JvsXMLCompletion.readCompletionToProvider(ProgletEngine.getInstance().getProglet().getCompletion(), cp);
+        }
+        JvsXMLCompletion.readCompletionToProvider("org/javascool/gui/completion-macros.xml", cp);
+        LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(cp);
+        return lacp;
+    }
+}
Index: src/org/javascool/gui/completion-macros.xml
===================================================================
--- src/org/javascool/gui/completion-macros.xml	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/completion-macros.xml	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<keywords>
+    <!-- 
+#####################
+    Stdin 
+#####################
+    -->
+    <!-- ReadString -->
+    <keyword name="readString" title="Stocke une chaîne de caractères dans une variable">
+        <doc>Crée une variable s qui va contenir une chaîne de caractères demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>String s = readString("question");</code>
+    </keyword>
+    <keyword name="readString" title="Demande à l'utilisateur une chaîne de caractères">
+        <doc>Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
+        </doc>
+        <code>readString()</code>
+    </keyword>
+    <!-- ReadInteger -->
+    <keyword name="readInteger" title="Stocke un entier dans une variable">
+        <doc>Crée une variable n qui va contenir un int demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>int n = readInteger("question");</code>
+    </keyword>
+    <keyword name="readInteger" title="Demande un nombre entier à l'utilisateur">
+        <doc>Lit un nombre entier dans une fenêtre présentée à l'utilisateur.</doc>
+        <code>readInteger()</code>
+    </keyword>
+    <!-- ReadDecimal -->
+    <keyword name="readDecimal" title="Stocke un nombre décimal dans une variable">
+        <doc>Crée une variable x qui va contenir un double demandé à l'utilisateur.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>double x = readDecimal("question");</code>
+    </keyword>
+    <keyword name="readDecimal" title="Demande un nombre décimal à l'utilisateur">
+        <doc>Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.</doc>
+        <code>readDecimal()</code>
+    </keyword>
+    <!-- ReadBoolean -->
+    <keyword name="readBoolean" title="Stocke un booléen dans une variable">
+        <doc>Crée une variable b qui va contenir un booléen demandé à l'utilisateur, dans une fenêtre 'oui' ou 'non'.
+Il peut prendre un paramètre "question" de type String qui décrit la valeur à entrer (optionel).</doc>
+        <code>boolean b = readBoolean("question");</code>
+    </keyword>
+    <keyword name="readBoolean" title="Demande un booléen à l'utilisateur">
+        <doc>Lit une valeur booléenne dans une fenêtre 'oui' ou 'non' présentée à l'utilisateur.</doc>
+        <code>readBoolean()</code>
+    </keyword>
+    <!-- 
+#####################
+    Stdin 
+#####################
+    -->
+    <keyword name="println" title="Affiche du texte dans la console">
+        <doc>Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console avec un retour à la ligne.</doc>
+        <code>println("");</code>
+    </keyword>
+    <keyword name="print" title="Affiche du texte dans la console">
+        <doc>Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console sans retour à la ligne.</doc>
+        <code>print("");</code>
+    </keyword>
+    <!-- 
+#####################
+    Macros
+#####################
+    -->
+    <keyword name="random" title="Génère un entier aléatoirement">
+        <doc>Renvoie un nombre entier aléatoire uniformément distribué entre deux valeurs entières (maximum inclus).
+        Ici: entre 0 et 100.</doc>
+        <code>random(0, 100);</code>
+    </keyword>
+    <keyword name="equal" title="Vérifie si deux Strings sont égales">
+        <doc>Renvoie true si deux chaînes de caratères sont égales, faux sinon.</doc>
+        <code>equal("","")</code>
+    </keyword>
+    <keyword name="sleep" title="Fait faire une pause au programme">
+        <doc>Temporise une durée fixée. Il prend un paramètre optionnel qui est la durée de pause en milli-secondes.
+        Ici: 1000 milli-secondes, docn 1 seconde.</doc>
+        <code>sleep(1000);</code>
+    </keyword>
+    <keyword name="assertion" title="Assert l'execution de Java's cool">
+        <doc>Vérifie une assertion et arrête le code si elle est fausse. Il prend un paramètre booléen obligatoire qui est la condition.
+Si elle est fausse, le programme s'arrête.</doc>
+        <code>assertion(true);</code>
+    </keyword>
+    <keyword name="getIcon" title="Charge une image">
+        <doc>Renvoie une icone stockée dans le JAR de l'application. Il prend un paramètre obligatoire qui est l'emplacement de l'icone.
+        Ici: une des icônes de JavaScool.</doc>
+        <code>getIcon("org/javascool/widget/icons/play.png");</code>
+    </keyword>
+    <keyword name="openUrl" title="Ouvre le navigateur du système">
+        <doc>Ouvre une URL (Universal Resource Location) dans un navigateur extérieur. Il prend un paramètre obligatoire qui est L'URL à afficher.</doc>
+        <code>openUrl("http://www.google.fr");</code>
+    </keyword>
+    <!-- 
+#####################
+    Java
+#####################
+    -->
+    <keyword name="if" title="Instruction conditionnelle">
+        <doc>Vérifie la condition et si elle est vraie, exécute le bloc d'instructions.</doc>
+        <code>  if(true) {
+    // CodeSiOui
+  }</code>
+    </keyword>
+    <keyword name="if/else" title="Instruction conditionnelle avec alternative">
+        <doc>Vérifie la condition et si elle est vraie, exécute le 1er bloc d'instructions. Si elle est fause, exécute le 2ème bloc</doc>
+        <code>  if(true) {
+    // CodeSiOui
+  } else {
+    // CodeSiNon
+  }</code>
+    </keyword>
+    <keyword name="while" title="Boucle sur un bloc d'instruction, selon une condition">
+        <doc>Tant que la condition est vraie, exécute le bloc d'instructions.</doc>
+        <code>  while(/*condition*/) {
+    // Code
+  }</code>
+    </keyword>
+    <keyword name="for" title="Boucle sur un bloc d'instruction, avec un compteur">
+        <doc>Tant que la valeur de i est plus petite que la valeur de n, exécute le bloc d'instructions. Le code s'exécute donc n fois.</doc>
+        <code><![CDATA[  for(int i = 0; i < n; i++) {
+    // Code
+  }]]></code>
+    </keyword>
+</keywords>
Index: src/org/javascool/gui/JVSTabs.java
===================================================================
--- src/org/javascool/gui/JVSTabs.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSTabs.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,82 @@
+package org.javascool.gui;
+
+import java.awt.Component;
+import java.util.HashMap;
+import javax.swing.ImageIcon;
+import javax.swing.JPanel;
+import javax.swing.JTabbedPane;
+import org.javascool.macros.Macros;
+
+/** Create a tab structure
+ * Java's cool Tab Structure is used to make easy JTabbedPane
+ * @author Philippe VIENNE
+ */
+class JVSTabs extends JTabbedPane {
+  private static final long serialVersionUID = 1L;
+
+  /** Contain JPanels opened */
+  protected HashMap<String, JPanel> tabs = new HashMap<String, JPanel>();
+
+  /** Add a tab with a JPanel
+   * @param name The tab name
+   * @param icon The link to the icon, can be an empty String
+   * @param panel The JPanel to show into the tab
+   * @return The new id of your tab
+   */
+  public String add(String name, String icon, JPanel panel) {
+    return this.add(name, icon, panel, null);
+  }
+  /** Add a tab with an Applet
+   * @param name The tab name
+   * @param icon The link to the icon, can be an empty String
+   * @param panel The Applet to show into the tab
+   * @return The new id of your tab
+   */
+  public String add(String name, String icon, Component panel) {
+    tabs.put(name, new JPanel());
+    if(!icon.equalsIgnoreCase("")) {
+      ImageIcon logo = Macros.getIcon(icon);
+      this.addTab(name, logo, panel);
+    } else
+      this.addTab(name, null, panel);
+    this.revalidate();
+    return name;
+  }
+  /** Add a tab with a JPanel
+   * @param name The tab name
+   * @param icon The link to the icon, can be an empty String
+   * @param panel The JPanel to show into the tab
+   * @param tooltip An tooltip for the tab
+   * @return The new id of your tab
+   */
+  public String add(String name, String icon, JPanel panel, String tooltip) {
+    tabs.put(name, panel);
+    if(!icon.equalsIgnoreCase("")) {
+      ImageIcon logo = Macros.getIcon(icon);
+      this.addTab(name, logo, panel, tooltip);
+    } else
+      this.addTab(name, null, panel, tooltip);
+    this.revalidate();
+    return name;
+  }
+  /** Get a JPanel
+   * @param name The id of JPanel
+   * @return The JPanel
+   */
+  public JPanel getPanel(String name) {
+    return this.tabs.get(name);
+  }
+  /** Delete a tab
+   * @param name The tab id
+   */
+  public void del(String name) {
+    this.removeTabAt(this.indexOfTab(name));
+    tabs.remove(name);
+  }
+  /** Switch to a tab
+   * @param name The id of the tab
+   */
+  public void switchToTab(String name) {
+    this.setSelectedIndex(this.indexOfTab(name));
+  }
+}
Index: src/org/javascool/gui/JVSFileTabs.java
===================================================================
--- src/org/javascool/gui/JVSFileTabs.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JVSFileTabs.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,356 @@
+package org.javascool.gui;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.UUID;
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.UIManager;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+import org.javascool.widgets.Console;
+import org.javascool.core.ProgletEngine;
+import org.javascool.tools.UserConfig;
+
+/** The JVSFileTabs
+ * A powerful JVSTabs to manage a multi-file editing. It only support JVSFile.
+ */
+class JVSFileTabs extends JVSTabs {
+    // Empeche de pouvoir renommer itempestivement des folder
+    static {
+    UIManager.put("FileChooser.readOnly", Boolean.TRUE);
+    }
+
+    private static final long serialVersionUID = 1L;
+    /** Store all JVSEditor in an HashMap by the fileId */
+    private static HashMap<String, JVSEditor> editors = new HashMap<String, JVSEditor>();
+    /** Store all JVSFile in an HashMap by the fileId */
+    private static HashMap<String, JVSFile> files = new HashMap<String, JVSFile>();
+    /** Store all fileIds in an HashMap by the tab name */
+    static HashMap<String, String> fileIds = new HashMap<String, String>();
+    /** The current compiled file */
+    private static String currentCompiledFile = "";
+    private static JVSFileTabs desktop;
+
+    /** Access to the unique instance of the JVSPanel object. */
+    public static JVSFileTabs getInstance() {
+        if (desktop == null) {
+            desktop = new JVSFileTabs();
+        }
+        return desktop;
+    }
+
+    /**
+     * @return the currentCompiledFile
+     */
+    public static String getCurrentCompiledFile() {
+        return currentCompiledFile;
+    }
+
+    /** Create a new JVSFileTabs */
+    private JVSFileTabs() {
+        super();
+    }
+
+    /** Open a new empty Java's cool file in tmp
+     * @return The file's tempory id in editor tabs
+     */
+    public String openNewFile() {
+        return this.openFile(new JVSFile(JVSFile.defaultCode));
+    }
+
+    /** Open a new empty Java's cool file in tmp
+     * @param url The url to the file (used by File())
+     * @return The file's tempory id in editor tabs
+     */
+    public String open(String url) {
+        return this.openFile(new JVSFile(url, true));
+    }
+
+    /** Open a file
+     * Open a file from the instance and open its tab
+     * @param file The opened file
+     * @return The file's tempory id in editor tabs
+     */
+    String openFile(JVSFile file) {
+        // Check if file is not already opened
+        if (!this.getFileId(file.getName()).equals("")) {
+            if (JVSFileTabs.files.get(this.getFileId(file.getName())).getFile().equals(file.getFile())) {
+                this.setSelectedIndex(this.getTabId(this.getFileId(file.getName())));
+                return this.getFileId(file.getName());
+            }
+        }
+        // Create the fileId wich is unique
+        String fileId = UUID.randomUUID().toString();
+        // Create the JVSEditor for the file
+        JVSEditor editor = new JVSEditor();
+        // Set text in the editor
+        editor.setText(file.getCode());
+
+        // Add listener for edit
+        editor.getRTextArea().getDocument().addDocumentListener(new DocumentListener() {
+
+            @Override
+            public void insertUpdate(DocumentEvent e) {
+            }
+
+            @Override
+            public void removeUpdate(DocumentEvent e) {
+            }
+
+            @Override
+            public void changedUpdate(DocumentEvent e) {
+                fileUpdateNotification();
+            }
+        });
+        // Store the new editor
+        JVSFileTabs.editors.put(fileId, editor);
+        // Store the JVSFile
+        JVSFileTabs.files.put(fileId, file);
+        // Create the tab name
+        String tabTitle = file.getName();
+        if (this.indexOfTab(file.getName()) != -1) {
+            int i = 1;
+            while (this.indexOfTab(file.getName() + " " + i) != -1) {
+                i++;
+            }
+            tabTitle = file.getName() + " " + i;
+            file.setName(tabTitle);
+        }
+        // We add the tab
+        add(tabTitle, "", editors.get(fileId));
+
+        // Store the new fileId by the tab name
+        JVSFileTabs.fileIds.put(tabTitle, fileId);
+        
+        JVSPanel.getInstance().haveNotToSave(fileId);
+        
+        // Select the new tab
+        this.setSelectedIndex(this.getTabId(fileId));
+        this.setTabComponentAt(this.getTabId(fileId), new TabPanel(this, fileId));
+        // Return the new file id
+        return fileId;
+    }
+
+    /** Close an opened file
+     * @param fileId The file ID
+     */
+    public void closeFile(String fileId) {
+        if (this.getTabId(fileId) != -1) {                // We check if file is opened
+            String tab_title = this.getTitleAt(this.getTabId(fileId));                   // Save the tap title (Useful)
+            try {
+                String fileName = "";
+                for(String name : JVSFileTabs.fileIds.keySet())
+                    if (JVSFileTabs.fileIds.get(name).equals(fileId))
+                        fileName = name;
+                 this.removeTabAt(this.getTabId(fileId));                         // First remove the tab
+                JVSFileTabs.fileIds.remove(fileName);                         // Remove id in the index
+                JVSFileTabs.files.remove(fileId);                         // Remove the file class
+                JVSFileTabs.editors.remove(fileId);                         // Remove the editor
+                JVSPanel.getInstance().haveToSave.remove(fileId);
+            } catch (Exception e) {
+                throw new IllegalStateException(e); // Use to debug
+            }
+        }
+    }
+
+    /** Get the Current file ID
+     * @return An file id
+     */
+    public String getCurrentFileId() {
+        String tab_name = this.getTitleAt(this.getSelectedIndex());             // Get the tab name opened to find the id
+        String fileId = JVSFileTabs.fileIds.get(tab_name);             // We get the id
+        return fileId;
+    }
+
+    /** Save the current file */
+    public Boolean saveCurrentFile() {
+        return this.saveFile(this.getCurrentFileId());             // We just save the file
+    }
+    /** Save the current file */
+    public Boolean saveAsCurrentFile() {
+        return this.saveAsFile(this.getCurrentFileId());             // We just save the file
+    }
+
+    /** Check if the current file is in tempory memory
+     * @return True if is tempory
+     */
+    public Boolean currentFileIsTmp() {
+        return JVSFileTabs.files.get(this.getCurrentFileId()).isTmp();             // Check in the JVS File object if is tempory
+    }
+
+    /** Compile a file
+     * @param fileId The id of the file to javaCompile
+     * @return True on success, false in case of error. Can return true if file is not openned
+     */
+    public Boolean compileFile(String fileId) {
+        if (!JVSFileTabs.fileIds.containsValue(fileId) || JVSFileTabs.files.get(fileId).isTmp()) {
+            return false;
+        }
+        JVSFileTabs.currentCompiledFile = fileId;
+        if (ProgletEngine.getInstance().doCompile(JVSFileTabs.editors.get(fileId).getText())) {
+            Console.getInstance().clear();
+            System.out.println("Compilation réussie !");
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /** Save a file
+     * @param fileId The id of the file to save
+     * @return True on success, false in case of error. Can return true if file is not openned
+     */
+    public Boolean saveFile(String fileId) {
+        if (!JVSFileTabs.fileIds.containsValue(fileId)) // Check if id is opened
+        {
+            return true;                   // Return true because file is not opened
+        }
+        if (JVSFileTabs.files.get(fileId).isTmp()) {
+            return this.saveAsFile(fileId);
+        } else {
+            JVSFileTabs.files.get(fileId).setCode(JVSFileTabs.editors.get(fileId).getText());                   // Set the editor's text into the object
+            JVSFileTabs.files.get(fileId).save();                   // Write data in the file
+            return true;
+        }
+    }
+
+    /** Prompt where we can save
+     * after prompt it call JVSFileTabs.saveFile(fileId)
+     * @param fileId The id of the file to save
+     * @return See saveFile()
+     */
+    public Boolean saveAsFile(String fileId) {
+        JFileChooser fc = new JFileChooser();             // We create a file chooser
+        try {
+        if (System.getProperty("os.name").toLowerCase().contains("nix") || System.getProperty("os.name").toLowerCase().contains("nux")) {
+            fc.setCurrentDirectory(new File(System.getProperty("user.dir")));
+        } else if (UserConfig.getInstance("javascool").getProperty("dir") != null &&
+                   !UserConfig.getInstance("javascool").getProperty("dir").isEmpty()) {
+            fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool").getProperty("dir")));
+        } else {
+            fc.setCurrentDirectory(new File(System.getProperty("home.dir")));
+        }
+        } catch(Exception e) {
+            // @todo Ici un platrage quand la mise en place du repertoire par defaut echoue 
+         System.err.println("Notice: échec de la mise en place du répertoire par défaut: "+ e);
+        }
+        fc.setApproveButtonText("Enregistrer");
+        fc.setDialogTitle("Enregistrer");
+        int returnVal = fc.showOpenDialog(this.getParent());             // Get the return value of user choice
+        if (returnVal == JFileChooser.APPROVE_OPTION) {                // Check if user is ok to save the file
+            String path = fc.getSelectedFile().getAbsolutePath();                   // Get the path which has been choosed by the user
+            String name = fc.getSelectedFile().getName();
+            UserConfig.getInstance("javascool").setProperty("dir", fc.getSelectedFile().getParentFile().getAbsolutePath());
+            if (!path.endsWith(".jvs")) // Test if user writed the extension
+            {
+                path = path + ".jvs";                         // If not we just add it
+            }
+            if (!name.endsWith(".jvs")) // Test if user writed the extension
+            {
+                name = name + ".jvs";                         // If not we just add it
+            }      //JVSFile file = new JVSFile(path, true);
+            if (!this.getFileId(name).equals("")) {
+                System.out.println("Le fichier n'est pas nouveau ; Test : ");
+                System.out.println(JVSFileTabs.files.get(this.getFileId(name)).getFile().getName().equals(name));
+                if (JVSFileTabs.files.get(this.getFileId(name)).getFile().getName().equals(name)) {
+                    JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+                            "Ce fichier est déjà ouvert dans Java's cool, choisisez un nouvelle endroit.",
+                            "Erreur d'écriture",
+                            JOptionPane.ERROR_MESSAGE);
+                    return this.saveAsFile(fileId);
+                }
+            }
+            JVSFileTabs.files.get(fileId).setPath(path);                   // We set the new path
+            JVSFileTabs.files.get(fileId).setName(fc.getSelectedFile().getName());                   // We set the new Name
+            this.editTabName(fileId, name);                   // Update the TabTitle to the new name
+            JVSFileTabs.files.get(fileId).setCode(JVSFileTabs.editors.get(fileId).getText());                   // Set the editor's text into the object
+            if (JVSFileTabs.files.get(fileId).save()) {
+                return true;
+            } else {
+                JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
+                        "Le fichier ne peut pas être écrit ici, choisisez un nouvelle endroit.",
+                        "Erreur d'écriture",
+                        JOptionPane.ERROR_MESSAGE);
+                return this.saveAsFile(fileId);
+            }                  // Write data in the file
+        } else {
+            return false;                   // If the user is not ok
+        }
+    }
+
+    /** Get the tabId for an fileId */
+    public int getTabId(String fileId) {
+        if (JVSFileTabs.fileIds.containsValue(fileId)) // We check if fileId exist
+        {
+            return this.indexOfComponent(JVSFileTabs.editors.get(fileId));                   // Get index from the editor
+        }
+        return -1;             // If file not exist, return -1.
+    }
+
+    /** Change the tab name
+     * @param fileId The id of the file wich we change the title
+     * @param newTitle The new title
+     * @return The success
+     */
+    public Boolean editTabName(String fileId, String newTitle) {
+        String tabTitle = newTitle;             // create the new title
+        if (this.indexOfTab(newTitle) != -1) {                // Check if tab with its name exist
+            int i = 1;
+            while (this.indexOfTab(newTitle + " " + i) != -1) // Generate it
+            {
+                i++;
+            }
+            tabTitle = newTitle + " " + i;
+        }
+        String oldTabTitle = this.getTitleAt(this.getTabId(fileId));             // Get the old tab title
+        this.setTitleAt(this.getTabId(fileId), tabTitle);             // Update the title
+        JVSFileTabs.fileIds.remove(oldTabTitle);             // remove old index
+        JVSFileTabs.fileIds.put(tabTitle, fileId);             // set the new fil
+        return true;             // return true all time
+    }
+
+    /** Get the fileId from a TabName
+     * @param tabName The tab Name
+     * @return The file Id
+     */
+    public String getFileId(String tabName) {
+        if (JVSFileTabs.fileIds.containsKey(tabName)) // Check if tabName exist
+        {
+            return JVSFileTabs.fileIds.get(tabName);                   // Return the id
+        } else {
+            return "";                   // Return empty string if tabName not exist
+        }
+    }
+
+    /** Get a file from its ID */
+    public JVSFile getFile(String id) {
+        if (JVSFileTabs.files.containsKey(id)) // Check if id exist
+        {
+            return JVSFileTabs.files.get(id);                   // Return the JVSFile
+        } else {
+            return new JVSFile();                   // Return new empty JVSFile if id not exists
+        }
+    }
+
+    /** Get the editor for an ID */
+    public JVSEditor getEditor(String fileId) {
+        if (JVSFileTabs.editors.containsKey(fileId)) // Check if fileId exist
+        {
+            return JVSFileTabs.editors.get(fileId);                   // Return the editor
+        } else {
+            return new JVSEditor();                   // Return new empty JVSEditor if fileId not exists
+        }
+    }
+
+    /** File update is call when a file is edited
+     * Call JVSPanel.mustSave(this.getCurrentFileId()) to check if file has to be save
+     */
+    protected static void fileUpdateNotification() {
+        JVSPanel.getInstance().mustSave(JVSFileTabs.getInstance().getCurrentFileId());
+    }
+
+    public int getOppenedFileCount() {
+        return this.tabs.entrySet().toArray().length;
+    }
+}
Index: src/org/javascool/gui/JvsXMLCompletion.java
===================================================================
--- src/org/javascool/gui/JvsXMLCompletion.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/JvsXMLCompletion.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,231 @@
+/*
+ *  Edited from JvsXMLCompletion.java - Parses XML representing code completion for a
+ * C-like language.
+ * Copyright (C) 2010 Robert Futrell
+ * robert_futrell at users.sourceforge.net
+ * http://fifesoft.com/rsyntaxtextarea
+ */
+package org.javascool.gui;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import org.fife.ui.autocomplete.BasicCompletion;
+import org.fife.ui.autocomplete.Completion;
+import org.fife.ui.autocomplete.CompletionProvider;
+import org.fife.ui.autocomplete.DefaultCompletionProvider;
+import org.fife.ui.autocomplete.ShorthandCompletion;
+import org.javascool.macros.Macros;
+import org.xml.sax.Attributes;
+import org.xml.sax.helpers.DefaultHandler;
+
+/**
+ * Parser for an XML file describing a procedural language such as JVS.<p>
+ *
+ * @version 1.0
+ */
+class JvsXMLCompletion extends DefaultHandler {
+
+    /**
+     * The completions found after parsing the XML.
+     */
+    private List completions;
+    /**
+     * The provider we're getting completions for.
+     */
+    private CompletionProvider provider;
+    /**
+     * The completion provider to use when loading classes, such as custom
+     * {@link FunctionCompletion}s.
+     */
+    private ClassLoader completionCL;
+    private String name;
+    private StringBuffer desc;
+    private String shortDesc;
+    private StringBuffer code;
+    private boolean doingKeywords;
+    private boolean inKeyword;
+    private boolean gettingDoc;
+    private boolean gettingCode;
+    private boolean inCompletionTypes;
+    /**
+     * The class loader to use to load custom completion classes, such as
+     * the one defined by {@link #funcCompletionType}.  If this is
+     * <code>null</code>, then a default class loader is used.  This field
+     * will usually be <code>null</code>.
+     */
+    private static ClassLoader DEFAULT_COMPLETION_CLASS_LOADER;
+
+    /**
+     * Constructor.
+     *
+     * @param provider The provider to get completions for.
+     * @see #reset(CompletionProvider)
+     */
+    public JvsXMLCompletion(CompletionProvider provider) {
+        this(provider, null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param provider The provider to get completions for.
+     * @param cl The class loader to use, if necessary, when loading classes
+     *        from the XML  (custom {@link FunctionCompletion}s, for example).
+     *        This may be <code>null</code> if the default is to be used, or
+     *        if the XML does not define specific classes for completion types.
+     * @see #reset(CompletionProvider)
+     */
+    public JvsXMLCompletion(CompletionProvider provider, ClassLoader cl) {
+        this.provider = provider;
+        this.completionCL = cl;
+        if (completionCL == null) {
+            // May also be null, but that's okay.
+            completionCL = DEFAULT_COMPLETION_CLASS_LOADER;
+        }
+        completions = new ArrayList();
+        desc = new StringBuffer();
+        code = new StringBuffer();
+    }
+
+    /**
+     * Called when character data inside an element is found.
+     */
+    @Override
+    public void characters(char[] ch, int start, int length) {
+        if (gettingDoc) {
+            desc.append(ch, start, length);
+        }
+        if (gettingCode) {
+            code.append(ch, start, length);
+        }
+    }
+
+    private BasicCompletion createCompletion() {
+        BasicCompletion bc = new BasicCompletion(provider, name);
+        if (code.length() > 0) {
+            bc = new ShorthandCompletion(provider, name, code.toString());
+            code = new StringBuffer();
+        }
+        if (desc.length() > 0) {
+            bc.setSummary(desc.toString());
+            desc = new StringBuffer();
+        }
+        if (shortDesc.length() > 0) {
+            bc.setShortDescription(shortDesc.toString());
+            shortDesc = "";
+        }
+        return bc;
+    }
+
+    /**
+     * Called when an element is closed.
+     */
+    @Override
+    public void endElement(String uri, String localName, String qName) {
+
+        if ("keywords".equals(qName)) {
+            doingKeywords = false;
+        } else if (doingKeywords) {
+
+            if ("keyword".equals(qName)) {
+                Completion c = null;
+                c = this.createCompletion();
+                completions.add(c);
+                inKeyword = false;
+            } else if (inKeyword) {
+                if ("doc".equals(qName)) {
+                    gettingDoc = false;
+                }
+                if ("code".equals(qName)) {
+                    gettingCode = false;
+                }
+            }
+
+        } else if (inCompletionTypes) {
+            if ("completionTypes".equals(qName)) {
+                inCompletionTypes = false;
+            }
+        }
+
+    }
+
+    /**
+     * Resets this parser to grab more completions.
+     *
+     * @param provider The new provider to get completions for.
+     */
+    public void reset(CompletionProvider provider) {
+        this.provider = provider;
+        completions.clear();
+        doingKeywords = inKeyword = gettingDoc = false;
+        desc = new StringBuffer();
+        code = new StringBuffer();
+    }
+
+    /**
+     * Sets the class loader to use when loading custom classes to use for
+     * various {@link Completion} types, such as {@link FunctionCompletion}s,
+     * from XML.<p>
+     *
+     * Users should very rarely have a need to use this method.
+     *
+     * @param cl The class loader to use.  If this is <code>null</code>, then
+     *        a default is used.
+     */
+    public static void setDefaultCompletionClassLoader(ClassLoader cl) {
+        DEFAULT_COMPLETION_CLASS_LOADER = cl;
+    }
+
+    /**
+     * Called when an element starts.
+     */
+    @Override
+    public void startElement(String uri, String localName, String qName,
+            Attributes attrs) {
+        if ("keywords".equals(qName)) {
+            doingKeywords = true;
+        } else if (doingKeywords) {
+            if ("keyword".equals(qName)) {
+                name = attrs.getValue("name");
+                shortDesc = attrs.getIndex("title") > -1 ? attrs.getValue("title") : "";
+                inKeyword = true;
+            } else if (inKeyword) {
+                if ("doc".equals(qName)) {
+                    gettingDoc = true;
+                }
+                if ("code".equals(qName)) {
+                    gettingCode = true;
+                }
+            }
+        }
+    }
+
+    public List getCompletions() {
+        return this.completions;
+    }
+    
+    public static DefaultCompletionProvider readCompletionToProvider(String file,DefaultCompletionProvider cp){
+        SAXParserFactory factory = SAXParserFactory.newInstance();
+        JvsXMLCompletion handler = new JvsXMLCompletion(cp, ClassLoader.getSystemClassLoader());
+        BufferedInputStream bin = new BufferedInputStream(ClassLoader.getSystemClassLoader().getResourceAsStream(file));
+        try {
+            SAXParser saxParser = factory.newSAXParser();
+            saxParser.parse(bin, handler);
+            List completions = handler.getCompletions();
+            cp.addCompletions(completions);
+        } catch (Exception ex) {
+            Macros.message("Erreur lors de la lecture de la librairie de<br/>complétion vérifier si le fichier xml<br/>est correctement écrit.<hr><i>Erreur : "+ex.getMessage()+"</i>", true);
+        } finally {
+            try {
+                bin.close();
+            } catch (IOException ex) {
+                throw new RuntimeException(ex.toString());
+            }
+        }
+        return cp;
+    }
+}
\ No newline at end of file
Index: src/org/javascool/gui/package.html
===================================================================
--- src/org/javascool/gui/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/gui/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les mécanismes de compilation d'une nouvelle proglet.</body>
+
Index: src/org/javascool/builder/hdoc2htm.xslt
===================================================================
--- src/org/javascool/builder/hdoc2htm.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/hdoc2htm.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,239 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sx="http://icl.com/saxon" extension-element-prefixes="sx">
+
+  <!-- This XSLT translates HML code to HTML 4 output -->
+
+<xsl:output 
+  method="html"
+  encoding="UTF-8"
+  doctype-public="-//W3C//DTD HTML 4.01//EN"
+  doctype-system="http://www.w3.org/TR/html4/strict.dtd"
+  indent="yes" />
+
+  <!-- This XSLT translates the proglet's HML documentation to HTML3.2 http://www.w3.org/TR/REC-html32-19970114) -->
+
+  <sx:function name="sx:jvs2htm" xmlns:jvs2htm="java:org.javascool.builder.Jvs2Html">
+    <xsl:param name="string"/>
+    <sx:return select="jvs2htm:run($string)"/>
+  </sx:function>
+  
+  <xsl:param name="output" select="'jvs'"/>
+
+<!-- These tags produce javasccool's doc specific constructs -->
+
+<xsl:template match="div|p">
+  <xsl:choose>
+    <xsl:when test="@class = 'sujet'">
+      <div align="right">
+        <xsl:if test ="count(intros) > 0">[<a href="#intros">introduction</a>]</xsl:if>
+        <xsl:if test ="count(works) > 0">[<a href="#works">travail proposé</a>]</xsl:if>
+        <xsl:if test ="count(notes) > 0">[<a href="#notes">remarques</a>]</xsl:if>
+      </div>
+      <xsl:call-template name="div"/>
+    </xsl:when>
+    <xsl:when test="@class = 'objectif'"><h2>Objectif.</h2><xsl:call-template name="div"/></xsl:when>
+    <xsl:when test="@class = 'intros' or @class = 'works' or @class = 'notes'">
+      <xsl:choose>
+        <xsl:when test="@class = 'intros'"><h2>Introduction.</h2></xsl:when>
+        <xsl:when test="@class = 'works'"><h2>Travail proposé.</h2></xsl:when>
+        <xsl:when test="@class = 'notes'"><h2>Remarques.</h2></xsl:when>
+      </xsl:choose>
+      <div id="{@class}"><ol><xsl:for-each select="*"><li><xsl:call-template name="div-2"/></li></xsl:for-each></ol></div>
+    </xsl:when>
+    <xsl:when test="@class = 'code'"><div class="code"><table witdh="90%" border="1" align="center"><tr><td><xsl:call-template name="div"/></td></tr></table></div></xsl:when>
+    <xsl:otherwise><xsl:call-template name="div"/></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template match="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'javascool'"><tt><a href="http://javascool.gforge.inria.fr" style="padding:0;margin:0;text-decoration:none">Java'sCool</a></tt></xsl:when>
+    <xsl:when test="@class = 'note'"><sup><a href="{concat('#', @link)}"><xsl:value-of select="@link"/></a></sup></xsl:when>
+    <xsl:when test="(@class = 'editor' or @class = 'newtab') and $output = 'jvs'"> 
+    <a href="{concat('http://',@class,'?', @link)}"><xsl:value-of select="@text"/></a>
+   </xsl:when>
+   <xsl:when test="@class = 'editor'"> 
+      <a class="{@class}" href="{concat(@link,'.html')}"><xsl:value-of select="@text"/></a>
+   </xsl:when>  
+   <xsl:otherwise><xsl:call-template name="l"/></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<!-- These tags performs the Jvs2Htm conversion -->
+
+<xsl:template match="code">
+  <div class="code"><table><tr><td>
+    <xsl:value-of disable-output-escaping="yes" select="sx:jvs2htm(.)"/>
+  </td></tr></table></div>
+</xsl:template>
+
+<!-- These tags allows to show pieces of code -->
+
+<xsl:template match="r">
+  <font color="#990000"><b><xsl:apply-templates/></b></font>
+</xsl:template>
+
+<xsl:template match="n">
+  <font color="#505000"><xsl:apply-templates/></font>
+</xsl:template>
+
+<xsl:template match="v">
+  <font color="#008000">&quot;<xsl:apply-templates/>&quot;</font>
+</xsl:template>
+
+<xsl:template match="m">
+  <p><tt><font color="#202080"><big>//</big>&#160;<xsl:apply-templates/></font></tt></p>
+</xsl:template>
+
+<xsl:template match="T">
+  &#160;&#160;&#160;
+</xsl:template>
+
+<!-- Here we manually include hml2htm.xslt to avoid file access -->
+
+<!-- 0 : Page production -->
+
+<xsl:template match="/*">
+  <html>
+    <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
+      <xsl:for-each select="@*"><xsl:choose>
+        <xsl:when test="name(.) = 'title'"><title><xsl:value-of select="."/></title></xsl:when>
+        <xsl:when test="name(.) = 'icon'"><link rel="shortcut icon" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'style'"><link rel="stylesheet" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'script'"><script type="text/javascript" src="{.}"/></xsl:when>
+        <xsl:otherwise><meta name="{name(.)}" content="{.}"/></xsl:otherwise> 
+        <!-- Possible improvement: take <meta http-equiv="$name" content="$value" /> or other <link rel="$name" href="$value" /> constructs into account !-->
+      </xsl:choose></xsl:for-each>
+    </head>
+    <body>
+      <xsl:if test="count(@title)=1"><h1><xsl:value-of select="@title"/>.</h1></xsl:if>
+      <xsl:apply-templates/>
+    </body>
+  </html>
+</xsl:template>
+
+<!-- 1 : Section production -->
+
+<xsl:template name="div">
+  <xsl:choose>
+    <xsl:when test="@class = 'table'">
+      <p><table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee"><xsl:call-template name="div-2"/></table><br/></p>
+    </xsl:when>
+    <xsl:when test="@class = 'ul' or @class = 'ol'">
+      <xsl:element name="{@class}"><xsl:call-template name="div-2"/></xsl:element>
+    </xsl:when>
+    <xsl:when test="../@class = 'ul' or ../@class = 'ol'"><li><xsl:call-template name="div-2"/></li></xsl:when>
+    <xsl:when test="../@class = 'table'"><tr><xsl:call-template name="div-2"/></tr></xsl:when>
+    <xsl:when test="../../@class = 'table'"><td valign="top"><xsl:call-template name="div-2"/></td></xsl:when>
+    <xsl:when test="@class = 'margin'"><div align="right"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'center'"><div align="center"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'tag'"><xsl:call-template name="tag"/></xsl:when>
+    <xsl:otherwise><div><xsl:call-template name="div-2"/></div></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+<xsl:template name="div-2">
+  <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@id)=1"><a name="{@id}"></a></xsl:if>
+  <xsl:if test="count(@title)=1"><xsl:choose>
+    <xsl:when test=".. = /"><h2><xsl:value-of select="@title"/>.</h2></xsl:when>
+    <xsl:when test="../.. = /"><h3><xsl:value-of select="@title"/>.</h3></xsl:when>
+    <xsl:when test="../../.. = /"><h4><xsl:value-of select="@title"/>.</h4></xsl:when>
+    <xsl:otherwise><b><xsl:value-of select="@title"/>.</b><xsl:text> </xsl:text></xsl:otherwise>
+  </xsl:choose></xsl:if>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- 1.1 : Pml construct description production -->
+
+<xsl:template name="tag"><table bgcolor="#eeeeee" width="90%">
+  <tr><td colspan="4"><b>{</b><xsl:text> </xsl:text><xsl:value-of select="@title"/></td></tr>
+  <tr><td align="center"><b>name</b></td><td align="center"><b>type</b></td><td align="center"><b>default value</b></td><td></td></tr>
+  <xsl:for-each select="param"><tr>
+     <td><font color="#505000"><xsl:value-of select="@name"/></font></td>
+     <td><font color="#990000"><xsl:value-of select="@type"/></font></td>
+     <td><xsl:choose>
+        <xsl:when test="count(@value)=1"><font color="#008000">"<xsl:value-of select="@value"/>"</font></xsl:when>
+        <xsl:otherwise><i>mandatory</i></xsl:otherwise>
+     </xsl:choose></td>
+     <td><xsl:apply-templates/></td>
+  </tr></xsl:for-each>
+  <tr><td colspan="4"><xsl:choose>
+    <xsl:when test="count(elements/@type) > 0">Structure: "<font color="#202080"><xsl:value-of select="elements/@type"/>"</font></xsl:when>
+    <xsl:otherwise><i>no element</i></xsl:otherwise>
+  </xsl:choose></td></tr>
+  <tr><td colspan="4"><hr/></td></tr>
+  <tr><td colspan="4">
+    <xsl:for-each select="*[name(.) != 'param' and name(.) != 'elements']"><xsl:apply-templates/></xsl:for-each>
+  </td></tr>
+  <tr><td colspan="4"><b>}</b></td></tr>
+</table></xsl:template>
+
+<!-- 2 : Span production -->
+
+<xsl:template match="s">
+  <span>
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </span>
+</xsl:template>
+<xsl:template match="b"><b><xsl:apply-templates/></b></xsl:template>
+<xsl:template match="i"><i><xsl:apply-templates/></i></xsl:template>
+<xsl:template match="c"><tt><xsl:apply-templates/></tt></xsl:template>
+<xsl:template match="S"><sup><xsl:apply-templates/></sup></xsl:template>
+<xsl:template match="I"><sub><xsl:apply-templates/></sub></xsl:template>
+
+<!-- 3 : Link production -->
+
+<xsl:template name="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'replace'"><script language="javascript">location.replace("<xsl:value-of select="@link"/>");</script></xsl:when>
+    <xsl:when test="@class = 'include'"><xsl:apply-templates select="document(@link)"/></xsl:when>
+    <xsl:when test="count(@link) = 1"><a href="{@link}"> 
+      <xsl:if test="count(@class)=1"><xsl:choose>
+        <xsl:when test="@class = 'newtab'"><xsl:attribute name="target">_blank</xsl:attribute></xsl:when>
+        <xsl:otherwise><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:otherwise>
+      </xsl:choose></xsl:if>
+      <xsl:if test="count(@icon) = 1"><img src="{@icon}" alt="{@text}"/></xsl:if>
+      <xsl:if test="count(@text)=1 and count(@icon)=1"><xsl:text> </xsl:text></xsl:if>
+      <xsl:if test="count(@text)=1"><xsl:value-of select="@text"/></xsl:if>
+      <xsl:if test="count(@text)=0 and count(@icon)=0">[.]</xsl:if>
+    </a></xsl:when>
+    <xsl:when test="count(@icon) = 1"><img src="{@icon}" alt="{@text}">
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    </img></xsl:when>
+    <xsl:when test="count(@text) = 1"><span>
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+      <xsl:value-of select="@text"/>
+    </span></xsl:when>
+  </xsl:choose>
+</xsl:template>
+
+<!--- 4: Code copy
+
+<xsl:template match="code">
+  <xsl:apply-templates mode ="code"/>
+</xsl:template>
+    
+<xsl:template match="*" mode="code"><xsl:text>
+</xsl:text>  
+  <xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+ -->
+ 
+<!--- 5: Spurious translation -->
+
+<xsl:template match="*"><xsl:text>
+</xsl:text>  
+<!--xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message-->
+<xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/hml2htm.xslt
===================================================================
--- src/org/javascool/builder/hml2htm.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/hml2htm.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+  <!-- This XSLT translates HML code to HTML 4 output -->
+
+<xsl:output 
+  method="html"
+  encoding="UTF-8"
+  doctype-public="-//W3C//DTD HTML 4.01//EN"
+  doctype-system="http://www.w3.org/TR/html4/strict.dtd"
+  indent="yes" />
+
+<!-- 0 : Page production -->
+
+<xsl:template match="/*">
+  <html>
+    <head>
+      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
+      <xsl:for-each select="@*"><xsl:choose>
+        <xsl:when test="name(.) = 'title'"><title><xsl:value-of select="."/></title></xsl:when>
+        <xsl:when test="name(.) = 'icon'"><link rel="shortcut icon" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'style'"><link rel="stylesheet" href="{.}"/></xsl:when>
+        <xsl:when test="name(.) = 'script'"><script type="text/javascript" src="{.}"/></xsl:when>
+        <xsl:otherwise><meta name="{name(.)}" content="{.}"/></xsl:otherwise> 
+        <!-- Possible improvement: take <meta http-equiv="$name" content="$value" /> or other <link rel="$name" href="$value" /> constructs into account !-->
+      </xsl:choose></xsl:for-each>
+    </head>
+    <body>
+      <xsl:if test="count(@title)=1"><h1><xsl:value-of select="@title"/>.</h1></xsl:if>
+      <xsl:apply-templates/>
+    </body>
+  </html>
+</xsl:template>
+
+<!-- 1 : Section production -->
+
+<xsl:template match="div|p"><xsl:call-template name="div"/></xsl:template>
+<xsl:template name="div">
+  <xsl:choose>
+    <xsl:when test="@class = 'table'">
+      <p><table align="center" width="90%" cellpadding="5px" bgcolor="#eeeeee"><xsl:call-template name="div-2"/></table><br/></p>
+    </xsl:when>
+    <xsl:when test="@class = 'ul' or @class = 'ol'">
+      <xsl:element name="{@class}"><xsl:call-template name="div-2"/></xsl:element>
+    </xsl:when>
+    <xsl:when test="../@class = 'ul' or ../@class = 'ol'"><li><xsl:call-template name="div-2"/></li></xsl:when>
+    <xsl:when test="../@class = 'table'"><tr><xsl:call-template name="div-2"/></tr></xsl:when>
+    <xsl:when test="../../@class = 'table'"><td valign="top"><xsl:call-template name="div-2"/></td></xsl:when>
+    <xsl:when test="@class = 'margin'"><div align="right"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'center'"><div align="center"><xsl:call-template name="div-2"/></div></xsl:when>
+    <xsl:when test="@class = 'tag'"><xsl:call-template name="tag"/></xsl:when>
+    <xsl:otherwise><div><xsl:call-template name="div-2"/></div></xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+<xsl:template name="div-2">
+  <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+  <xsl:if test="count(@id)=1"><a name="{@id}"></a></xsl:if>
+  <xsl:if test="count(@title)=1"><xsl:choose>
+    <xsl:when test=".. = /"><h2><xsl:value-of select="@title"/>.</h2></xsl:when>
+    <xsl:when test="../.. = /"><h3><xsl:value-of select="@title"/>.</h3></xsl:when>
+    <xsl:when test="../../.. = /"><h4><xsl:value-of select="@title"/>.</h4></xsl:when>
+    <xsl:otherwise><b><xsl:value-of select="@title"/>.</b><xsl:text> </xsl:text></xsl:otherwise>
+  </xsl:choose></xsl:if>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- 1.1 : Pml construct description production -->
+
+<xsl:template name="tag"><table bgcolor="#eeeeee" width="90%">
+  <tr><td colspan="4"><b>{</b><xsl:text> </xsl:text><xsl:value-of select="@title"/></td></tr>
+  <tr><td align="center"><b>name</b></td><td align="center"><b>type</b></td><td align="center"><b>default value</b></td><td></td></tr>
+  <xsl:for-each select="param"><tr>
+     <td><font color="#505000"><xsl:value-of select="@name"/></font></td>
+     <td><font color="#990000"><xsl:value-of select="@type"/></font></td>
+     <td><xsl:choose>
+        <xsl:when test="count(@value)=1"><font color="#008000">"<xsl:value-of select="@value"/>"</font></xsl:when>
+        <xsl:otherwise><i>mandatory</i></xsl:otherwise>
+     </xsl:choose></td>
+     <td><xsl:apply-templates/></td>
+  </tr></xsl:for-each>
+  <tr><td colspan="4"><xsl:choose>
+    <xsl:when test="count(elements/@type) > 0">Structure: "<font color="#202080"><xsl:value-of select="elements/@type"/>"</font></xsl:when>
+    <xsl:otherwise><i>no element</i></xsl:otherwise>
+  </xsl:choose></td></tr>
+  <tr><td colspan="4"><hr/></td></tr>
+  <tr><td colspan="4">
+    <xsl:for-each select="*[name(.) != 'param' and name(.) != 'elements']"><xsl:apply-templates/></xsl:for-each>
+  </td></tr>
+  <tr><td colspan="4"><b>}</b></td></tr>
+</table></xsl:template>
+
+<!-- 2 : Span production -->
+
+<xsl:template match="s">
+  <span>
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </span>
+</xsl:template>
+<xsl:template match="b"><b><xsl:apply-templates/></b></xsl:template>
+<xsl:template match="i"><i><xsl:apply-templates/></i></xsl:template>
+<xsl:template match="c"><tt><xsl:apply-templates/></tt></xsl:template>
+<xsl:template match="S"><sup><xsl:apply-templates/></sup></xsl:template>
+<xsl:template match="I"><sub><xsl:apply-templates/></sub></xsl:template>
+
+<!-- 3 : Link production -->
+
+<xsl:template match="l"><xsl:call-template name="l"/></xsl:template>
+<xsl:template name="l">
+  <xsl:choose>
+    <xsl:when test="@class = 'replace'"><script language="javascript">location.replace("<xsl:value-of select="@link"/>");</script></xsl:when>
+    <xsl:when test="@class = 'include'"><xsl:apply-templates select="document(@link,.)"/></xsl:when>
+    <xsl:when test="count(@link) = 1"><a href="{@link}"> 
+      <xsl:if test="count(@class)=1"><xsl:choose>
+        <xsl:when test="@class = 'newtab'"><xsl:attribute name="target">_blank</xsl:attribute></xsl:when>
+        <xsl:otherwise><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:otherwise>
+      </xsl:choose></xsl:if>
+      <xsl:if test="count(@icon) = 1"><img src="{@icon}" alt="{@text}"/></xsl:if>
+      <xsl:if test="count(@text)=1 and count(@icon)=1"><xsl:text> </xsl:text></xsl:if>
+      <xsl:if test="count(@text)=1"><xsl:value-of select="@text"/></xsl:if>
+      <xsl:if test="count(@text)=0 and count(@icon)=0">[.]</xsl:if>
+    </a></xsl:when>
+    <xsl:when test="count(@icon) = 1"><img src="{@icon}" alt="{@text}">
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+    </img></xsl:when>
+    <xsl:when test="count(@text) = 1"><span>
+      <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:if>
+      <xsl:value-of select="@text"/>
+    </span></xsl:when>
+  </xsl:choose>
+</xsl:template>
+
+<!--- 4: Code copy
+
+<xsl:template match="code">
+  <xsl:apply-templates mode ="code"/>
+</xsl:template>
+    
+<xsl:template match="*" mode="code"><xsl:text>
+</xsl:text>  
+  <xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+ -->
+ 
+<!--- 5: Spurious translation -->
+
+<xsl:template match="*"><xsl:text>
+</xsl:text>  
+<!--xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message-->
+<xsl:element name="{name(.)}">
+  <xsl:for-each select="@*"><xsl:attribute name="{name(.)}"><xsl:value-of select="."/></xsl:attribute></xsl:for-each>
+  <xsl:apply-templates/>
+</xsl:element>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/htm2hml.xslt
===================================================================
--- src/org/javascool/builder/htm2hml.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/htm2hml.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+  <!-- This XSLT translates HTNML to HML constructs -->
+
+<xsl:output method="xml" encoding="utf-8" omit-xml-declaration="yes"/>
+
+<!--- 1: Division translation -->
+
+<xsl:template match="ul|ol|table">
+  <div class="{name(.)}"> 
+    <xsl:apply-templates/>
+  </div>
+</xsl:template>
+
+<xsl:template match="div|p|li|tr|td">
+  <div>
+    <xsl:if test="count(@title)=1"><xsl:attribute name="title"><xsl:value-of select="@title"/></xsl:attribute></xsl:if>
+    <xsl:choose>
+      <xsl:when test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="@class"/></xsl:attribute></xsl:when>
+      <xsl:when test="count(@align)=1"><xsl:attribute name="class"><xsl:value-of select="@align"/></xsl:attribute></xsl:when>
+      <xsl:when test="count(@valign)=1"><xsl:attribute name="class"><xsl:value-of select="@valign"/></xsl:attribute></xsl:when>
+    </xsl:choose>
+    <xsl:if test="count(@id)=1"><xsl:attribute name="id"><xsl:value-of select="@id"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </div>
+</xsl:template>
+
+<!--- 2: Span translation -->
+
+<xsl:template match="span">
+  <s>    
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="class"/></xsl:attribute></xsl:if>
+    <xsl:apply-templates/>
+  </s>
+</xsl:template>
+<xsl:template match="b|i|u">
+  <xsl:element name="{name(.)}"><xsl:apply-templates/></xsl:element>
+</xsl:template>
+<xsl:template match="tt"><c><xsl:apply-templates/></c></xsl:template>
+<xsl:template match="sup"><S><xsl:apply-templates/></S></xsl:template>
+<xsl:template match="sub"><I><xsl:apply-templates/></I></xsl:template>
+
+<!--- 3: Link translation -->
+
+<xsl:template match="a">
+  <l>    
+    <xsl:if test="count(@class)=1"><xsl:attribute name="class"><xsl:value-of select="class"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(@href)=1"><xsl:attribute name="link"><xsl:value-of select="@href"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(img/@src)=1"><xsl:attribute name="icon"><xsl:value-of select="img/@src"/></xsl:attribute></xsl:if>
+    <xsl:attribute name="text"><xsl:value-of select="text()"/></xsl:attribute>
+  </l>
+</xsl:template>
+
+<xsl:template match="img">
+  <l class="icon">    
+    <xsl:if test="count(@src)=1"><xsl:attribute name="icon"><xsl:value-of select="@src"/></xsl:attribute></xsl:if>
+    <xsl:if test="count(@alt)=1"><xsl:attribute name="text"><xsl:value-of select="@alt"/></xsl:attribute></xsl:if>
+  </l>
+</xsl:template>
+
+<!--- 4: Spurious translation 
+
+<xsl:template match="br|hr|form|input|select|option">
+  <xsl:message>Unexpected tag: <xsl:value-of select="name(.)"/> !!</xsl:message>
+</xsl:template>
+
+<xsl:template match="*">
+  <xsl:message>Undefined tag: <xsl:value-of select="name(.)"/> !!</xsl:message>
+</xsl:template> -->
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/ProgletsBuilder.java
===================================================================
--- src/org/javascool/builder/ProgletsBuilder.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/ProgletsBuilder.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,488 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.builder;
+
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Xml2Xml;
+import org.javascool.tools.Pml;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+import java.util.ArrayList;
+import java.util.Date;
+import org.javascool.Core;
+import org.javascool.About;
+
+/** Cette factory contient les mécanismes de construction d'une application Java's Cool avec des proglets.
+ *
+ * @see <a href="ProgletsBuilder.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletsBuilder {
+    /** Définit le file separator dans une expression régulière. */
+    private static final String fileRegexSeparator = File.separator.equals("\\") ? "\\\\" : File.separator;
+
+    // @factory
+    private ProgletsBuilder() {
+    }
+
+    /** Définit si la construction se fait avec tous les messages intermédiaires. */
+    public static void setVerbose(boolean v) {
+        verbose = v;
+    }
+    static boolean verbose = false;
+    /** Teste si cette version de Java'sCool a la capacité de créer des jar.  */
+    public static boolean canBuildProglets() {
+        try {
+            Class.forName("com.icl.saxon.TransformerFactoryImpl");
+            return true;
+        } catch (Throwable e) {
+            return false;
+        }
+    }
+
+    /** Renvoie les proglets à construire. 
+     * @param names Noms ou suffixes des proglets à sélectionner.
+     * @return La liste des noms absolus des répertoires des proglets trouvées
+     */
+    public static String[] getProglets(String[] names) {
+        ArrayList<String> proglets = new ArrayList<String>();
+         for (String dir : FileManager.list(System.getProperty("user.dir"))) {
+            if (FileManager.exists(dir + File.separator + "proglet.pml")) {
+	      boolean found = names == null;
+	      if (names != null)
+		for(String name : names) 
+		  found |= dir.endsWith(name);
+	      if (found)
+                proglets.add(dir);
+            }
+            }
+        return proglets.toArray(new String[proglets.size()]);
+    }
+   /**
+    * @see #getProglets(String[])
+    */
+    public static String[] getProglets() {
+      return getProglets(null);
+    }
+    /** Construit une nouvelle archive avec les proglets proposées.
+     * @param proglets Les proglets sélectionnées. Par défaut toutes les proglets disponibles.
+     * @param targetDir Le répertoire cible dans lequel la construction se fait. Si null utilise un répertoire temporaire.
+     * @param webdoc Si true compile la javadoc et les jars de chaque proglet (false par défaut).
+     * @return La valeur true si la construction est sans erreur, false sinon.
+     */
+    public static boolean build(String[] proglets, String targetDir, boolean webdoc) {
+        if (!canBuildProglets()) {
+            throw new IllegalArgumentException("Mauvaise configuration du builder, il faut utiliser le bon jar !");
+        }
+        try {
+            if (proglets.length == 0) {
+                throw new IllegalArgumentException("Aucune proglet à construire");
+            }
+            // Définition de la jarre cible.
+            String targetJar = System.getProperty("user.dir") + File.separator + "javascool-proglets.jar";
+            new File(targetJar).delete();
+            log("Scan des proglets à partir du répertoire: " + System.getProperty("user.dir"));
+            // Installation du répertoire de travail.
+            File buildDir;
+            String jarDir, progletsDir;
+            // Création des répertoires cible.
+            {
+                if (targetDir == null) {
+                    buildDir = new File(".build");
+                } else {
+                    buildDir = new File(targetDir);
+                    if (new File(".").equals(buildDir.getCanonicalFile())) {
+                        throw new IllegalArgumentException("Le répertoire des proglets et celui du build ne peuvent pas être identiques");
+                    }
+                }
+		JarManager.rmDir(buildDir);
+		buildDir.mkdirs();
+                jarDir = buildDir + File.separator + "jar";
+                progletsDir = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "proglets";
+                new File(progletsDir).mkdirs();
+            }
+            DialogFrame.setUpdate("Installation 1/2", 10);
+            // Expansion des classes javascool et des proglets existantes dans les jars
+            {
+                log("Extraction des Jars du sketchbook", true);
+                // Expansion des jars du sketchbook
+                for (String jar : FileManager.list(System.getProperty("user.dir"), ".*\\.jar")) {
+                    if (!jar.matches(".*" + fileRegexSeparator + "javascool-(builder|proglets).jar")) {
+                        JarManager.jarExtract(jar, jarDir);
+                    }
+                }
+                // Expansion des jars des proglets
+                for (String proglet : proglets) {
+                    for (String jar : FileManager.list(proglet, ".*\\.jar", 2)) {
+                        JarManager.jarExtract(jar, jarDir);
+                    }
+                }
+                // Expansion des jars de javascool
+                String javascoolJar = Core.javascoolJar();
+                log("Extraction de Java's cool", true);
+                String libs[] = {"org/javascool", "org/fife", "com/sun/tools/javac", "sun/tools/java", "com/sun/source/tree", "com/sun/source/util"};
+                for(String lib : libs)
+                  JarManager.jarExtract(javascoolJar, jarDir,lib);
+            }
+            DialogFrame.setUpdate("Installation 2/2", 20);
+            Integer level = 20;
+            int up = (10 / proglets.length == 0 ? 1 : 10 / proglets.length);
+            // Construction des proglets
+            for (String proglet : proglets) {
+                ProgletBuild build = new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir);
+                String name = new File(proglet).getName();
+                log("Compilation de " + name + " ...");
+                    DialogFrame.setUpdate("Construction de " + name + " 1/4", level += up);
+                    build.copyFiles();
+                    DialogFrame.setUpdate("Construction de " + name + " 2/4", level += up);
+                    build.checkProglet();
+                    DialogFrame.setUpdate("Construction de " + name + " 3/4", level += up);
+                    build.convertHdocs(false);
+                if (!build.isprocessing) {
+                    DialogFrame.setUpdate("Construction de " + name + " 4/4", level += up);
+                    build.createHtmlApplet();
+                    if (webdoc)
+                        build.javadoc(jarDir);
+                }
+            }
+            // Lancement de la compilation de tous les java des proglets
+            {
+                log("Compilation des fichiers java");
+                String[] javaFiles = FileManager.list(progletsDir, ".*\\.java", 2);
+                if (javaFiles.length > 0)
+		  javac(jarDir, javaFiles);
+            }
+            DialogFrame.setUpdate("Finalisation 1/2", 90);
+            System.out.println("Compilation des jarres .. ");
+            // Création des jarres avec le manifest
+            {
+                String version = "Java'sCool v4 on \"" + new Date() + "\" Revision #" + About.revision;
+                Pml manifest = new Pml().set("Main-Class", "org.javascool.Core").
+                        set("Manifest-version", version).
+                        set("Created-By", "inria.fr (javascool.gforge.inria.fr) ©INRIA: CeCILL V2 + CreativeCommons BY-NC-ND V2").
+                        set("Implementation-URL", "http://javascool.gforge.inria.fr").
+                        set("Implementation-Vendor", "javascool@googlegroups.com, ou=javascool.gforge.inria.fr, o=inria.fr, c=fr").
+                        set("Implementation-Version", version).
+                        save(buildDir + "/manifest.jmf");
+                // Création des archives pour chaque proglet
+                if (webdoc) {
+                    for (String proglet : proglets) {
+                        String name = new File(proglet).getName();
+                        String javascoolPrefix = "org" + File.separator + "javascool" + File.separator;
+                        String jarEntries[] = {
+                            javascoolPrefix + "Core", javascoolPrefix + "About", "org" + File.separator + "fife",
+                            javascoolPrefix + "builder", javascoolPrefix + "core", javascoolPrefix + "gui", javascoolPrefix + "macros", javascoolPrefix + "tools", javascoolPrefix + "widgets",
+                            javascoolPrefix + "proglets" + File.separator + name};
+                        String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
+                        JarManager.jarCreate(tmpJar, buildDir + "/manifest.jmf", jarDir, jarEntries);
+			// Reconstruction des pages webs en mode web
+			new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir).convertHdocs(true);
+                    }
+                }
+                // Création de l'archive principale
+                JarManager.jarCreate(targetJar, buildDir + "/manifest.jmf", jarDir);
+                // Signature et déplacement des "javascool-proglet-"+name+".jar" dans les répetoires des proglets
+                if (webdoc) {
+                    System.out.print("Signature des jarres: ");
+                    System.out.flush();
+                    for (String proglet : proglets) {
+                        String name = new File(proglet).getName();
+                        String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
+                        String signedJar = progletsDir + File.separator + name + File.separator + "javascool-proglet-" + name + ".jar";
+                        if (new File(signedJar).getParentFile().exists()) {
+                            System.out.print(name + " .. ");
+                            String keystore = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "builder" + File.separator + "javascool.key";
+                            String args = "-storepass\tjavascool\t-keypass\tmer,d,azof\t-keystore\t" + keystore + "\t-signedjar\t" + signedJar + "\t" + tmpJar + "\tjavascool";
+                            sun.security.tools.JarSigner.main(args.split("\t"));
+
+                        }
+                    }
+                    System.out.println("ok.");
+                }
+                DialogFrame.setUpdate("Finalisation 2/2", 100);
+            }
+            if (targetDir == null) {
+	      // JarManager.rmDir(buildDir);
+            }
+            System.out.println("Construction achevée avec succès: «" + targetJar + "» a été créé");
+            System.out.println("\tIl faut lancer «" + targetJar + "» pour tester/utiliser les proglets.");
+            return true;
+        } catch (Exception e) {
+            e.printStackTrace(System.err);
+            System.out.println("Erreur inopinée lors de la construction (" + e.getMessage() + "): corriger l'erreur et relancer la construction");
+            return false;
+        }
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets, String targetDir) {
+        return build(proglets, targetDir, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets, boolean webdoc) {
+        return build(proglets, null, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String targetDir, boolean webdoc) {
+        return build(getProglets(), targetDir, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String[] proglets) {
+        return build(proglets, null, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(String targetDir) {
+        return build(getProglets(), targetDir, false);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build(boolean webdoc) {
+        return build(getProglets(), null, webdoc);
+    }
+
+    /**
+     * @see #build(String[], String, boolean)
+     */
+    public static boolean build() {
+        return build(getProglets(), null, false);
+    }
+
+    /** Lance la compilation java sur un groupe de fichiers. */
+  private static void javac(String classPath, String[] javaFiles) {
+    // if (!Java2Class.compile(javaFiles, true)) throw new IllegalArgumentException("Erreur de compilation java");
+    try {
+      // Appel au compilateur en spécifiant le classpath
+      String args[] = new String[javaFiles.length + 3];
+      args[0] = "-cp";
+      args[1] = classPath;
+      args[2] = "-Xlint";
+      System.arraycopy(javaFiles, 0, args, 3, javaFiles.length);
+      	 StringWriter out = new StringWriter();
+	 Class.forName("com.sun.tools.javac.Main").
+	   getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter")).
+	   invoke(null, (Object) args, new PrintWriter(out));
+         String sout = out.toString().trim();
+         if (sout.length() > 0) {
+           System.out.println("Erreur de compilation java:\n" + sout);
+	   throw new IllegalArgumentException("Erreur de compilation java");
+        }
+    } catch(Throwable e) {
+      System.err.println("Echec de compilation :"+ e);
+	throw new IllegalArgumentException("Erreur de compilation java");
+    }
+  }
+
+    /** Construction de javadoc avec sources en java2html. */
+    private static void javadoc(String name, String classPath, String srcDir, String apiDir) throws IOException {
+        apiDir = new File(apiDir).getCanonicalPath();
+        new File(apiDir).mkdirs();
+        String files[] = FileManager.list(srcDir, ".*\\.java$");
+        if (files.length > 0) {
+            {
+                // Construit l'appel à javadoc
+                String argv = "-quiet\t-classpath\t" + classPath + "\t-d\t" + apiDir
+		  + "\t-link\thttp://download.oracle.com/javase/6/docs/api"
+		  + "\t-public\t-author\t-windowtitle\tJava's Cool v4\t-doctitle\tJava's Cool v4\t-version\t-nodeprecated\t-nohelp\t-nonavbar\t-notree\t-charset\tutf-8";
+                for (String f : files) {
+                    argv += "\t" + f;
+                }
+                // Lance javadoc
+                try {
+                    com.sun.tools.javadoc.Main.execute(argv.split("\t"));
+                } catch (Throwable e) {
+                    throw new IOException(e);
+                }
+            }
+            // Construit les sources en HTML à partir de java2html
+            {
+                // Lance java2html
+                Jvs2Html.runDirectory(srcDir, apiDir + File.separator + "org" +  File.separator + "javascool" +  File.separator + "proglets"  +  File.separator + name);
+            }
+        }
+    }
+
+    /** Envoie un message de log dans la console.
+     * @param text Le message
+     * @param onlyVerbose Ne s'affiche que si l'option -v est activé
+     */
+    public static void log(String text, boolean onlyVerbose) {
+        if (onlyVerbose) {
+            if (verbose) {
+                System.out.println(text);
+            }
+        } else {
+            System.out.println(text);
+        }
+    }
+
+    /** Imprime un message dans la console
+     * @see ProgletsBuilder#log(java.lang.String, boolean) 
+     */
+    public static void log(String text) {
+        log(text, false);
+    }
+
+    /** Contôleur pour la compilation d'une proglet. */
+    private static class ProgletBuild {
+
+        /** Le nom de la proglet */
+        private String name;
+        /** Le répertoire de la proglet à compiler */
+        private String progletSrc;
+        /** Le répertoire de la proglet compilée */
+        private String progletDir;
+        /** Le fichier Pml d'information de la proglet */
+        private Pml pml;
+        /** Le dossier du jar final */
+        private String jarDest;
+        /** Vrai si la proglet est processing */
+        private boolean isprocessing;
+
+        /** Crée un nouveau contôleur pour la compilation d'une proglet.
+         * @param name Le nom de la proglet
+         * @param progletDir Le répertoire de la proglet à compiler
+         * @param pml Le fichier Pml d'information de la proglet
+         * @param jarDest Le dossier du jar final
+         */
+        public ProgletBuild(String name, String progletDir, Pml pml, String jarDest) {
+            this.name = name = name != null ? new File(name).getName() : "?";
+            this.pml = pml = pml != null ? pml : new Pml().load(progletDir + File.separator + "proglet.pml");
+            try {
+	      this.progletSrc = progletDir != null ? new File(progletDir).getAbsolutePath() : "";
+            } catch (Exception e) {
+                throw new RuntimeException("Le dossier source de " + name + " n'existe pas");
+            }
+            this.jarDest = jarDest = jarDest != null ? new File(jarDest).getAbsolutePath() : "";
+            this.progletDir = jarDest + "/org/javascool/proglets/".replace("/", File.separator) + name;
+            this.isprocessing = pml.getBoolean("processing");
+	}
+
+        /** Lit automatiquement le fichier Pml
+         * @see ProgletBuild#ProgletBuild(java.lang.String, java.lang.String, org.javascool.tools.Pml, java.lang.String) 
+         */
+        public ProgletBuild(String name, String progletDir, String jarDest) {
+            this(name, progletDir, null, jarDest);
+        }
+
+        /** Copie les fichiers de la proglet de la source à la destination. */
+        public void copyFiles() {
+            log("Copie des fichiers de " + name, true);
+            try {
+                new File(progletDir).mkdirs();
+                JarManager.copyFiles(progletSrc, progletDir);
+            } catch (IOException ex) {
+                throw new RuntimeException("Erreur lors de la copie des fichiers de " + name, ex);
+            }
+            // Efface les répertoires applet et les jar dans la cible
+            {
+                JarManager.rmDir(new File(progletDir, "applet"));
+                for (String jar : FileManager.list(progletDir, ".*\\.jar"))
+                    new File(jar).delete();
+            }
+        }
+        /** Vérifie si la proglet respect les specifications */
+        public void checkProglet() {
+            log("Vérification de la proglet " + name, true);
+            boolean error = false;
+            if (!(name.matches("[a-zA-Z][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+") && name.length() <= 20)) {
+                System.out.println("Le nom de la proglet «" + name + "» est bizarre:"+
+				   " il ne doit contenir que des lettres faire au moins quatre caractères et au plus seize et démarrer par une lettre minuscule");
+                error = true;
+            }
+            if (!FileManager.exists(progletDir + File.separator + "help.xml")) {
+                System.out.println("Pas de fichier d'aide pour " + name + ", la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (FileManager.exists(progletDir + File.separator + "completion.xml")) {
+                String err = Xml2Xml.run(FileManager.load(progletDir + File.separator + "completion.xml"),
+                        FileManager.load(jarDest + "/org/javascool/builder/completionok.xslt".replace("/", File.separator))).trim();
+                if (err.length() > 0) {
+                    System.out.println("Il y a une erreur dans le fichier completion.xml : «" + err.replaceAll("\\s+", " ") + "», la proglet ne sera pas construite.");
+                    error = true;
+                }
+            }
+            if (!pml.isDefined("author")) {
+                System.out.println("Le champ «author» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (!pml.isDefined("title")) {
+                System.out.println("Le champ «title» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
+                error = true;
+            }
+            if (isprocessing && !(pml.isDefined("width") && pml.isDefined("height"))) {
+                System.out.println("Les champ «width» et «height» ne sont pas définis dans " + name + "/proglet.pml, la proglet processing ne sera pas construite.");
+                error = true;
+            }
+            pml.save(progletDir + File.separator + "proglet.php");
+            if (error) {
+                throw new IllegalArgumentException("La proglet ne respecte pas les spécifications");
+            }
+        }
+
+        /** Convertit les XML en HTM, sauf le completion.xml. */
+        public void convertHdocs(boolean webdoc) {
+            log("Convertion des HDocs pour " + name, true);
+            for (String doc : FileManager.list(progletDir, ".*\\.xml"))
+	      if (!new File(doc).getName().equals("completion.xml")) {
+		try {
+		  log("Convertion de " + new File(doc).getName(), true);
+		  // Conversion des pages hdoc pour le web
+		  FileManager.save(doc.replaceFirst("\\.xml", "\\.htm"),
+				   Xml2Xml.run(FileManager.load(doc, true),
+					       FileManager.load(jarDest + "/org/javascool/builder/hdoc2htm.xslt".replace("/", File.separator)),
+					       "output", webdoc ? "web" : "jvs"), false, true);
+		} catch (IllegalArgumentException e) {		  throw new IllegalArgumentException("dans " + new File(doc).getName() + " : " + e.getMessage());
+		}
+                }
+            // Construit les sources exemples en HTML à partir de java2html
+            {
+                // Lance java2html
+                Jvs2Html.runDirectory(progletDir, progletDir);
+            }
+        }
+
+        /** Crée la page html de l'applet de la proglet */
+        public void createHtmlApplet() {
+            log("Création de l'applet HTML pour " + name, true);
+            FileManager.save(progletDir + File.separator + "applet-tag.htm",
+                    "<applet width='560' height='620' code='org.javascool.widget"
+                    + "s.PanelApplet' archive='./proglets/" + name + "/javascool"
+                    + "-proglet-" + name + ".jar'><param name='panel' value='org"
+                    + ".javascool.proglets." + name + ".Panel'/><pre>Impossible "
+                    + "de lancer " + name + ": Java n'est pas installé ou mal co"
+                    + "nfiguré</pre></applet>\n");
+        }
+
+        /** Génère la javadoc de la proglet */
+        public void javadoc(String classPath) {
+            try {
+                log("Création de la javadoc pour " + name, true);
+                ProgletsBuilder.javadoc(name, classPath, progletDir, progletDir + File.separator + "api");
+            } catch (IOException ex) {                throw new RuntimeException("Erreur lors de la génération de la javadoc");
+            }
+        }
+    }
+}
Index: src/org/javascool/builder/JarManager.java
===================================================================
--- src/org/javascool/builder/JarManager.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/JarManager.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,168 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.builder;
+
+import org.javascool.tools.FileManager;
+
+import java.io.File;
+import java.io.OutputStream;
+import java.io.InputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+
+import java.util.Enumeration;
+import java.util.jar.Attributes;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+
+/** Met à disposition des fonctions de gestion de jar et répertoires de déploiement. */
+public class JarManager {
+  // @factory
+  private JarManager() {}
+
+  /** Extrait une arborescence d'un jar.
+   * @param jarFile Jarre dont on extrait les fichiers.
+   * @param destDir Dossier où on déploie les fichiers.
+   * @param jarEntry Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
+   */
+  public static void jarExtract(String jarFile, String destDir, String jarEntry) {
+    try {
+      ProgletsBuilder.log("Extract files from " + jarFile + " to " + destDir + ((!jarEntry.isEmpty()) ? " which start with " + jarEntry : ""),true);
+      JarFile jf = new JarFile(jarFile);
+      JarInputStream jip=new JarInputStream(new FileInputStream(jarFile));
+      Enumeration<JarEntry> entries = jf.entries();
+      JarEntry je;
+      while((je = jip.getNextJarEntry())!=null) {
+        if((jarEntry.isEmpty()?true:je.getName().startsWith(jarEntry)) && !je.isDirectory()&&!je.getName().contains("META-INF")) {
+          File dest = new File(destDir + File.separator + je.getName());
+          dest.getParentFile().mkdirs();
+          copyStream(jip, new FileOutputStream(dest));
+        }
+      }
+      jip.close();
+      
+    } catch(Exception ex) { throw new IllegalStateException(ex);
+    }
+  }
+  /**
+   * @see #jarExtract(String, String, String)
+   */
+  public static void jarExtract(String jarFile, String destDir) {
+    jarExtract(jarFile, destDir, "");
+  }
+  /** Crée un jar à partir d'une arborescence.
+   * @param jarFile Jar à construire. Elle est détruite avant d'être crée.
+   * @param mfFile Fichier de manifeste (obligatoire).
+   * @param srcDir Dossier source avec les fichiers à mettre en jarre.
+   * @param jarEntries Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
+   */
+  public static void jarCreate(String jarFile, String mfFile, String srcDir, String[] jarEntries) {
+    try {
+        ProgletsBuilder.log("Création du jar "+jarFile,true);
+     File parent = new File(jarFile).getParentFile();
+     if (parent != null) parent.mkdirs();
+      new File(jarFile).delete();
+      srcDir = new File(srcDir).getCanonicalPath();
+      Manifest manifest = new Manifest(new FileInputStream(mfFile));
+      manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
+      JarOutputStream target = new JarOutputStream(new FileOutputStream(jarFile), manifest);
+      copyFileToJar(new File(srcDir), target, new File(srcDir), jarEntries);
+      target.close();
+    } catch(Exception ex) { ex.printStackTrace(); throw new RuntimeException(ex);
+    }
+  }  
+  /**
+   * @see #jarCreate(String, String, String, String[])
+   */
+  public static void jarCreate(String jarFile, String mfFile, String srcDir) {
+    jarCreate(jarFile, mfFile, srcDir, null);
+  }
+  /** Copie un répertoire/fichier dans un autre en oubliant les svn.
+   * @param srcDir Dossier source.
+   * @param dstDir Dossier cible.
+   */
+  public static void copyFiles(String srcDir, String dstDir) throws IOException {
+    if(new File(srcDir).isDirectory()) {
+      if(!new File(srcDir).getName().equals(".svn"))
+        for(String s : FileManager.list(srcDir)) {
+          String d = dstDir + File.separator + new File(s).getAbsoluteFile().getName();
+          copyFiles(s, d);
+        }
+    } else {
+      new File(dstDir).getParentFile().mkdirs();
+      copyStream(new FileInputStream(srcDir), new FileOutputStream(dstDir));
+    }
+  }
+  // Ajoute un stream a un jar
+  private static void copyFileToJar(File source, JarOutputStream target, File root, String[] jarEntries) throws IOException {
+    // Teste si la source est dans les fichier à extraire
+    if (jarEntries != null) {
+      boolean skip = true;
+      for(String jarEntry : jarEntries) {
+	String entry = root.toString() + File.separator + jarEntry;
+	skip &= !(entry.startsWith(source.toString()) | source.toString().startsWith(entry));
+      }
+      if (skip)
+	return;
+    }
+    BufferedInputStream in = null;
+    try {
+      if(source.isDirectory()) {
+        String name = source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/");
+        if(!name.isEmpty() && (!source.equals(root))) {
+          if(!name.endsWith("/"))
+            name += "/";
+          JarEntry entry = new JarEntry(name);
+          entry.setTime(source.lastModified());
+          target.putNextEntry(entry);
+          target.closeEntry();
+        }
+        for(File nestedFile : source.listFiles())
+          copyFileToJar(nestedFile, target, root, jarEntries);
+      } else {
+	JarEntry entry = new JarEntry(source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/"));
+	entry.setTime(source.lastModified());
+	target.putNextEntry(entry);
+	copyStream(new BufferedInputStream(new FileInputStream(source)), target);
+      }
+    } catch(Throwable e) {
+      e.printStackTrace(System.out); throw new IllegalStateException(e);
+    }
+  }
+  // Copy un stream dans un autre
+  private static void copyStream(InputStream in, OutputStream out) throws IOException {
+    InputStream i = in instanceof JarInputStream?in :new BufferedInputStream(in, 2048);
+    OutputStream o = out instanceof JarOutputStream ? out : new BufferedOutputStream(out, 2048);
+    byte data[] = new byte[2048];
+    for(int c; (c = i.read(data, 0, 2048)) != -1;)
+      o.write(data, 0, c);
+    if(o instanceof JarOutputStream)
+      ((JarOutputStream) o).closeEntry();
+    else
+      o.close();
+    if(i instanceof JarInputStream){
+        ((JarInputStream)i).closeEntry();
+    } else {
+        i.close();
+    }
+  }
+  /** Détruit récursivement un fichier ou répertoire.
+   * * <p>Irréversible: à utiliser avec la plus grande prudence.</p>
+   */
+  public static void rmDir(File dir) {
+    if (dir.isDirectory())
+      for(File f : dir.listFiles())
+	rmDir(f);
+    dir.delete();
+  }
+}
Index: src/org/javascool/builder/javascool.key
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/builder/javascool.key
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/builder/Jvs2Html.java
===================================================================
--- src/org/javascool/builder/Jvs2Html.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/Jvs2Html.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,80 @@
+package org.javascool.builder;
+
+import de.java2html.converter.JavaSource2HTMLConverter;
+import de.java2html.javasource.JavaSource;
+import de.java2html.javasource.JavaSourceParser;
+import de.java2html.javasource.JavaSourceType;
+import de.java2html.options.JavaSourceConversionOptions;
+import de.java2html.options.JavaSourceStyleEntry;
+import de.java2html.util.RGB;
+import java.io.File;  
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+
+import org.javascool.tools.FileManager;
+
+/** Convertit une portion de source Java ou Jvs en Html colorisé.
+ * <p>Note: utilise une version patchée de <a href="http://www.java2html.de">java2html</a>, disponible dans <a href="http://code.google.com/p/javascool/source/browse/work/lib/jvs2html.jar">jvs2html.jar</a>, qui doit être dans le CLASSPATH.</p></p>
+ *
+ * @see <a href="Jvs2Html.java.html">code source</a>
+ * @serial exclude
+ */
+public class Jvs2Html {
+    // @factory
+
+    private Jvs2Html() {
+    }
+
+    /** Convertit une portion de source Java ou JVs en Html colorisé..
+     * @param code Le code Java ou Jvs.
+     * @return Le code Html généré.
+     * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'éxecution.
+     */
+    public static String run(String code) {
+        try {
+            StringReader stringReader = new StringReader(code);
+            JavaSource source = new JavaSourceParser().parse(stringReader);
+            JavaSource2HTMLConverter converter = new JavaSource2HTMLConverter();
+            JavaSourceConversionOptions options = JavaSourceConversionOptions.getDefault();
+            options.getStyleTable().put(JavaSourceType.KEYWORD, new JavaSourceStyleEntry(RGB.ORANGE, true, false));
+            StringWriter writer = new StringWriter();
+            converter.convert(source, options, writer);
+            return "<pre>"+writer.toString().replace("\n", "").replace("<br/>", "\n").replace("&#160;&#160;&#160;&#160;", "\t") +"</pre>";
+        } catch (IOException e) {
+            throw new RuntimeException(e + " when converting: «" + code + "»");
+        }
+    }
+
+    /** Convertit un répertoire de source Java vers un autre répertoire en source HTML Colorisé.
+     * @param srcDir Le répertoire source
+     * @param destDir Le répertoire de destination
+     * @return true si la convertion a réussit
+     * @throws RuntimeException si il y a une erreur durant la convertion
+     */
+    public static boolean runDirectory(String srcDir, String destDir) {
+        try {
+            File src = new File(srcDir);
+            File dest = new File(destDir);
+            String[] fileList = FileManager.list(srcDir);
+            for (String file : fileList) {
+                if (file.endsWith(".java") || file.endsWith(".jvs") ) {
+                    FileManager.save(dest.getCanonicalPath() + File.separator + new File(file).getName() + ".html", Jvs2Html.run(FileManager.load(file)));
+                }
+            }
+            return true;
+        } catch (Exception e) {
+            throw new RuntimeException(e + " when converting: «" + srcDir + "»");
+        }
+    }
+
+    /** Lanceur de la conversion d'une portion de source Java ou Jvs en Html colorisé.
+     * @param usage <tt>java org.javascool.builder.Jvs2Html input-file [output-file]</tt>
+     */
+    public static void main(String[] usage) {
+        // @main
+        if (usage.length > 0) {
+            FileManager.save(usage.length > 1 ? usage[1] : "stdout:", run(FileManager.load(usage[0])));
+        }
+    }
+}
Index: src/org/javascool/builder/DialogFrame.java
===================================================================
--- src/org/javascool/builder/DialogFrame.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/DialogFrame.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,175 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.builder;
+
+import org.javascool.widgets.MainFrame;
+import javax.swing.JPopupMenu;
+import javax.swing.JLabel;
+import javax.swing.JCheckBox;
+import javax.swing.JMenuItem;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.File;
+import org.javascool.widgets.Console;
+import javax.swing.JProgressBar;
+import java.util.ArrayList;
+import javax.swing.JButton;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import org.javascool.About;
+import org.javascool.Build;
+
+/** Définit l'interface graphique pour la construction de proglets.
+ *
+ * @see <a href="DialogFrame.java.html">code source</a>
+ * @serial exclude
+ */
+public class DialogFrame {
+
+    /** Ouvre une console indépendante pour lancer la construction de proglets. */
+    public static void startFrame() {
+
+        jCreatorButton=Console.getInstance().getToolBar().addTool("Créer une nouvelle proglet", "org/javascool/widgets/icons/new.png",
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        startProgletCreatorMenu();
+                    }
+                });
+        jBuilderButton=Console.getInstance().getToolBar().addTool("Lancement du builder", "org/javascool/widgets/icons/compile.png",
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        startProgletBuilderMenu();
+                    }
+                });
+        Console.getInstance().getToolBar().addTool("Progress Bar", jProgressBar = new JProgressBar());
+        jProgressBar.setSize(new Dimension(100, 25));
+        Console.getInstance().getToolBar().addTool("Status Bar", jLabel = new JLabel());
+        Console.getInstance().getToolBar().addRightTool("Convertisseur HML",  new Runnable() {
+
+                    @Override
+                    public void run() {
+		      startConvertisseurHML();
+                    }
+                });
+        Console.getInstance().getToolBar().addRightTool(About.getAboutMessage());
+        setUpdate("", 0);
+        new MainFrame().reset("Java's Cool 4 Proglet Buidler", Build.logo, Console.getInstance());
+    }
+
+    /** Met à jour la progression de la construction.
+     * @param statut Statut sur l'opération en cours. Un message de 64 caractères max.
+     * @param percent Pourcentage de complétion entre 0 et 100.
+     */
+    public static void setUpdate(String statut, int percent) {
+        while (statut.length() < 64) {
+            statut += " ";
+        }
+        if (jLabel != null) {
+            jLabel.setText(statut);
+        }
+        if (jProgressBar != null) {
+            jProgressBar.setValue(percent);
+        }
+    }
+    private static JButton jBuilderButton = null;
+    private static JButton jCreatorButton = null;
+    private static JLabel jLabel = null;
+    private static JProgressBar jProgressBar = null;
+    // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
+    private static void startProgletCreatorMenu() {
+        JPopupMenu jCreatorMenu = new JPopupMenu();
+        jCreatorMenu.add(new JLabel("Entrer le nom de la proglet à construire:", JLabel.LEFT));
+        jCreatorMenuDir = new JTextField();
+        jCreatorMenuDir.setText(System.getProperty("user.dir") + File.separator);
+        jCreatorMenuDir.setEditable(false);
+        jCreatorMenu.add(new JPanel() {
+
+            {
+                add(jCreatorMenuDir);
+                add(jCreatorMenuName = new JTextField(20));
+            }
+        });
+        JMenuItem menuitem = new JMenuItem("Créer le répertoire et les fichiers exemples");
+        jCreatorMenu.add(menuitem);
+        menuitem.addActionListener(new ActionListener() {
+
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                new Thread(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        String name = jCreatorMenuName.getText();
+                        if (name != null && name.length() > 0) {
+                            ProgletCreator.mkdirProglet(jCreatorMenuDir.getText() + name);
+                        }
+                    }
+                }).start();
+            }
+        });
+        Component parent = Console.getInstance().getToolBar();
+        jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());
+    }
+    private static JTextField jCreatorMenuDir, jCreatorMenuName;
+    // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
+
+    private static void startProgletBuilderMenu() {
+        boolean reload = false;
+        if ((jBuilderMenu == null) || reload) {
+            jBuilderMenu = new JPopupMenu();
+            if (ProgletsBuilder.getProglets().length > 0) {
+                jBuilderMenu.add(new JLabel("Sélectionner les proglets à construire:"));
+                for (String proglet : ProgletsBuilder.getProglets()) {
+                    JCheckBox check = new JCheckBox(proglet);
+                    check.setSelected(true);
+                    jBuilderMenu.add(check);
+                }
+                jBuilderMenu.addSeparator();
+                JMenuItem menuitem = new JMenuItem("Construire le jar");
+                menuitem.addActionListener(new ActionListener() {
+
+                    @Override
+                    public void actionPerformed(ActionEvent e) {
+                        new Thread(new Runnable() {
+
+                            @Override
+                            public void run() {
+                                ArrayList<String> proglets = new ArrayList<String>();
+                                for (Component c : jBuilderMenu.getComponents()) {
+                                    if (c instanceof JCheckBox && ((JCheckBox) c).isSelected()) {
+                                        proglets.add(((JCheckBox) c).getText());
+                                    }
+                                }
+                                Console.getInstance().clear();
+                                ProgletsBuilder.build(proglets.toArray(new String[proglets.size()]));
+                            }
+                        }).start();
+                    }
+                });
+                jBuilderMenu.add(menuitem);
+            } else {
+                jBuilderMenu.add(new JLabel("Aucune proglet à construire dans ce répertoire"));
+            }
+        }
+        Component parent = Console.getInstance().getToolBar();
+        jBuilderMenu.show(jBuilderButton, 0, parent.getHeight());
+    }
+    // @ inner-class-variable
+    private static JPopupMenu jBuilderMenu = null;
+
+    private static void startConvertisseurHML() {
+        JPopupMenu jCreatorMenu = new JPopupMenu();
+        jCreatorMenu.add(new Htm2Hml());
+        Component parent = Console.getInstance().getToolBar();
+        jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());
+    }
+}
Index: src/org/javascool/builder/LinkCheck.java
===================================================================
--- src/org/javascool/builder/LinkCheck.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/LinkCheck.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,151 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2005.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.builder;
+
+// Used in check the link
+import java.net.URI;
+import java.net.URL;
+
+// Used to cache the links
+import java.util.HashSet;
+import java.util.HashMap;
+
+// Used to patch href
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+import org.javascool.tools.FileManager;
+
+/** Permet de vérifier les liens cassés sur un site.
+ * @see <a href="LinkCheck.java.html">source code</a>
+ * @serial exclude
+ */
+public class LinkCheck {
+  private LinkCheck() {}
+
+  /** Lanceur du test des liens cassés.
+   * @param usage <tt>java org.javascool.tools.LinkCheck [-recursive] location</tt>
+   * <p>Teste les liens d'une adresse web, avec récursion à travers les sous-pages si besoin.</p>
+   */
+  public static void main(String usage[]) {
+    if(usage.length > 0)
+      check(usage[usage.length - 1], "-recursive".equals(usage[0]));
+  }
+  /** Teste les liens d'une adresse web et donne les liens cassés à la console.
+   * @param location L'adresse web à tester.
+   * @param recursive Si true, effectue récursion à travers les sous-pages.
+   *
+   * @throws IllegalArgumentException Si l'URL est mal formée.
+   */
+  public static void check(String location, boolean recursive) {
+    echoBroken("LINKCHECK: " + getRoot(location));
+    links = new HashSet<String>();
+    anchors = new HashMap<String, HashSet<String> >();
+    root = getRoot(location);
+    loop = recursive;
+    npages = nlinks = nbrokens = 0;
+    check(location);
+    echoBroken("  SCANNED PAGES: " + npages + " SCANNED LINKS: " + nlinks + " BROKENS LINKS: " + nbrokens);
+    links = null;
+    anchors = null;
+  }
+  private static HashSet<String> links;
+  private static HashMap<String, HashSet<String> > anchors;
+  private static String root;
+  private static boolean loop;
+  private static int npages, nlinks, nbrokens;
+  private static void check(String location) {
+    try {
+      String text = FileManager.load(location);
+      npages++;
+      for(String href : getLinks(text))
+        if(!href.matches("^(https|javascript|rtsp|mailto):.*$")) {
+          try {
+            href = new URL(new URL(location), href.replaceAll("%2e", ".")).toString();
+            if(!links.contains(href)) {
+              links.add(href);
+              nlinks++;
+              String anchor = null;
+              int i = href.indexOf("#");
+              if(i != -1) {
+                anchor = href.substring(i + 1);
+                href = href.substring(0, i);
+              }
+              if(!FileManager.exists(href))
+                echoBroken("BROKEN  Link in " + location + " -> " + href);
+              else {
+                if(loop && href.startsWith(root) && href.matches("^http:.*([?][^?]*|/|\\.(htm|html|shtml|php))$") && !href.matches("^.*\\.(xslt|java)"))
+                  check(href);
+                if(anchor != null) {
+                  if(!anchors.containsKey(href))
+                    anchors.put(href, getAnchorSet(FileManager.load(href)));
+                  if(!anchors.get(href).contains(anchor))
+                    echoBroken("BROKEN  Anchor in " + location + " -> " + href + " #" + anchor);
+                }
+              }
+            }
+          } catch(Exception e) {
+            echoBroken("SPURIOUS Link in " + location + " -> " + href + " (" + e + ") ");
+          }
+        }
+    } catch(Exception e) {
+      echoBroken("SPURIOUS   " + location + " (" + e + ") ");
+    }
+  }
+  private static String getRoot(String location) {
+    try { return new URI(location).normalize().toString();
+    } catch(Exception e) {
+      return location;
+    }
+  }
+  private static void echoBroken(String message) {
+    System.out.println(message);
+    nbrokens++;
+  }
+  /** Renvoie les ancres d'un texte HTML.
+   * <div> Ici les attributs  <tt>&lt;a href=..</tt> <tt>&lt;img src=..</tt> sont considérés comme des liens.</div>
+   */
+  public static String[] getLinks(String text) {
+    HashSet<String> h = new HashSet<String>();
+    for(int i = 0, l = text.length(); i < l;) {
+      Matcher matcher = linkPattern.matcher(text).region(i, l);
+      if(matcher.find()) {
+        int i1 = matcher.end(), i2 = nextQuote(text, i1);
+	String link = text.substring(i1, i2);
+	if (!link.startsWith("'"))
+	  h.add(link);
+        i = i2;
+      } else
+        break;
+    }
+    return h.toArray(new String[h.size()]);
+  }
+  /** Renvoie les ancres d'un texte HTML.
+   * <div> Ici les attributs <tt>&lt;a name=..</tt> et <tt>&lt; id=..</tt> sont considérés comme des ancres.</div>
+   */
+  public static String[] getAnchors(String text) {
+    HashSet<String> a = getAnchorSet(text);
+    return a.toArray(new String[a.size()]);
+  }
+  private static HashSet<String> getAnchorSet(String text) {
+    HashSet<String> a = new HashSet<String>();
+    for(int i = 0, l = text.length(); i < l;) {
+      Matcher matcher = anchorPattern.matcher(text).region(i, l);
+      if(matcher.find()) {
+        int i1 = matcher.end(), i2 = nextQuote(text, i1);
+        a.add(text.substring(i1, i2));
+        i = i2;
+      } else
+        break;
+    }
+    return a;
+  }
+  private static int nextQuote(String text, int i1) {
+    char c = text.charAt(i1 - 1);
+    int i2 = text.indexOf(c, i1);
+    return i2 == -1 ? text.length() : i2;
+  }
+  private static final Pattern linkPattern = Pattern.compile("(href|HREF|src|SRC)\\s*=\\s*[\"']");
+  private static final Pattern anchorPattern = Pattern.compile("<([aA]\\s+(name|NAME)|[^>]+(id|ID))\\s*=\\s*[\"']");
+}
Index: src/org/javascool/builder/Htm2Hml.java
===================================================================
--- src/org/javascool/builder/Htm2Hml.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/Htm2Hml.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,57 @@
+package org.javascool.builder;
+
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import javax.swing.JToolBar;
+import javax.swing.Box;
+import javax.swing.JLabel;
+import javax.swing.JButton;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+import java.awt.Color;
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Xml2Xml;
+
+/** Calculette de conversion de HTML en HML. */
+public class Htm2Hml extends JPanel {
+  private JTextArea htm, hml;
+  public Htm2Hml() {
+    setLayout(new BorderLayout());
+    JToolBar b = new JToolBar();
+    b.setFloatable(false);
+    b.add(new JLabel("Traduction de [X]HTML en HML (coller le HTML à gauche et copié le HML à droite)"));
+    b.add(Box.createHorizontalGlue());
+    b.add(new JButton("[Traduire]") {
+	{
+	  addActionListener(new ActionListener() {
+	      private static final long serialVersionUID = 1L;
+	      @Override
+		public void actionPerformed(ActionEvent e) {
+		translate();
+	      }});
+	}});
+    add(b, BorderLayout.NORTH);
+    JPanel c = new JPanel();
+    c.add(new JScrollPane(htm = new JTextArea(40, 64)));
+    c.add(new JScrollPane(hml = new JTextArea(40, 64) {
+	private static final long serialVersionUID = 1L;
+	{
+	  setBackground(new Color(200, 200, 200));
+	  setEditable(false);
+	}
+      }));
+    add(c, BorderLayout.CENTER);
+    // Just to test
+    htm.setText("<div>\n<div><img src='ok.png'></div>\n<hr>\n</div>");
+  }
+  private void translate() {
+    hml.setText(Xml2Xml.html2xhtml(htm.getText()));
+    try {
+      hml.setText(Xml2Xml.run(hml.getText(), FileManager.load("org/javascool/builder/htm2hml.xslt")));
+    } catch(Exception e) {
+      System.out.println("Impossible de traduire le HTML en HML: "+e);
+    }
+  }
+}
Index: src/org/javascool/builder/ProgletCreator.java
===================================================================
--- src/org/javascool/builder/ProgletCreator.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/ProgletCreator.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,153 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+*********************************************************************************/
+
+package org.javascool.builder;
+
+import java.io.File;
+import org.javascool.tools.FileManager;
+
+/** Cette factory contient les mécanismes de construction d'une nouvelle proglet.
+ * <h1>Ebauche non finalisée: ce mécanisme est au stade d'ébauche.</h1>
+ * @see <a href="ProgletCreator.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletCreator {
+  // @factory
+  private ProgletCreator() {}
+
+  /** Crée un répertoire et les fichiers de base de la proglet.
+   * @param location Emplacement de la proglet, le nom du répertoire correspond à celui de la proglet.
+   * @return La valeur true si la construction a pu se faire, false sinon.
+   *
+   * @throws IllegalArgumentException Si le nom de la proglet n'est pas un nom Java standard.
+   * @throws RuntimeException Si il y a eu une erreur d'entrée sortie lors de la création.
+   */
+  public static boolean mkdirProglet(String location) {
+    String name = new File(location).getName();
+    if(!name.matches("[a-z][a-zA-Z][a-zA-Z][a-zA-Z]+")) {
+      System.out.println("Le nom de la proglet «" + name + "» est bizarre: \n il ne doit contenir que des lettres, faire au moins quatre caractères, et démarrer par une minuscule.");
+      System.out.println("Impossible de créer une telle proglet");
+      return false;
+    }
+    if(new File(location).isDirectory())
+      System.out.println("Le répertoire «" + location + "» existe déjà, les fichiers existants seront renommés");
+    if((!new File(location).isDirectory()) && !new File(location).mkdirs()) {
+      String tail = new File(location).exists() ? "un fichier existe à cet emplacement" : "il doit être interdit de créer le répertoire ici";
+      System.out.println("Impossible de créer le répertoire «" + location + "» de la proglet, " + tail);
+    }
+    FileManager.save(location + File.separator + "proglet.pml", progletPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "help.xml", helpPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Panel.java", panelPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Functions.java", functionsPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "completion.xml", completionPattern.replaceAll("@name", name), true);
+    FileManager.save(location + File.separator + "Translator.java", translatorPattern.replaceAll("@name", name), true);
+    System.out.println("La proglet «" + name + "» est crée dans " + location);
+    return true;
+  }
+  private static final String progletPattern =
+   "title=\"Exemple de «proglet»\"\n" +
+   "author=\"Prenom Nom<email@serveur.com>\"\n" +
+   "icon=\"sample.png\"\n";
+  private static final String helpPattern =
+    "<div title=\"La «proglet» @name\">\n" +
+    "  <div class=\"objectif\">\n" +
+    "  </div>\n" +
+    "  <div class=\"intros\">\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "  <div class=\"works\">\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "  <div class=\"notes\">\n" +
+    "   <!-- référencées par des tags de la forme <l class=\"note\" link=\"1\"/> -->\n" +
+    "    <div title=\"item 1\">\n" +
+    "    </div>\n" +
+    "  etc..\n" +
+    "  </div>\n" +
+    "</div>\n";
+  private static final String panelPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "import static org.javascool.macros.Macros.*;\n" +
+    "import static org.javascool.proglets.@name.Functions.*;\n" +
+    "import javax.swing.JPanel;\n" +
+    "\n" +
+    "/** Définit le panneau graphique de la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Panel.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Panel extends JPanel /* ou tout autre Component pertinent. */ {\n" +
+    "\n" +
+    "  // @bean\n" +
+    " public Panel() {" +
+    "  // @"+"todo Définir ici la construction de l'objet graphique\n" +
+    "  }\n" +
+    "\n" +
+    "  /** Démo de la proglet. */\n" +
+    "  public void start() {\n" +
+    "  // @"+"todo Définir ici le code de démo de la proglet.\n" +
+    "  }\n" +
+    "\n" +
+    "}\n";
+  private static final String functionsPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "import static org.javascool.macros.Macros.*;\n" +
+    "\n" +
+    "/** Définit les fonctions pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Functions.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Functions {\n" +
+    "  private static final long serialVersionUID = 1L;\n" +
+    "  // @factory\n" +
+    "  private Functions() {}\n" +
+    "  /** Renvoie l'instance de la proglet pour accéder à ses éléments.\n" +
+    "   * <p> Utilisé dans une construction de type <tt>getPane().appelDeMethode(..)</tt>.</p>\n" +
+    "   */\n" +
+    "  private static Panel getPane() {\n" +
+    "     return getProgletPane();\n" +
+    "  }\n" +
+    "\n" +
+    "  //@"+"todo Définir ici les fonctions <tt>public static</tt>\n" +
+    "\n" +
+    "}\n";
+
+  private static final String completionPattern =
+    "<keywords>\n" +
+    "  <keyword \n" +
+    "    name=\"nom de la complétion\" \n" +
+    "    title=\"description en ligne\">\n" +
+    "    <code>texte source de la complétion</code>\n" +
+    "    <doc>Texte qui documente la fonction de l'on complète</doc>\n" +
+    "  </keyword>\n" +
+    "  <!-- autres keyword -->\n" +
+    "</keywords>\n";
+
+
+  private static final String translatorPattern =
+    "package org.javascool.proglets.@name;\n" +
+    "\n" +
+    "/** Définit la traduction d'un code Jvs en code Java  pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
+    " *\n" +
+    " * @see <a href=\"Translator.java.html\">code source</a>\n" +
+    " * @serial exclude\n" +
+    " */\n" +
+    "public class Translator extends org.javascool.core.Translator {\n" +
+    "    @Override\n" +
+    "     public String getImports() {\n" +
+    "    return \"\";\n" +
+    "  }\n" +
+    "    @Override\n" +
+    "  public String translate(String code) {\n" +
+    "    return code;\n" +
+    "  }\n" +
+    "}\n";
+}
Index: src/org/javascool/builder/completionok.xslt
===================================================================
--- src/org/javascool/builder/completionok.xslt	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/completionok.xslt	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sx="http://icl.com/saxon" extension-element-prefixes="sx">
+
+<xsl:output 
+  method="text"
+  encoding="UTF-8"/>
+
+<!-- A la racine: il faut le tag keywords -->
+
+<xsl:template match="/">
+  <xsl:apply-templates select="*[not (name(.) = 'keywords')]" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- keywords : ne doit contenir que (0 à n) keyword -->
+
+<xsl:template match="keywords">
+  <xsl:apply-templates select="@*|*[not (name(.) = 'keyword')]|text()" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- keyword doit contenir les attributs name et title et les elements code et doc (optionel) -->
+
+<xsl:template match="keyword">
+  <xsl:if test="count(@name) = 0"><xsl:call-template name="no-attribute"><xsl:with-param name="name" select="'name'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(@title) = 0"><xsl:call-template name="no-attribute"><xsl:with-param name="name" select="'title'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(code) = 0"><xsl:call-template name="no-element"><xsl:with-param name="name" select="'code'"/></xsl:call-template></xsl:if>
+  <xsl:if test="count(doc) = 0"><xsl:call-template name="no-element"><xsl:with-param name="name" select="'doc'"/></xsl:call-template></xsl:if>
+  <xsl:apply-templates select="@*[not (name(.) = 'name' or name(.) = 'title')]" mode="error"/>
+  <xsl:apply-templates select="*[not (name(.) = 'doc' or name(.) = 'code')]|text()" mode="error"/>
+  <xsl:apply-templates/>
+</xsl:template>
+
+<!-- doc|code ne doivent contenir que du texte -->
+
+<xsl:template match="code|doc">
+  <xsl:apply-templates select="@*|*" mode="error"/>
+</xsl:template>
+
+<!-- Skip des espaces et affichage des erreurs -->
+
+<xsl:template match="text()"/>
+
+<xsl:template name="no-attribute">
+  <xsl:param name="name"/>
+  [Missing attribute: <xsl:value-of select="$name"/>]
+</xsl:template>
+
+<xsl:template name="no-element">
+  <xsl:param name="name"/>
+  [Missing element: <xsl:value-of select="$name"/>]
+</xsl:template>
+
+<xsl:template match="*" mode="error">
+  [Unexpected tag: <xsl:value-of select="name(.)"/>]
+</xsl:template>
+
+<xsl:template match="text()" mode="error">
+  <xsl:if test="not (normalize-space(.) = '')">
+    [Unexpected text: "<xsl:value-of select="."/>"]
+  </xsl:if>
+</xsl:template>
+
+</xsl:stylesheet>
Index: src/org/javascool/builder/package.html
===================================================================
--- src/org/javascool/builder/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/builder/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1 @@
+<body>Ce package contient les mécanismes du moteur du JavaScool Builder.</body>
Index: src/org/javascool/widgets/MainFrame.java
===================================================================
--- src/org/javascool/widgets/MainFrame.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/MainFrame.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,181 @@
+package org.javascool.widgets;
+
+// Used to set Win look and feel
+import javax.swing.UIManager.LookAndFeelInfo;
+import javax.swing.UIManager;
+
+import javax.swing.JFrame;
+import javax.swing.JRootPane;
+import java.applet.Applet;
+import java.awt.Component;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import javax.swing.ImageIcon;
+import org.javascool.macros.Macros;
+
+/** Définit une fenêtre principale pour lancer une application. */
+public class MainFrame extends JFrame {
+  private Component pane;
+  // @bean
+  public MainFrame() {}
+
+  /** Compte des fenêtres ouvertes pour gérer le exit. */
+  private static int frameCount = 0;
+
+  /** Définit le look and feel de l'application. */
+  static void setLookAndFeel() {
+    try {
+      for(LookAndFeelInfo info : UIManager.getInstalledLookAndFeels())
+        if("Nimbus".equals(info.getName())) {
+          UIManager.setLookAndFeel(info.getClassName());
+          break;
+        }
+    } catch(Exception e1) {
+      String os = System.getProperty("os.name");
+      if(os.startsWith("Windows")) {
+        try {
+          UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
+        } catch(Exception e2) {}
+      } else {
+        try {
+          UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        } catch(Exception e2) {
+          System.err.println("Note: Utilisaton du thème Java (et non du système)");
+        }
+      }
+    }
+  }
+  static {
+    setLookAndFeel();
+  }
+
+  /** Construit la fenêtre sans boutons de fermeture.
+   * <p>- Doit être appelé avant la méethode reset.</p>
+   * @return Cet objet, permettant de définir la construction <tt>new MainFrame().asPopup().reset(..)</tt>.
+   */
+  public MainFrame asPopup() {
+    // @todo voir sur mac si ca solde le pb du close intempestif
+    if (System.getProperty("os.name").toLowerCase().indexOf("mac") >= 0) {
+      setUndecorated(true);  
+      getRootPane().setWindowDecorationStyle(JRootPane.NONE);
+    } else if (System.getProperty("os.name").toLowerCase().indexOf("win") >= 0){
+      // Si besoin de faire qq chose sous windows
+    }
+    return this;
+  }
+
+  /** Construit et ouvre une fenêtre principale pour lancer une application.
+   * @param title Le titre de la fenêtre.
+   * @param icon L'icône de la fenêtre.
+   * @param width Largeur de la fenêtre. Si 0 on prend tout l'écran.
+   * @param height Hauteur de la fenêtre. Si 0 on prend tout l'écran.
+   * @param pane Le composant graphique à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new MainFrame().reset(..)</tt>.
+   */
+  public MainFrame reset(String title, String icon, int width, int height, Component pane) {
+    if (title != null)
+      setTitle(title);
+    if(System.getProperty("os.name").toUpperCase().contains("MAC")) {
+      try {
+        System.setProperty("com.apple.mrj.application.apple.menu.about.name", title);
+      } catch(Exception e2) {}
+    }
+    if (icon != null) {
+      ImageIcon image = Macros.getIcon(icon);
+      if(image != null)
+        setIconImage(image.getImage());
+      }
+    add(this.pane = pane);
+    if(pane instanceof Applet)
+      ((Applet) pane).init();
+    setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
+    addWindowListener(new WindowAdapter() {
+                        @Override
+                        public void windowClosing(WindowEvent e) {
+                            close();
+                        }
+                      }
+                      );
+    pack();
+    if((width > 0) && (height > 0))
+      setSize(width, height);
+    else
+      setExtendedState(JFrame.MAXIMIZED_BOTH);
+    setVisible(true);
+    if(pane instanceof Applet)
+      ((Applet) pane).start();
+    if(firstFrame == null)
+      firstFrame = this;
+    frameCount++;
+    return this;
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, int width, int height, Component pane) {
+    return reset(title, null, width, height, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, String icon, Component pane) {
+    return reset(title, icon, 0, 0, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(String title, Component pane) {
+    return reset(title, null, 0, 0, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(int width, int height, Component pane) {
+    return reset(pane.getClass().toString(), null, width, height, pane);
+  }
+  /**
+   * @see #reset(String, String, int, int, Component)
+   */
+  public MainFrame reset(Component pane) {
+    return reset(pane.getClass().toString(), null, 0, 0, pane);
+  }
+  /** Ferme la fenêtre principale à partir du programme.
+   * @param force Si true ferme la fenêter même si isClosable() renvoie false.
+   */
+  public void close(boolean force) {
+                          if(force || isClosable()) {
+                            if(MainFrame.this.pane instanceof Applet) {
+			      try {
+				((Applet) MainFrame.this.pane).stop();
+			      } catch (Throwable e1) { }
+			      try {
+				((Applet) MainFrame.this.pane).destroy();
+			      } catch (Throwable e2) { }
+                            }
+                            setVisible(false);
+                            dispose();
+                            frameCount--;
+                            if(frameCount == 0)
+                              System.exit(0);
+                          }
+  }
+  /**
+   * @see #close(boolean)
+   */
+  public void close() {
+      close(false);
+  }
+  /** Détermine si la fenêtre principale peut-être fermée.
+   * @return La valeur true si la fenêtre principale peut-être fermée, sinon false.
+   */
+  public boolean isClosable() {
+    return true;
+  }
+  /** Renvoie la frame principale ouverte.
+   * @return La frame principale ouverte comme parent des dialogues modaux.
+   */
+  public static JFrame getFrame() {
+    return firstFrame;
+  }
+  private static JFrame firstFrame = null;
+}
Index: src/org/javascool/widgets/Dialog.java
===================================================================
--- src/org/javascool/widgets/Dialog.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/Dialog.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,61 @@
+package org.javascool.widgets;
+
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import javax.swing.JDialog;
+import javax.swing.SwingUtilities;
+import org.javascool.macros.Macros;
+
+/** Définit un dialogue en popup qui gère l'aspect modal/non-modal.
+ * <p>Si le dialog est appelé de l'AWT il est non-modal (donc ne bloque pas l'AWT) sinon il est modal (il blqieu jusqu'à complétion du dialogue).
+ * <p>Son utilisation typique se fait à travers une construction de la forme:<pre>
+ * dialog = new NonModalDialog();
+ * dialog.add(.. le composant du dialogue ..);
+ * dialog.open(true);</pre></p>
+ * <p>Lorsque le composant du dialogue reçoit la réponse il ferme le dialogue, par exemple:<pre>
+ *  public void actionPerformed(ActionEvent e) {
+ *    ... report de la valeur fournie par l'utilisateur ...
+ *    messageDialog.close();
+ * }</pre></p>
+ */
+public class Dialog extends JDialog {
+  // @bean
+  public Dialog() {
+    super(MainFrame.getFrame());
+    addWindowListener(new WindowAdapter() {
+	@Override
+	  public void windowClosing(WindowEvent e) {
+	  pending = false;
+	}
+      }
+		      );
+  }
+  /** Ouvre le dialogue et entre en attente d'un retour de l'utilisateur. 
+   * @param modal Si true le dialogue est bloquant et attend la réponse de l'utilisateur, si false il est non-modal et renvoie la main AVANT que le dialogue soit complété.
+   * <p>Il ne faut pas appelé le dialogue en mode modal directement d'un gestionnaire d'événement (bouton, etc..) mais utiliser un Thread.</p>
+   */
+  public void open(boolean modal) {
+    setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
+    pack();
+    if (MainFrame.getFrame() != null)
+       setLocation((MainFrame.getFrame().getWidth() - getWidth()) / 2, (MainFrame.getFrame().getHeight() - getHeight()) / 2);
+    setVisible(true);
+    if (modal && SwingUtilities.isEventDispatchThread())
+      throw new IllegalStateException("Impossible d'utiliser un dialogue modal directement d'un événement de l'interface: créer un thread");
+    pending = modal;
+    while(pending) 
+      Macros.sleep(100);
+  }
+  /** Routine à appeler quand le dialogue à été achevé pour continuer le programme. */
+  public void close() {
+    dispose();
+    pending = false;
+  }
+  /** Teste si le dialogue est en cours ou achevé. 
+   * return La valeur true si le dialogue est en cours, sinon false.
+   */
+  public boolean isOpen() {
+    return pending;
+  }
+  private boolean pending = false;
+}
Index: src/org/javascool/widgets/StartStopButton.java
===================================================================
--- src/org/javascool/widgets/StartStopButton.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/StartStopButton.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,91 @@
+package org.javascool.widgets;
+
+import javax.swing.JPanel;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import org.javascool.macros.Macros;
+
+/** Définit un bouton de start/stop avec affichage du temps de calcul.
+ *
+ * @author Philippe Vienne
+ * @see <a href="StartStopButton.java.html">code source</a>
+ * @serial exclude
+ */
+public abstract class StartStopButton extends JPanel {
+  private static final long serialVersionUID = 1L;
+  /** Le bouton de start/stop .*/
+  private JButton startButton;
+  /** L'affichage du temps d'exécution. */
+  private JLabel execTime;
+
+  // @bean
+  public StartStopButton() {
+    this.setOpaque(false);
+    add(startButton = new JButton("Arrêter"));
+    startButton.addActionListener(new ActionListener() {
+                                    @Override
+                                    public void actionPerformed(ActionEvent e) {
+                                      new Thread(new Runnable() {
+                                                   public void run() {
+                                                     if(isStarting())
+                                                       doStop();
+                                                     else
+                                                       doStart();
+                                                   }
+                                                 }
+                                                 ).start();
+                                    }
+                                  }
+                                  );
+    add(execTime = new JLabel("  Temps d'exécution : 0 min 0 sec"));
+    doStop();
+  }
+  /** Lancement du programme et du compteur. */
+  private void doStart() {
+    if(isRunning())
+      stop();
+    execTime.setText("  Temps d'exécution : 0 min 0 sec");
+    startButton.setText("Arrêter");
+    startButton.setIcon(Macros.getIcon("org/javascool/widgets/icons/stop.png"));
+    revalidate();
+    new Thread(new Runnable() {
+                 @Override
+                 public void run() {
+                   for(int t = 0; isRunning(); t++) {
+                     execTime.setText("  Temps d'exécution : " + t / 60 + " min " + t % 60 + " sec");
+                     execTime.revalidate();
+                     Macros.sleep(1000);
+                   }
+                   doStop();
+                 }
+               }
+               ).start();
+    start();
+  }
+  /** Indique que l'interface à affiché le lancement. */
+  private boolean isStarting() {
+    return "Arrêter".equals(startButton.getText());
+  }
+  /** Arrêt du programme et du compteur. */
+  private void doStop() {
+    if(isRunning())
+      stop();
+    startButton.setText("Exécuter");
+    startButton.setIcon(Macros.getIcon("org/javascool/widgets/icons/play.png"));
+    revalidate();
+  }
+  /** Cette méthode est appelée au lancement demandé par l'utilisateur. */
+  abstract public void start();
+
+  /** Cette méthode est appelée à l'arrêt demandé par l'utilisateur. */
+  abstract public void stop();
+
+  /** Cette méthode est appellée par le compteur pour déterminer si le programme est terminé.
+   * <p>Par défaut l'indicateur est celui de l'appel à la méthode <tt>stop</tt>.</p>
+   */
+  public boolean isRunning() {
+    return isStarting();
+  }
+}
Index: src/org/javascool/widgets/Console.java
===================================================================
--- src/org/javascool/widgets/Console.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/Console.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,133 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+
+package org.javascool.widgets;
+
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import javax.swing.JLabel;
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+
+// redirectSystemStreams
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.io.IOException;
+import org.javascool.tools.FileManager;
+
+/** Définit une zone d'affichage qui permet de recevoir les messages de la console.
+ *
+ * @author Philippe Vienne
+ * @see <a href="Console.java.html">code source</a>
+ * @serial exclude
+ */
+public class Console extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  /** Zone d'affichage */
+  private JTextArea outputPane;
+  /** Barre de menu */
+  private ToolBar toolbar;
+  /** Zone d'affichage du statut. */
+  private JLabel status;
+
+  // @static-instance
+
+  /** Crée et/ou renvoie l'unique instance de console.
+   * <p>Une application ne peut définir qu'une seule console.</p>
+   */
+  public static Console getInstance() {
+    if(console == null)
+      console = new Console();
+    return console;
+  }
+  /** Renvoie true si la console a déjà été instanciée, false sinon. */
+  public static boolean isInstanced() {
+    return console != null;
+  }
+  private static Console console = null;
+  private Console() {
+    BorderLayout layout = new BorderLayout();
+    this.setLayout(layout);
+    // Construit la zone d'affichage
+    outputPane = new JTextArea();
+    outputPane.setEditable(false);
+    float[] bg = Color.RGBtoHSB(200, 200, 200, null);
+    outputPane.setBackground(Color.getHSBColor(bg[0], bg[1], bg[2]));
+    JScrollPane scrolledOutputPane = new JScrollPane(outputPane);
+    this.add(scrolledOutputPane, BorderLayout.CENTER);
+    // Construit la zone des bouttons
+    toolbar = new ToolBar();
+    toolbar.addTool("Effacer", "org/javascool/widgets/icons/erase.png", new Runnable() {
+                      @Override
+                      public void run() {
+                        clear();
+                      }
+                    }
+                    );
+    toolbar.addSeparator();
+    toolbar.addTool("status", status = new JLabel("                                         "));
+    this.add(toolbar, BorderLayout.NORTH);
+    // Finalise l'objet
+    redirectSystemStreams();
+    this.setVisible(true);
+  }
+  /** Redirige le System.out vers cet affichage */
+  private void redirectSystemStreams() {
+      final OutputStream oldOut = System.out;
+      OutputStream out = new OutputStream() {
+      @Override
+      public void write(int b) throws IOException {
+        print(String.valueOf((char) b));
+        oldOut.write(b);
+      }
+      @Override
+      public void write(byte[] b, int off, int len) throws IOException {
+        print(new String(b, off, len));
+        oldOut.write(b, off, len);
+      }
+      @Override
+      public void write(byte[] b) throws IOException {
+        write(b, 0, b.length);
+        oldOut.write(b);
+      }
+    };
+    System.setOut(new PrintStream(out, true));
+  }
+  /** Efface le contenu de la console. */
+  public void clear() {
+    outputPane.setText("");
+  }
+  /** Affiche une information dans la barre de statut.
+   * @param text Texte à afficher.
+   */
+  public void show(String text) {
+    status.setText(text);
+  }
+  /** Affiche du texte dans la console.
+   * @param text Le texte à afficher.
+   */
+  public void print(String text) {
+    outputPane.append(text);
+  }
+  /** Renvoie le contenu actuel de la console.
+   * @return Ce qui affiché dans la console.
+   */
+  public String getText() {
+    return outputPane.getText();
+  }
+  /** Renvoie la barre de menu de la console pour ajouter des éléments.
+   * @return La barre de menu de la console.
+   */
+  public ToolBar getToolBar() {
+    return toolbar;
+  }
+  /** Sauve ce qui est présentement écrit dans la console dans un fichierL.
+   * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.
+   */
+  public void saveConsoleOutput(String location) {
+    FileManager.save(location, getText());
+  }
+}
Index: src/org/javascool/widgets/ToolBar.java
===================================================================
--- src/org/javascool/widgets/ToolBar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/ToolBar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,119 @@
+package org.javascool.widgets;
+
+import javax.swing.JToolBar;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.util.HashMap;
+import javax.swing.Box;
+import javax.swing.JComponent;
+import javax.swing.AbstractButton;
+import javax.swing.JButton;
+import org.javascool.macros.Macros;
+
+/** Définit une barre d'outils avec intégration de la gestion des actions.
+ *
+ * @author Philippe Vienne
+ * @see <a href="ToolBar.java.html">code source</a>
+ * @serial exclude
+ */
+public class ToolBar extends JToolBar {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public ToolBar() {
+    setFloatable(false);
+  }
+  /** Table des boutons indexés par leurs noms. */
+  private HashMap<String, JComponent> buttons = new HashMap<String, JComponent>();
+  /** Table des actions associées au bouton. */
+  private HashMap<AbstractButton, Runnable> actions = new HashMap<AbstractButton, Runnable>();
+
+  /** Initialize la barre de boutons et efface tous les élements. */
+  @Override
+  public void removeAll() {
+    left = right = 0;
+    setVisible(false);
+    revalidate();
+    super.removeAll();
+    buttons.clear();
+    actions.clear();
+    setVisible(true);
+    revalidate();
+  }
+  /** Ajoute un bouton à la barre d'outils.
+   * @param label Nom du bouton. Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param icon  Icone du bouton. Si null le bouton est montré sans icone.
+   * @param action Action associée au bouton.
+   * @return Le bouton ajouté.
+   */
+  public final JButton addTool(String label, String icon, Runnable action) {
+    return addTool(label, icon, action, left++);
+  }
+  /**
+   * @see #addTool(String, String, Runnable)
+   */
+  public final JButton addTool(String label, Runnable action) {
+    return addTool(label, null, action);
+  }
+  /** Ajoute un bouton à une position précise de la barre d'outil
+   * @see #addTool(String, String, Runnable)
+   */
+  private JButton addTool(String label, String icon, Runnable action, int where) {
+    JButton button = icon == null ? new JButton(label) : new JButton(label, Macros.getIcon(icon));
+    button.addActionListener(new ActionListener() {
+                               @Override
+                               public void actionPerformed(ActionEvent e) {
+                                 actions.get((AbstractButton) e.getSource()).run();
+                               }
+                             }
+                             );
+    add(button, where);
+    if(buttons.containsKey(label)) throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
+    buttons.put(label, button);
+    actions.put(button, action);
+    revalidate();
+    return button;
+  }
+  /** Ajoute un composant à la barre d'outils.
+   * @param label Nom du composant (ce nom restera invisible). Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param component Le composant à ajouter.
+   */
+  public void addTool(String label, JComponent component) {
+    add(component, left++);
+    if(buttons.containsKey(label)) throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
+    buttons.put(label, component);
+    revalidate();
+  }
+  /** Efface un composant de la barre d'outils. */
+  public void removeTool(String label) {
+    if(buttons.containsKey(label)) {
+      JComponent c = buttons.get(label);
+      remove(c);
+      buttons.remove(label);
+      if(c instanceof AbstractButton && actions.containsKey((AbstractButton) c))
+        actions.remove((AbstractButton) c);
+      setVisible(false);
+      revalidate();
+      setVisible(true);
+      revalidate();
+    }
+  }
+  /** Ajoute un composant à la droite de la barre d'outil.
+   * @param label Nom du composant (ce nom restera invisible). Chaque bouton/item/étiquette doit avoir un nom différent.
+   * @param action Action associée au bouton.
+   * @return Le bouton ajouté.
+   */
+  public JButton addRightTool(String label, Runnable action) {
+    if(right == 0)
+      add(Box.createHorizontalGlue());
+    return addTool(label, null, action, left + (++right));
+  }
+  /** Ajoute un composant à la barre d'outils.
+   * @param component Le composant à ajouter.
+   */
+  public void addRightTool(JComponent component) {
+     if(right == 0)
+      add(Box.createHorizontalGlue());
+    add(component, left + (++right));
+  }
+  private int left = 0, right = 0;
+}
Index: src/org/javascool/widgets/PanelApplet.java
===================================================================
--- src/org/javascool/widgets/PanelApplet.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/PanelApplet.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,108 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to encapsulate a proglet
+import javax.swing.JApplet;
+import java.awt.BorderLayout;
+import java.awt.Component;
+import javax.swing.JLabel;
+import org.javascool.tools.Invoke;
+
+/** Définit une applet qui encapsule un objet graphique.
+ * <p>Permet de wrapper un objet graphique dans une page HTML avec une construction de la forme
+ * <div><tt>&lt;applet code="org.javascool.widgets.PanelApplet" archive="les-classes-java.jar" width="560" height="720"></tt></div>
+ * <div><tt>&lt;param name="panel" value="nom-complet-qualifé-de-l-objet-graphique"/></tt></div>
+ * <div><tt>&lt;param name="manual-start" value="true-ou-false"/></tt></div>
+ * <div><tt>&lt;/applet></tt></div>
+ * </p>
+ * <ul>
+ * <li>L'objet doit être un instance de <tt>java.awt.Component</tt> donc n'importe quel composant «swing» ou «awt».</li>
+ * <li>Si l'objet possède des méthodes <tt>init<tt>, , <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> elles sont invoquées par les méthodes correspondandes de l'applet.</li>
+ * <li>Si l'option <tt>manual-start</tt> est activée les méthodes <tt>start</tt>, <tt>stop</tt> ne sont invoquées par l'applet mais par un bouton utilisateuer.</li>
+ * </ul>
+ * @see <a href="PanelApplet.java.html">source code</a>
+ * @serial exclude
+ */
+public class PanelApplet extends JApplet {
+  private static final long serialVersionUID = 1L;
+
+  /** Definition programmatique des paramètres de l'applet.
+   * @param panel Le nom de la classe Java de l'objet graphique à afficher.
+   * @param manualStart Invocations manuelles si true des méthodes <tt>start/stop</tt> (par défaut), sinon elles sont invoquées au lancement.
+   * @return Cet objet, permettant de définir la construction <tt>new PanelApllet().reset(..)</tt>.
+   */
+  public PanelApplet reset(String panel, boolean manualStart) {
+    this.panel = panel;
+    this.manualStart = manualStart;
+    return this;
+  }
+  /**
+   * @see #reset(String, boolean)
+   */
+  public PanelApplet reset(String panel) {
+    return reset(panel, true);
+  }
+  private String panel = null;
+  private boolean manualStart = true;
+  @Override
+  public void init() {
+    if (pane != null)
+      throw new IllegalStateException("Impossible d'instancier deux PanelApplet dans une application");
+    try {
+      if(panel == null) {
+        panel = getParameter("panel");
+        manualStart = getParameter("manualStart") == null || getParameter("manualStart").toLowerCase().equals("true");
+      }
+    } catch(Exception e) {}
+    try {
+      getContentPane().add(pane = (Component) Class.forName(panel).newInstance(), BorderLayout.CENTER);
+    } catch(Exception e) {
+      System.err.println(e);
+      getContentPane().add(new JLabel("Pas d'applet à montrer.", JLabel.CENTER), BorderLayout.CENTER);
+      manualStart = false;
+    }
+    if(manualStart && Invoke.run(pane, "start", false)) {
+      getContentPane().add(new ToolBar().addTool("Démo de la proglet", "org/javascool/widgets/icons/play.png", new Runnable() { public void run() {
+	(new Thread() { public void run() {
+	  Invoke.run(pane, "start");
+	}}).start();
+      }}), BorderLayout.NORTH);
+    }
+    Invoke.run(pane, "init");
+  }
+  @Override
+  public void destroy() {
+    Invoke.run(pane, "init");
+  }
+  @Override
+  public void start() {
+    if(!manualStart)
+      Invoke.run(pane, "start");
+  }
+  @Override
+  public void stop() {
+    if(!manualStart)
+      Invoke.run(pane, "stop");
+  }
+ /** Renvoie le panneau graphique de la proglet courante.
+   * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
+   */
+  public static Component getPane() {
+    return pane;
+  }
+  static {
+    MainFrame.setLookAndFeel();
+  }
+  private static Component pane = null;
+  /** Lanceur dans une fenêtre principale d'une objet graphique.
+   * @param usage <tt>java org.javascool.widgets.PanelApplet nom-complet-qualifé-de-l-objet-graphique</tt>.
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 0)
+      new MainFrame().reset(new PanelApplet().reset(usage[0]));
+  }
+}
Index: src/org/javascool/widgets/CurveOutput.java
===================================================================
--- src/org/javascool/widgets/CurveOutput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/CurveOutput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,299 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Color;
+import java.awt.Graphics;
+
+// Used to define a click
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.event.MouseEvent;
+
+// Used to define an icon/label
+
+// Used to store labels
+import java.util.ArrayList;
+
+/** Panneau pour le tracé de courbes 2D.
+ *
+ * @see <a href="CurveOutput.java.html">source code</a>
+ * @serial exclude
+ */
+public class CurveOutput extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  // @bean
+  public CurveOutput() {}
+  private static class point {
+    double x, y;
+  };
+  private ArrayList<ArrayList<point> > curves = new ArrayList<ArrayList<point> >();
+  private static class line {
+    double x1, y1, x2, y2;
+    Color c;
+  }
+  private ArrayList<line> lines = new ArrayList<line>();
+  private static class oval {
+    double x, y, w, h;
+    Color c;
+  }
+  private ArrayList<oval> ovals = new ArrayList<oval>();
+  private static class label {
+    double x, y;
+    String s;
+    Color c;
+  }
+  private ArrayList<label> labels = new ArrayList<label>();
+  {
+    ReticuleMouseListener l = new ReticuleMouseListener();
+    addMouseMotionListener(l);
+    addMouseListener(l);
+    reset(0, 0, 1, 1);
+  }
+
+  /** Routine interne de tracé, ne pas utiliser.
+   *
+   */
+  @Override
+  public void paint(Graphics g) {
+    width = getWidth();
+    height = getHeight();
+    i0 = width / 2;
+    j0 = height / 2;
+    w0 = i0 - 10;
+    h0 = j0 - 10;
+    super.paint(g);
+    paintBackground(g);
+    g.setPaintMode();
+    for(int c = 0; c < 10; c++) {
+      ArrayList<point> curve = curves.get(c);
+      g.setColor(colors[c]);
+      for(int i = 1; i < curve.size(); i++) {
+        point p0 = curve.get(i - 1), p1 = curve.get(i);
+        g.drawLine(x2i(p0.x), y2j(p0.y), x2i(p1.x), y2j(p1.y));
+      }
+    }
+    for(line l : lines) {
+      g.setColor(l.c);
+      g.drawLine(x2i(l.x1), y2j(l.y1), x2i(l.x2), y2j(l.y2));
+    }
+    for(oval l : ovals) {
+      g.setColor(l.c);
+      g.drawOval(x2i(l.x), y2j(l.y), x2w(l.w), y2h(l.h));
+    }
+    for(label l : labels) {
+      int i = x2i(l.x), j = y2j(l.y);
+      g.setColor(l.c);
+      g.drawString(l.s, i, j);
+      g.drawLine(i - 1, j, i + 1, j);
+      g.drawLine(i, j - 1, i, j + 1);
+    }
+    paintReticule(g);
+  }
+  private void paintReticule(Graphics g) {
+    int i = x2i(reticuleX), j = y2j(reticuleY);
+    g.setColor(Color.white);
+    g.setXORMode(Color.black);
+    g.drawLine(i0 - w0, j, i0 + w0, j);
+    g.drawLine(i, j0 - h0, i, j0 + h0);
+  }
+  private void paintBackground(Graphics g) {
+    g.setPaintMode();
+    g.setColor(Color.CYAN);
+    g.fillRoundRect(1, 1, width - 2, height - 2, 30, 30);
+    g.setColor(Color.BLACK);
+    g.drawRoundRect(1, 1, width - 2, height - 2, 30, 30);
+    g.setColor(Color.DARK_GRAY);
+    g.fillRect(i0 - w0, j0 - h0, 2 * w0, 2 * h0);
+    g.setColor(Color.WHITE);
+    g.drawRect(i0 - w0, j0 - h0, 2 * w0, 2 * h0);
+    g.drawLine(i0, j0 - h0, i0, j0 + h0);
+    g.drawLine(i0 - w0, j0, i0 + w0, j0);
+  }
+  private int x2i(double x) {
+    return (int) Math.rint(i0 + w0 * x);
+  }
+  private int y2j(double y) {
+    return (int) Math.rint(j0 - h0 * y);
+  }
+  private int x2w(double x) {
+    return (int) Math.rint(w0 * x);
+  }
+  private int y2h(double y) {
+    return (int) Math.rint(h0 * y);
+  }
+  private double i2x(int i) {
+    return ((double) (i - i0)) / w0;
+  }
+  private double j2y(int j) {
+    return ((double) (j0 - j)) / h0;
+  }
+  private int width, height, i0, j0, w0, h0;
+
+  private class ReticuleMouseListener implements MouseMotionListener, MouseListener {
+    private static final long serialVersionUID = 1L;
+    @Override
+    public void mouseDragged(MouseEvent e) {
+      paintReticule(getGraphics());
+      reticuleX = i2x(e.getX());
+      reticuleY = j2y(e.getY());
+      paintReticule(getGraphics());
+    }
+    @Override
+    public void mouseReleased(MouseEvent e) {
+      mouseDragged(e);
+      if(runnable != null)
+        runnable.run();
+    }
+    @Override
+    public void mouseMoved(MouseEvent e) {}
+    @Override
+    public void mousePressed(MouseEvent e) {}
+    @Override
+    public void mouseClicked(MouseEvent e) {}
+    @Override
+    public void mouseEntered(MouseEvent e) {}
+    @Override
+    public void mouseExited(MouseEvent e) {}
+  }
+
+  /** Efface et initialize le tracé.
+   * @param Xoffset Abscisse du point central. 0 par défaut.
+   * @param Yoffset Ordonnée du point central. 0 par défaut.
+   * @param Xscale Echelle horizontale, le tracé se fait dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param Yscale Echelle verticale, le tracé se fait dans  [-Yscale+Yoffset..Yscale+Yoffset].
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
+   */
+  public CurveOutput reset(double Xoffset, double Yoffset, double Xscale, double Yscale) {
+    this.Xoffset = Xoffset;
+    this.Yoffset = Yoffset;
+    this.Xscale = Xscale;
+    this.Yscale = Yscale;
+    curves = new ArrayList<ArrayList<point> >();
+    for(int c = 0; c < 10; c++)
+      curves.add(new ArrayList<point>());
+    lines = new ArrayList<line>();
+    ovals = new ArrayList<oval>();
+    labels = new ArrayList<label>();
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /** Efface et initialize le tracé.
+   * @param Xscale Echelle horizontale.
+   * @param Yscale Echelle verticale.
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
+   * @see #reset(double, double, double, double)
+   */
+  public CurveOutput reset(double Xscale, double Yscale) {
+    return reset(0, 0, Xscale, Yscale);
+  }
+  /**
+   * @see #reset(double, double, double, double)
+   */
+  public CurveOutput reset() {
+    return reset(0, 0, 1, 1);
+  }
+  private double Xoffset = 0, Yoffset = 0, Xscale = 1, Yscale = 1;
+
+  /** Ajoute un point à une courbe.
+   * @param x Abscisse du point dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du point dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param c Couleur de la courbe, dans {0, 9}. Le code des couleurs est le suivant:
+   * <div id="colors"><b>Code des couleurs</b><table>
+   * <tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr>
+   * <tr><td>noir</td><td>marron</td><td>rouge</td><td>orange</td><td>jaune</td><td>vert</td><td>bleu</td><td>violet</td><td>gris</td><td>blanc</td></td>
+   * </table></div>
+   */
+  public void add(double x, double y, int c) {
+    point p = new point();
+    p.x = (x - Xoffset) / Xscale;
+    p.y = (y - Yoffset) / Yscale;
+    if((0 <= c) && (c < 10))
+      curves.get(c).add(p);
+    repaint(0, 0, getWidth(), getHeight());
+  }
+  /** Trace une ligne.
+   * @param x1 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y1 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param x2 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y2 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x1, double y1, double x2, double y2, int c) {
+    line l = new line();
+    l.x1 = (x1 - Xoffset) / Xscale;
+    l.y1 = (y1 - Yoffset) / Yscale;
+    l.x2 = (x2 - Xoffset) / Xscale;
+    l.y2 = (y2 - Yoffset) / Yscale;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    lines.add(l);
+  }
+  /** Trace un cercle.
+   * @param x Abscisse du centre, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param r Rayon du cercle.
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x, double y, double r, int c) {
+    oval l = new oval();
+    l.x = (x - Xoffset - r) / Xscale;
+    l.y = (y - Yoffset + r) / Yscale;
+    l.w = 2 * r / Xscale;
+    l.h = 2 * r / Yscale;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    ovals.add(l);
+  }
+  /** Trace une chaîne de caractères.
+   * @param x Abscisse du coin en haut à gauche du texte, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Ordonnée du coin en haut à gauche du texte, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   * @param s Texte à tracer.
+   * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
+   */
+  public void add(double x, double y, String s, int c) {
+    label l = new label();
+    l.x = (x - Xoffset) / Xscale;
+    l.y = (y - Yoffset) / Yscale;
+    l.s = s;
+    l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
+    labels.add(l);
+  }
+  /** Renvoie la position horizontale du réticule. */
+  public double getReticuleX() {
+    return Xoffset + Xscale * reticuleX;
+  }
+  /** Renvoie la position verticale du réticule. */
+  public double getReticuleY() {
+    return Yoffset + Yscale * reticuleY;
+  }
+  /** Définit la position du réticule.
+   * @param x Abscisse du réticule, dans [-Xscale+Xoffset..Xscale+Xoffset].
+   * @param y Reticule ordinate, dans [-Yscale+Yoffset..Yscale+Yoffset].
+   */
+  public void setReticule(double x, double y) {
+    x -= Xoffset;
+    x /= Xscale;
+    y -= Yoffset;
+    y /= Yscale;
+    reticuleX = x < -1 ? -1 : x > 1 ? 1 : x;
+    reticuleY = y < -1 ? -1 : y > 1 ? 1 : y;
+    repaint(0, 0, getWidth(), getHeight());
+  }
+  private double reticuleX = 0, reticuleY = 0;
+
+  private static Color colors[] = { Color.BLACK, new Color(150, 75, 0), Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.MAGENTA, Color.GRAY, Color.WHITE };
+
+  /** Définit une portion de code appellée à chaque modification du réticule.
+   * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
+   * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().setRunnable(..)</tt>.
+   */
+  public CurveOutput setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+  private Runnable runnable = null;
+}
Index: src/org/javascool/widgets/NumberInput.java
===================================================================
--- src/org/javascool/widgets/NumberInput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/NumberInput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,123 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Dimension;
+import javax.swing.BorderFactory;
+
+// Used for the text field
+import javax.swing.JTextField;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+// Used for the slider
+import javax.swing.JSlider;
+import java.awt.Font;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+
+/** Panneau pour l'entrée de valeurs numériques.
+ * @see <a href="NumberInput.java.html">source code</a>
+ * @serial exclude
+ */
+public class NumberInput extends JPanel {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public NumberInput() {
+    setPreferredSize(new Dimension(400, 62));
+    field = new JTextField(12);
+    field.addActionListener(new ActionListener() {
+                              @Override
+                              public void actionPerformed(ActionEvent evt) {
+                                try { set(new Double(field.getText()).doubleValue(), 'T');
+                                } catch(NumberFormatException e) {}
+                              }
+                            }
+                            );
+    add(field);
+    slider = new JSlider();
+    slider.setFont(new Font("Dialog", Font.PLAIN, 0));
+    slider.addMouseListener(new MouseListener() {
+                              @Override
+                              public void mouseClicked(MouseEvent e) {}
+                              @Override
+                              public void mouseEntered(MouseEvent e) {}
+                              @Override
+                              public void mouseExited(MouseEvent e) {}
+                              @Override
+                              public void mousePressed(MouseEvent e) {}
+                              @Override
+                              public void mouseReleased(MouseEvent e) {
+                                set((NumberInput.this.max - NumberInput.this.min) / 100.0 * slider.getValue() + NumberInput.this.min, 'S');
+                              }
+                            }
+                            );
+    add(slider);
+    setText("");
+    setScale(0, 100, 1);
+    setValue(0);
+  }
+  private JTextField field;
+  private JSlider slider;
+  // Display the value
+  private void set(double value, char from) {
+    // Retrain value to be step by step and in the min-max interval
+    value = step <= 0 ? value : min + step *Math.rint((value - min) / step);
+    value = value<min ? min : value> max ? max : value;
+    this.value = value;
+    field.setText(new Double(value).toString().replaceFirst("(99999|00000).*$", "").replaceFirst(".0$", ""));
+    if(from != 'S')
+      slider.setValue((int) ((max > min) ? 100.0 * (value - min) / (max - min) : value));
+    if((from != ' ') && (runnable != null))
+      runnable.run();
+  }
+  /** Définit le nom de la valeur numérique.
+   * @param name Nom du paramètre.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
+   */
+  public final NumberInput setText(String name) {
+    setBorder(BorderFactory.createTitledBorder(name));
+    return this;
+  }
+  /** Définit le nom et les paramètres de la valeur numérique.
+   * @param min Valeur minimale à entrer. 0 par défaut.
+   * @param max Valeur maximale à entrer. 100 par défaut.
+   * @param step Précision de la valeur à entrer. 1 par défaut.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
+   */
+  public final NumberInput setScale(double min, double max, double step) {
+    this.min = min;
+    this.max = max;
+    this.step = step;
+    return this;
+  }
+  /**
+   * @see #setScale(double, double, double)
+   */
+  public final NumberInput setScale() {
+    return setScale(0, 100, 1);
+  }
+  /** Renvoie la valeur numérique. */
+  public double getValue() {
+    return value;
+  }
+  /** Définit la valeur numérique. */
+  public void setValue(double value) {
+    set(value, ' ');
+  }
+  /** Définit une portion de code appellée à chaque modification de la valeur.
+   * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
+   * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setRunnable(..)</tt>.
+   */
+  public NumberInput setRunnable(Runnable runnable) {
+    this.runnable = runnable;
+    return this;
+  }
+  private Runnable runnable = null;
+
+  private double min, max, step, value;
+}
Index: src/org/javascool/widgets/IconOutput.java
===================================================================
--- src/org/javascool/widgets/IconOutput.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/IconOutput.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,251 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.widgets;
+
+// Used to define the gui
+import javax.swing.JPanel;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.util.HashMap;
+
+// Used to manipulate the image
+import java.awt.image.BufferedImage;
+import java.awt.Graphics2D;
+import java.awt.Dimension;
+import javax.imageio.ImageIO;
+import org.javascool.macros.Macros;
+import java.io.IOException;
+
+/** Panneau pour le tracé d'images pixeliques.
+ *
+ * @see <a href="IconOutput.java.html">source code</a>
+ * @serial exclude
+ */
+public class IconOutput extends JPanel {
+  private static final long serialVersionUID = 1L;
+  // @bean
+  public IconOutput() {
+    setBackground(Color.GRAY);
+    setPreferredSize(new Dimension(550, 550));
+    reset(550, 550);
+  }
+  /** Routine interne de tracé, ne pas utiliser.
+   *
+   */
+  @Override
+  public void paint(Graphics g) {
+    super.paint(g);
+    setBounds();
+    g.setPaintMode();
+    for(int j = 0; j < height; j++)
+      for(int i = 0; i < width; i++) {
+	int ij = i + j * width;
+	if (0 <= ij && ij < image.length) {
+	  g.setColor(image[ij]);
+	  g.fillRect(i0 + i * dij, j0 + j * dij, dij, dij);
+	}
+      }
+    Graphics2D g2d = (Graphics2D) g;
+    paint2D(g2d);
+  }
+  /** Cette routine est appellée à chaque tracé et permet de définir un tracé spécifique au dessus de l'image affichée. 
+   * - Pour utiliser cette foncctionnalité, il faut définir: <pre>
+   * class MyIconInput extends IconInput {
+   *   public void paint2D(Graphics2D g) {
+   *     // Ici ajouter les g.drawLine g.fillOval g.drawRect g.fillRect souhaité.
+   *   }
+   * }</pre>
+   * @param g2d L'environnement graphique 2D à utiliser pour peindre.
+   */
+  public void paint2D(Graphics2D g2d) {
+  }
+  private void setBounds() {
+    int di = width > 0 && getWidth() >= width && zoom ? getWidth() / width : 1;
+    int dj = height > 0 && getHeight() >= height && zoom ? getHeight() / height : 1;
+    dij = di < dj ? di : dj;
+    i0 = (getWidth() - width * dij) / 2;
+    j0 = (getHeight() - height * dij) / 2;
+  }
+  /**  Efface et initialize l'image.
+   * @param width Taille horizontale de l'image.
+   * @param height Taille verticale de l'image.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public final IconOutput reset(int width, int height, boolean zoom) {
+    if(width > 550 || height > 550 || width * height > 550 * 550) throw new IllegalArgumentException("Image size too big !");
+    this.zoom = zoom;
+    if (width <= 0)
+      width = 300;
+    if (height <= 0)
+      height = 300;
+    if(width % 2 == 0)
+      width++;
+    if(height % 2 == 0)
+      height++;
+    image = new Color[(this.width = width) * (this.height = height)];
+    for(int ij = 0; ij < this.width * this.height; ij++)
+      image[ij] = Color.WHITE;
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /**
+   * @see #reset(int, int, boolean)
+   */
+  public final IconOutput reset(int width, int height) {
+    return reset(width, height, true);
+  }
+  /** Initialize l'image à partir d'un fichier.
+   * @param location L'URL (Universal Resource Location) de l'image.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public IconOutput reset(String location, boolean zoom) throws IOException {
+    // Fait 2//3 essais sur l'URL si besoin
+    for (int n = 0; n < 3; n++) {
+      BufferedImage img = ImageIO.read(Macros.getResourceURL(location));
+      if(img != null)
+	return reset(img, zoom);
+    }
+    throw new IOException("Unable to load the image " + location);
+  }
+  /**
+   * @see #reset(String, boolean)
+   */
+  public final IconOutput reset(String location)  throws IOException {
+    return reset(location, true);
+  }
+  /** Initialize l'image à partir d'une image en mémoire.
+   * @param img L'image qui va initialiser le tracé.
+   * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
+   * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
+   */
+  public IconOutput reset(BufferedImage img, boolean zoom) {
+    reset(img.getWidth(), img.getHeight(), zoom);
+    for(int j = 0; j <  img.getHeight(); j++)
+      for(int i = 0; i < img.getWidth(); i++)
+	image[i + width * j] = new Color(img.getRGB(i, j));
+    repaint(0, 0, getWidth(), getHeight());
+    return this;
+  }
+  /**
+   * @see #reset(BufferedImage, boolean)
+   */
+  public final IconOutput reset(BufferedImage img) {
+    return reset(img, true);
+  }
+  /** Renvoie les dimensions de l'image. */
+  public Dimension getDimension() {
+    return new Dimension(width, height);
+  }
+  /** Renvoie une image dans laquelle le contenu de l'affichage est copié.
+   * @return Le contenu de l'affichage sous forme d'image.
+   */
+  public BufferedImage getImage() {
+    BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+    for(int j = 0; j < img.getHeight(); j++)
+      for(int i = 0; i < img.getWidth(); i++)
+	img.setRGB(i, j, image[i + width * j].getRGB());
+    return img;
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param  c Couleur: "black" (default), "blue", "cyan", "gray", "green", "magenta", "orange", "pink", "red", "white", "yellow".
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, String c) {
+    return set(x, y, getColor(c));
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param v L'intensité en niveau de gris du pixel de 0 (noir) à 255 (blanc).
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, int v) {
+    v = v < 0 ? 0 : v > 255 ? 255 : v;
+    return set(x, y, new Color(v, v, v));
+  }
+  /** Définit la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @param c L'intensité en couleur du pixel.
+   * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
+   */
+  public boolean set(int x, int y, Color c) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      setBounds();
+      int ij = x + y * width;
+      image[ij] = c;
+      repaint(i0 + x * dij, j0 + y * dij, dij, dij);
+      return true;
+    } else
+      return false;
+  }
+  /** Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return L'intensite du pixel entre 0 et 255 ou 0 si le pixel n'est pas dans l'image.
+   */
+  public int getIntensity(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return (c.getRed() + c.getGreen() + c.getBlue()) / 3;
+    } else
+      return 0;
+  }
+  /**  Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return La couleur du pixel ou "undefined" si le pixel n'est pas dans l'image.
+   */
+  public String getColor(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return colors.containsKey(c) ? colors.get(c) : c.toString();
+    } else
+      return "undefined";
+  }
+  /**  Renvoie la valeur d'un pixel.
+   * @param x Abscisse du pixel, dans {0, width{.
+   * @param y Ordonnée du pixel, dans {0, height{.
+   * @return La couleur du pixel ou black si le pixel n'est pas dans l'image.
+   */
+  public Color getPixelColor(int x, int y) {
+    if((0 <= x) && (x < width) && (0 <= y) && (y < height)) {
+      Color c = image[x + y * width];
+      return c;
+    } else
+      return Color.BLACK;
+  }
+  private Color image[];
+  private int width, height, i0, j0, dij;
+  boolean zoom = true;
+
+  private static HashMap<Color, String> colors = new HashMap<Color, String>();
+  private static Color getColor(String color) {
+    try { return (Color) Class.forName("java.awt.Color").getField(color).get(null);
+    } catch(Exception e) {
+      return Color.BLACK;
+    }
+  }
+  private static void putColors(String color) {
+    colors.put(getColor(color), color);
+  }
+  static {
+    putColors("black");
+    putColors("blue");
+    putColors("cyan");
+    putColors("gray");
+    putColors("green");
+    putColors("magenta");
+    putColors("orange");
+    putColors("pink");
+    putColors("red");
+    putColors("white");
+    putColors("yellow");
+  }
+}
Index: src/org/javascool/widgets/HtmlDisplay.java
===================================================================
--- src/org/javascool/widgets/HtmlDisplay.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/HtmlDisplay.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,263 @@
+/*********************************************************************************
+* Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+* Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2004.  All rights reserved.   *
+*********************************************************************************/
+package org.javascool.widgets;
+
+// Used to build the gui
+import java.net.MalformedURLException;
+import javax.swing.JPanel;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.io.File;
+import java.io.IOException;
+import javax.swing.JButton;
+import javax.swing.JScrollPane;
+import javax.swing.JEditorPane;
+
+// Used to manage links
+import javax.swing.event.HyperlinkEvent;
+import javax.swing.event.HyperlinkListener;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.net.URLDecoder;
+import javax.swing.text.Document;
+import org.javascool.macros.Macros;
+
+// Used to manage keystroke
+import java.util.ArrayList;
+
+/** Definit un visualisateur de pages HTML3.
+ * <p><i>Note:</i> L'implémentation disponible ne rend utilisable que le "vieux" HTML-3.</p>
+ * <p><i>Conseil:</i> Ecrire les pages en <a href="http://javascool.gforge.inria.fr/v4/index.php?page=developers&action=doc-xml">HML</a> (en XHTML simplifié),
+ * la maintenance et polyvalence des pages en sera renforcée.</p>
+ * <div id="URLs"><p><b>Mécanismes d'affichage des contenus:</b><ul>
+ * <li>Les pages locales d'extension <tt>*.htm</tt> sont réputées être du HTML3 et sont affichées ici.</li>
+ * <li>Les autres pages <tt>http://</tt>, <tt>file://</tt>, etc.. sont visualiées dans le navigateur du système, extérieur à javascool.</li>
+ * <li>Il est possible d'ouvrir des pages dans une cible autre que ce visualisateur: <ul>
+ *   <li>Les liens de la forme <tt>http://editor/<i>location</i></tt> ouvrent le document dans l'éditeur de JavaScool. <br>
+ *     Il sont générés par un tag de la form <tt>&lt;l class="editor" ..</tt></li>
+ *   <li>Les liens de la forme <tt>http://newtab/<i>location</i></tt> ouvrent le document dans un autre onglet de JavaScool.<br>
+ *     Il sont générés par un tag de la form <tt>&lt;l class="newtab" ..</tt></li> </li>
+ * </ul> Il sont produits par les tags <tt>&lt;a target="editor" . . </tt> du XML.
+ * En cas d'échec les contenus sont dirigés vers le navigateur du système, extérieur à javascool.</li>
+ * <li>Les liens de la forme <tt>string://?value="text"</tt> permettent d'afficher directement du texte HTML3.</li>
+ * <li>Les autres liens font l'objet d'un appel à la méthode <tt>doBrowse()</tt> ce qui permet de définir des URI dépendant de l'application.</li>
+ * </ul></div>
+ *
+ * @see <a href="HtmlDisplay.java.html">source code</a>
+ * @serial exclude
+ */
+public class HtmlDisplay extends JPanel {
+  private static final long serialVersionUID = 1L;
+
+  /** Le panneau d'affichage du texte. */
+  private JEditorPane pane;
+  /** Les bottons de navigation. */
+  private JButton home, prev, next;
+
+  /** Définit le préfix pour une chaîne. */
+  static private final String stringPrefix = "http://string?";
+  /** Définit le préfix pour une ouverture dans l'éditeur. */
+  static private final String editorPrefix = "http://editor?";
+  /** Définit le préfix pour une ouverture dans un onglet. */
+  static private final String newtabPrefix = "http://newtab?";
+
+  // @bean
+  public HtmlDisplay() {
+    setLayout(new BorderLayout());
+    {
+      ToolBar bar = new ToolBar();
+      home = bar.addTool("Page initiale", "org/javascool/widgets/icons/refresh.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasHome())
+                               update(urls.getHome(), false);
+                           }
+                         }
+                         );
+      prev = bar.addTool("Page précédente", "org/javascool/widgets/icons/prev.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasPrev())
+                               update(urls.getPrev(), false);
+                           }
+                         }
+                         );
+      next = bar.addTool("Page suivante", "org/javascool/widgets/icons/next.png", new Runnable() {
+                           @Override
+                           public void run() {
+                             if(urls.hasNext())
+                               update(urls.getNext(), false);
+                           }
+                         }
+                         );
+      add(bar, BorderLayout.NORTH);
+    }
+    {
+      pane = new JEditorPane();
+      pane.setBackground(Color.WHITE);
+      pane.setEditable(false);
+      pane.setContentType("text/html; charset=utf-8");
+      pane.addHyperlinkListener(new HyperlinkListener() {
+                                  @Override
+                                  public void hyperlinkUpdate(HyperlinkEvent e) {
+                                    if(e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
+                                      update(e.getDescription(), true);
+                                  }
+                                }
+                                );
+      JScrollPane spane = new JScrollPane(pane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
+      add(spane, BorderLayout.CENTER);
+    }
+  }
+  /** Affiche une page de texte HTML3 dans le visualisateur.
+   * @param location L'URL de la page à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setPage(..)</tt>.
+   */
+  public HtmlDisplay setPage(String location) {
+    update(location, true);
+    return this;
+  }
+  public HtmlDisplay setPage(URL location) {
+    update(location, true);
+    return this;
+  }
+  /** Affiche un texte HTML3 dans le visualisateur.
+   * @param text Le texte à afficher.
+   * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setText(..)</tt>.
+   */
+  public HtmlDisplay setText(String text) {
+    try {
+      return setPage(stringPrefix + URLEncoder.encode(text, "utf-8"));
+    } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu: (" + e + ") c'est un bug Java !");
+    }
+  }
+  /** Met à jour les boutons selon l'état de la pile. */
+  private void updateButtons() {
+    home.setEnabled(urls.hasHome());
+    prev.setEnabled(urls.hasPrev());
+    next.setEnabled(urls.hasNext());
+  }
+  /** Définit une pile d'URL avec le mécanisme de home/prev/next. */
+  private class URLStack extends ArrayList<Object>{
+    private static final long serialVersionUID = 1L;
+    /** Index courant dans la pile. */
+    private int current = -1;
+    /** Ajoute un élément dans la pile. */
+    public void push(Object url) {
+      current++;
+      while(current < size())
+        remove(current);
+      add(url);
+    }
+    public Object getCurrent() {
+      return current >= 0 ? get(current) : null;
+    }
+    public boolean hasHome() {
+      return current >= 0;
+    }
+    public Object getHome() {
+      if(hasHome())
+        current = 0;
+      return getCurrent();
+    }
+    public boolean hasPrev() {
+      return current > 0;
+    }
+    public Object getPrev() {
+      if(hasPrev())
+        current--;
+      return getCurrent();
+    }
+    public boolean hasNext() {
+      return current < size() - 1;
+    }
+    public Object getNext() {
+      if(hasNext())
+        current++;
+      return getCurrent();
+    }
+    @Override
+    public String toString() {
+      String s = "";
+      for(int i = size() - 1; i >= 0; i--)
+        s += (i == current ? " * " : "   ") + get(i) + "\n";
+      return s;
+    }
+  }
+  private URLStack urls = new URLStack();
+
+  /** Implémentation du mécanisme de gestion des URL spécifiques.
+   * <p>Cette routine est appelée pour gérer des URL specifiques d'une application donnée.</p>
+   * @param location L'URL à traiter.
+   * @return Cette méthode doit retourner true si l'URL à été traité et false si l'URL n'a pas été reconnu ou traité.
+   */
+  public boolean doBrowse(String location) {
+    return false;
+  }
+  /** Gestion des URLs externes par le navigateur du système. */
+  private void browse(String location) {
+    try {
+      java.awt.Desktop.getDesktop().browse(new java.net.URI(location));
+    } catch(Exception e) {
+      setText("Cette page est à l'adresse internet: <tt>«" + location.replaceFirst("^(mailto):.*", "$1: ...") + "»</tt> (non accessible ici).");
+    }
+  }
+  /** Mécanisme de gestion des URL. */
+  private void update(String location, boolean push) {
+    // Gestion des contenus textuels
+    if(location.startsWith(stringPrefix)) { // Affichage de texte
+      try {
+        if(push)
+          urls.push(location);
+        pane.setText(URLDecoder.decode(location.substring(stringPrefix.length()), "utf-8"));
+      } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu : (" + e + ") c'est un bug Java !");
+      }
+    } else if(location.startsWith(editorPrefix)) {  // Affichage dans editeur JavaScool
+      org.javascool.gui.Desktop.getInstance().openFile(toURL(location.substring(editorPrefix.length())));
+    } else if(location.startsWith(newtabPrefix)) {    // Affichage dans browser JavaScool
+      URL url = toURL(location.substring(newtabPrefix.length()));
+      String name = new File(url.getPath()).getName().replaceFirst("\\.[^\\.]*$", "").replace('_', '.');
+      org.javascool.gui.Desktop.getInstance().openBrowserTab(url.toString(), name.substring(0, 1).toUpperCase()+name.substring(1));
+    } else if(location.matches("^(http|https|rtsp|mailto):.*$")) {    // Gestion des URL externes
+      browse(location);
+    } else if(location.matches(".*\\.htm$") || location.matches("^#.*")) {   // Gestion des URLs en HTML3 et des ancres
+      update(toURL(location), push);
+    } else if(!doBrowse(location))     // Délégation au client
+      setText("Le lien : <tt>«" + location + "»</tt> n'a pas pu être affiché");
+  }
+  private void update(URL url, boolean push) {
+    if(push)
+      urls.push(url);
+    pane.getDocument().putProperty(Document.StreamDescriptionProperty, null);
+    
+    try {
+      pane.setPage(url);
+    } catch(IOException e) {
+      setText("Le lien : <tt>«" + url + "»</tt> génère une erreur \"" + e.toString() + "\"");
+    }
+    updateButtons();
+  }
+  private void update(Object link, boolean push) {
+    if(link instanceof URL)
+      update((URL) link, push);
+    else
+      update(link.toString(), push);
+  }
+  private URL toURL(String location) {
+    try {
+      return urls.isEmpty() ? Macros.getResourceURL(location) :
+	urls.getCurrent() instanceof URL ? new URL((URL) urls.getCurrent(), location) :
+	new URL(location);
+    } catch(MalformedURLException e) {
+      try {
+      return new URL(stringPrefix+"Le lien : <tt>«" + location + "»</tt> est mal formé");
+      } catch(MalformedURLException ex) {
+          throw new IllegalStateException(ex);
+      }
+    }
+  }
+}
+
Index: src/org/javascool/widgets/icons/remove.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/remove.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/save.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/save.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/refresh.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/refresh.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/erase.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/erase.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/open.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/open.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/play.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/play.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo32.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo32.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo16.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo16.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/prev.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/prev.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/next.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/next.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/saveas.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/saveas.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/logo-builder.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/logo-builder.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/stop.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/stop.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/scripts.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/scripts.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/compile.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/compile.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/error.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/error.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/icons/new.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/org/javascool/widgets/icons/new.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: src/org/javascool/widgets/package.html
===================================================================
--- src/org/javascool/widgets/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/widgets/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,2 @@
+<body>Ce package contient les widgets et routines que le formateur peut utiliser pour faire de nouvelles proglets.</body>
+
Index: src/org/javascool/Core.java
===================================================================
--- src/org/javascool/Core.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/Core.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,86 @@
+/*******************************************************************************
+*           Philippe.Vienne, Copyright (C) 2011.  All rights reserved.         *
+*******************************************************************************/
+
+package org.javascool;
+
+import javax.swing.UIManager;
+import org.javascool.macros.Macros;
+import java.io.File;
+import java.net.URLDecoder;
+import java.nio.charset.Charset;
+import java.io.UnsupportedEncodingException;
+import org.javascool.gui.Desktop;
+import org.javascool.tools.ErrorCatcher;
+
+/** Lanceur de l'application "apprenant" qui permet de manipuler des «proglets».  *
+ *
+ * @see <a href="Core.java.html">source code</a>
+ * @serial exclude
+ */
+public class Core {
+  /** Aide de JVS */
+  public static final String help = "org/javascool/macros/memo-macros.htm";
+  /** Mets en place le système d'alerte en cas d'erreur non gérée. */
+  static void setUncaughtExceptionAlert() {
+    ErrorCatcher.setUncaughtExceptionAlert("<h1>Détection d'une anomalie liée à Java:</h1>\n" +
+                                           "Il y a un problème de compatibilité avec votre système, nous allons vous aider:<ul>\n" +
+                                           "  <li>Copier/Coller tous les éléments de cette fenêtre et</li>\n" +
+                                           "  <li>Envoyez les par mail à <b>javascool@googlegroups.com</b> avec toute information utile.</li>" +
+                                           " </ul>",
+                                           About.revision);
+  }
+  /** Retrouve le chemin du jar courant.
+   * @return Le chemin du jar
+   * @throws RuntimeException lorsque l'application n'a pas été démarré depuis un jar
+   */
+  public static String javascoolJar()  {
+    if (javascoolJar != null)
+      return javascoolJar;
+    String url = Macros.getResourceURL("org/javascool/Core.class").toString().replaceFirst("jar:file:([^!]*)!.*", "$1");
+    System.err.println("Notice: javascool url is " + url);   
+    if(url.endsWith(".jar")) {
+      try {
+	String jar = URLDecoder.decode(url, "UTF-8");
+	if (new File(jar).exists())
+	  return javascoolJar = jar;
+	// Ici on essaye tous les encodages possibles pour essayer de détecter javascool
+	{
+	  jar = URLDecoder.decode(url, Charset.defaultCharset().name());
+	  if (new File(jar).exists())
+	    return jar;
+	  for(String enc : Charset.availableCharsets().keySet()) {
+	    jar = URLDecoder.decode(url, enc);
+	    if (new File(jar).exists()) {
+	      System.err.println("Notice: javascool file " + jar + " correct decoding as "+enc);   
+	      return javascoolJar = jar;
+	    } else {
+	      System.err.println("Notice: javascool file " + jar + " wrong decoding as "+enc);   
+	    }
+	  }
+	  throw new RuntimeException("Il y a un bug d'encoding sur cette plate forme");
+	}
+      } catch (UnsupportedEncodingException ex) {
+	throw new RuntimeException("Spurious defaultCharset: this is a caveat");
+      }
+    } else
+      throw new RuntimeException("Java's cool n'a pas été démarré depuis un Jar");
+  }
+  private static String javascoolJar = null;
+  /** Lanceur de l'application.
+   * @param usage <tt>java -jar javascool.jar</tt>
+   */
+  public static void main(String[] usage) {
+    if((usage.length > 0) && (usage[0].equals("-h") || usage[0].equals("-help") || usage[0].equals("--help"))) {
+      System.out.println("Java's Cool Core - lance l'interface pour travailler avec les proglets");
+      System.out.println("Usage : java -jar javascool.jar");
+      System.exit(0);
+    }
+    // Empeche de pouvoir renommer itempestivement des folder
+    UIManager.put("FileChooser.readOnly", Boolean.TRUE);
+    System.err.println("" + About.title + " is starting ...");
+    ErrorCatcher.checkJavaVersion(6);
+    setUncaughtExceptionAlert();
+    Desktop.getInstance().getFrame();
+  }
+}
Index: src/org/javascool/core/Java2Jar.java
===================================================================
--- src/org/javascool/core/Java2Jar.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Java2Jar.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,87 @@
+/**************************************************************
+ * Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+ **************************************************************/
+package org.javascool.core;
+
+import java.io.File;
+import java.io.IOException;
+import org.javascool.Core;
+import org.javascool.builder.JarManager;
+import org.javascool.tools.Pml;
+
+/** Définit le mécanisme de compilation en ligne d'un code Java et de création du Jar obtenu.
+ *
+ * @see <a href="Java2Jar.java.html">code source</a>
+ * @serial exclude
+ */
+public class Java2Jar {
+  // @factory
+  private Java2Jar() {}
+
+  /** Compile dans le système de fichier local, un code source Java.
+   * <p>Les fichiers <tt>.class</tt> sont générés dans sur place.</p>
+   * <p>Les erreurs de compilation sont affichées dans la console.</p>
+   * @param jarFile La jarre de stockage du résultat.
+   * @param mainClass Le nom de la classe qui contient le main.
+   * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
+   * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
+   * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
+   *
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFile, boolean allErrors) {
+    String javaFiles[] = { javaFile };
+    return compile(jarFile, mainClass, javaFiles, allErrors);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFile) {
+    return compile(jarFile, mainClass, javaFile, false);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFiles[]) {
+    return compile(jarFile, mainClass, javaFiles, false);
+  }
+  /**
+   * @see #compile(String, String, String, boolean)
+   */
+  public static boolean compile(String jarFile, String mainClass, String javaFiles[], boolean allErrors)  {
+    try {
+      String buildDir = ".build";
+      JarManager.rmDir(new File(buildDir));
+      new File(buildDir).mkdirs();
+      JarManager.jarExtract(Core.javascoolJar(), buildDir, "org/javascool");
+      for (int i = 0; i < javaFiles.length; i++) {
+        String file = javaFiles[i]; javaFiles[i] =  buildDir+File.separator+file;
+        JarManager.copyFiles(file, javaFiles[i]);
+      }
+      if (!Java2Class.compile(javaFiles, allErrors))
+	return false;
+      String mfFile = buildDir + File.separator + "manifest.jmf";
+      Pml manifest = new Pml().set("Main-Class", mainClass).
+	set("Implementation-URL", "http://javascool.gforge.inria.fr").
+	save(mfFile);
+      JarManager.jarCreate(jarFile, mfFile, buildDir);
+      JarManager.rmDir(new File(buildDir));
+      return true;
+    } catch(IOException e) {
+      throw new RuntimeException("Erreur d'entrées-sorties à la compilation : "+ e);
+    }
+  }
+  
+  /** Lanceur de la conversion Jvs en Java.
+   * @param usage <tt>java org.javascool.core.Java2Jar main-file [input-file(s) ..] [output-file]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 1) {
+      String javaFiles[] = new String[usage.length-1];
+      System.arraycopy(usage, 0, javaFiles, 0, javaFiles.length);
+      compile(usage[usage.length-1], new File(usage[0]).getName().replaceAll("\\.java$", ""), javaFiles, true);
+    }
+  }
+}
+  
Index: src/org/javascool/core/ProgletEngine.java
===================================================================
--- src/org/javascool/core/ProgletEngine.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/ProgletEngine.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,427 @@
+/*********************************************************************************
+ * Philippe.Vienne@sophia.inria.fr, Copyright (C) 2011.  All rights reserved.    *
+ * Guillaume.Matheron@sophia.inria.fr, Copyright (C) 2011.  All rights reserved. *
+ * Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved.   *
+ *********************************************************************************/
+package org.javascool.core;
+
+import java.applet.Applet;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.util.ArrayList;
+import org.javascool.macros.Macros;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.Comparator;
+import javax.swing.JFrame;
+import org.javascool.Core;
+import org.javascool.tools.FileManager;
+import org.javascool.tools.Pml;
+import org.javascool.tools.Invoke;
+import org.javascool.widgets.MainFrame;
+
+/** Définit les mécanismes de compilation, exécution, gestion de proglet.
+ *
+ * @see <a href="ProgletEngine.java.html">code source</a>
+ * @serial exclude
+ */
+public class ProgletEngine {
+
+    /** Tables des proglets. */
+    private ArrayList<Proglet> proglets;
+
+    // @static-instance
+    /** Crée et/ou renvoie l'unique instance de l'engine.
+     * <p>Une application ne peut définir qu'un seul engine.</p>
+     */
+    public static ProgletEngine getInstance() {
+        if (engine == null) {
+            engine = new ProgletEngine();
+        }
+        return engine;
+    }
+    private static ProgletEngine engine = null;
+
+    private ProgletEngine() {
+        String javascoolJar = Core.javascoolJar();
+        // Détection des proglets présentes dans le jar
+        try {
+            proglets = new ArrayList<Proglet>();
+            for (String dir : FileManager.list(javascoolJar, "org.javascool.proglets.[^\\.]+.proglet.pml")) {
+                String name = dir.replaceFirst("jar:[^!]*!(.*)proglet.pml", "$1");
+	      try {
+                Proglet proglet = new Proglet().load(name);
+                proglets.add(proglet);
+	      }  catch(Exception e) {
+		System.err.println("Erreur lors de la détection dans le jar de la proglet "+name+" en "+dir+" ("+e+")");
+	      }
+            }
+        } catch(Exception er) {
+	  System.err.println("Erreur lors de la détection des proglets ("+er+" avec "+javascoolJar+"\n . . vous pouvez quand même utiliser JavaScool");
+        }
+        // Définit une proglet "vide" pour lancer l'interface
+        if (proglets.isEmpty()) {
+            for (int i = 0; i < 1; i++) {
+                Proglet p = new Proglet();
+                p.pml.set("name", "Interface");
+                p.pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
+                p.pml.set("help-location", "org/javascool/macros/memo-macros.htm");
+                proglets.add(p);
+            }
+        }   
+        // Tri des proglets par ordre alphabétique
+            Collections.sort(proglets, new Comparator<Proglet>() {
+                    @Override
+                     public int compare(Proglet p1, Proglet p2) {
+                         return p1.getName().compareTo(p2.getName());
+            }});    
+    }
+    //
+    // [1] Mécanisme de compilation/exécution
+    //
+
+    /** Mécanisme de compilation du fichier Jvs.
+     * @param program Nom du programme à compiler.
+     * @return La valeur true si la compilation est ok, false sinon.
+     */
+    public boolean doCompile(String program) {
+        doStop();
+        // Traduction Jvs -> Java puis Java -> Class et chargement de la classe si succès
+        Jvs2Java jvs2java = new Jvs2Java();
+        if (getProglet() != null) {
+            jvs2java.setProgletTranslator(getProglet().getTranslator());
+            jvs2java.setProgletPackageName(getProglet().hasFunctions() ? "org.javascool.proglets." + getProglet().getName() : null);
+        }
+        String javaCode = jvs2java.translate(program);
+        // Creation d'un répertoire temporaire
+        String javaFile;
+        try {
+            File buildDir = FileManager.createTempDir("javac");
+            javaFile = buildDir + File.separator + jvs2java.getClassName() + ".java";
+            FileManager.save(javaFile, javaCode);
+            // Si il y a un problème avec le répertoire temporaire on se rabat sur le répertoire local
+        } catch(Exception e) {
+            javaFile = new File(jvs2java.getClassName() + ".java").getAbsolutePath();
+            System.err.println("Sauvegarde locale du fichier : "+ javaFile);
+            FileManager.save(javaFile, javaCode);
+        }
+        if (Java2Class.compile(javaFile)) {
+            runnable = Java2Class.load(javaFile);
+            return true;
+        } else {
+            runnable = null;
+            return false;
+        }
+    }
+
+    /** Mécanisme de lancement du programme compilé. */
+    public void doRun() {
+        doStop();
+        // Lancement du runnable dans un thread
+        if (runnable != null) {
+            (thread = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    try {
+                        runnable.run();
+                        thread = null;
+                    } catch (Throwable e) {
+                        System.out.println("Erreur à l'exécution: " + e);
+                    }
+                }
+            })).start();
+        }
+    }
+
+    /** Mécanisme d'arrêt du programme compilé. 
+     * @param message Message d'erreur affiché à la console. Si null (par défaut) pas de message.
+     */
+    public void doStop(String message) {
+        if (thread != null) {
+            thread.interrupt();
+            thread = null;
+        }
+        if (message != null) {
+            System.out.println("Cause de l'interruption : " + message);
+        }
+    }
+
+    /**
+     * @see #doStop(String)
+     */
+    public void doStop() {
+        doStop(null);
+    }
+
+    /** Renvoie true si le programme est en cours. */
+    public boolean isRunning() {
+        return thread != null;
+    }
+    private Thread thread = null;
+    private Runnable runnable = null;
+
+    /** Renvoie le runnable correspondant au programme utilisateur en cours.
+     * @return Le runnable correspondant au programme démarré par doRun() ou null si il n'y en a pas.
+     */
+    public Runnable getProgletRunnable() {
+        return runnable;
+    }
+    //
+    // Mécanisme de chargement d'une proglet
+    //
+
+    /** Mécanisme de chargement d'une proglet.
+     * @param proglet Le nom de la proglet.
+     * @return La proglet en fonctionnement ou null si la proglet n'existe pas.
+     * @throws IllegalArgumentException Si il y a tentative d'utilisation d'une proglet indéfinie
+     */
+    public Proglet setProglet(String proglet) {
+        if (currentProglet != null)
+        currentProglet.stop();
+        currentProglet = null;
+        for (Proglet p : getProglets()) {
+            if (p.getName().equals(proglet)) {
+                currentProglet = p;
+            }
+        }
+        if (currentProglet == null)
+            throw new IllegalArgumentException("Tentative d'utilisation d'une proglet indéfinie : "+proglet);
+        currentProglet.start();
+        return currentProglet;
+    }
+
+    /** Renvoie la proglet demandé.
+     * @return la proglet ou null sinon.
+     */
+    public Proglet getProglet(String proglet) {
+        for (Proglet p : getProglets()) {
+            if (p.getName().equals(proglet)) {
+                return p;
+            }
+        }
+        return null;
+    }
+
+    /** Renvoie la proglet courante.
+     * * @return la proglet courante ou null sinon.
+     */
+    public Proglet getProglet() {
+        return currentProglet;
+    }
+    private Proglet currentProglet = null;
+
+    /** Renvoie toutes les proglets actuellement disponibles.
+     * @return Un objet utilisable à travers la construction <tt>for(Proglet proglet: getProglets()) { .. / .. }</tt>.
+     */
+    public Iterable<Proglet> getProglets() {
+        return proglets;
+    }
+
+    public class Proglet {
+
+        /** Méta-données de la proglet. */
+        public Pml pml = new Pml();
+
+        /** Définit une proglet à partir d'un répertoire donné.
+         * @param location L'URL (Universal Resource Location) où se trouve la proglet.
+         * @throws IllegalArgumentException Si l'URL est mal formée.
+         * @return Cet objet, permettant de définir la construction <tt>new Proglet().load(..)</tt>.
+         */
+        public Proglet load(String location) {
+            // Définit les méta-données de la proglet.
+            pml.load(location + "proglet.pml", true);
+            pml.set("location", location);
+            try {
+                pml.set("name", new File(location).getName());
+            } catch (Exception e) {
+                throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
+            }
+            if (FileManager.exists(Macros.getResourceURL(location + "completion.xml"))) {
+                pml.set("completion", location + "completion.xml");
+            }
+            if (pml.isDefined("icon")
+                    && FileManager.exists(Macros.getResourceURL(location + pml.getString("icon")))) {
+                pml.set("icon-location", location + pml.getString("icon"));
+            } else {
+                pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
+            }
+            try {
+                Class.forName("org.javascool.proglets." + pml.getString("name") + ".Functions");
+                pml.set("has-functions", true);
+            } catch (Throwable e) {
+                pml.set("has-functions", false);
+            }
+            if (!pml.isDefined("help-location")) {
+                pml.set("help-location", pml.getString("location") + "help.htm");
+            }
+            try {
+                pml.set("jvs-translator", (Translator) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Translator").newInstance());
+            } catch (Throwable e) {
+            }
+            return this;
+        }
+
+        @Override
+        public String toString() {
+            return pml.toString();
+        }
+
+        /** Renvoie le nom de la proglet.
+         * @return Le nom de la proglet.
+         */
+        public String getName() {
+            return pml.getString("name");
+        }
+
+        /** Renvoie le titre de la proglet.
+         * @return Le titre de la proglet.
+         */
+        public String getTitle() {
+            return pml.getString("title");
+        }
+
+        /** Renvoie l'icone de la proglet.
+         * @return Le nom de l'URL de l'icone de la proglet, ou l'icone par defaut sinon.
+         */
+        public String getIcon() {
+            return pml.getString("icon-location");
+        }
+
+        /** Renvoie la documentation de la proglet.
+         * @return L'URL de la documentation de la proglet.
+         */
+        public String getHelp() {
+            return pml.getString("help-location");
+        }
+
+        /** Renvoie l'url du fichier de completion de la proglet.
+         * @return L'URL de l'xml de completion de la proglet.
+         */
+        public String getCompletion() {
+            return pml.getString("completion", "");
+        }
+
+        /** Indique si la proglet définit des fonctions statiques pour l'utilisateur.
+         */
+        public boolean hasFunctions() {
+            return pml.getBoolean("has-functions");
+        }
+
+        /** Renvoie, si il existe, le panneau graphique à insérer dans javascool.
+         * @return Le panneau graphique de la proglet si il existe, sinon null.
+         */
+        public Component getPane() {
+           setPane();
+            return (Component) pml.getObject("java-pane");
+        }
+        /** Renvoie, si il existe, le panneau graphique de la proglet.
+         * @return Le panneau graphique de la proglet si il existe, sinon null.
+         */
+        public Component getProgletPane() {
+           setPane();
+           return (Component) pml.getObject("java-proglet-pane");
+        }
+        private void setPane() {
+          if (!pml.isDefined("pane-defined")) {
+              pml.set("pane-defined", true);
+            if (this.isProcessing()) {
+                boolean popup = true;
+                try {
+		  int width = pml.getInteger("width", 500), height = pml.getInteger("height", 500);
+                    Applet applet = (Applet) Class.forName("" + pml.getString("name") + "").newInstance();
+                    applet.init();
+                    applet.setMinimumSize(new Dimension(width, height));
+                    applet.setMaximumSize(new Dimension(width, height));
+                    if (popup) {
+                        popupframe = (new MainFrame() {
+                                @Override
+                            public boolean isClosable() { return false; }
+			  }).asPopup().reset(getName(), getIcon(), width, height, applet);
+                        pml.set("java-pane", null);
+                    }  else {
+                        pml.set("java-pane", applet);
+                    }
+                    pml.set("java-proglet-pane", applet);
+                } catch(java.lang.ClassNotFoundException e0) {
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    System.out.println("Upps erreur de chargement d'une proglet processing : "+e);
+                }
+            } else {
+                try {
+                    Component pane = (Component) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Panel").newInstance();
+                    if (pane instanceof JFrame) {
+                     ((JFrame) pane).setVisible(true);
+                     pml.set("java-pane", null);
+                    } else
+                        pml.set("java-pane", pane);
+                    pml.set("java-proglet-pane", pane);
+                } catch(java.lang.ClassNotFoundException e0) {
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    System.out.println("Upps erreur de chargement d'une proglet : "+e);
+                }
+            }
+            }
+        }
+        private MainFrame popupframe = null;
+        /** Renvoie, si il existe, le translateur de code de la proglet.
+         * @return Le translateur de code de la proglet si il existe, sinon null.
+         */
+        public Translator getTranslator() {
+            return (Translator) pml.getObject("jvs-translator");
+        }
+
+        /** Indique si la proglet a une démo pour l'utilisateur.
+         */
+        public boolean hasDemo() {
+            return getPane() != null && Invoke.run(getPane(), "start", false);
+        }
+
+        /** Lance la démo de la proglet.
+         * @throws RuntimeException si la méthode génère une exception lors de son appel.
+         */
+        public void doDemo() {
+            if (hasDemo()) {
+                (new Thread() {
+
+                    @Override
+                    public void run() {
+                        Invoke.run(getPane(), "start");
+                    }
+                }).start();
+            }
+        }
+
+        /**  Indique si la proglet est une proglet processing.
+         * @return La valeur true si cette applet est développée en processing.
+         */
+        public boolean isProcessing() {
+            return pml.getBoolean("processing");
+        }
+        /** Démarre la proglet. */
+        public void start() {
+        if (popupframe != null)
+            popupframe.setVisible(true);
+       try {
+        if (getPane() != null && getPane() instanceof Applet)
+            ((Applet) getPane()).start();
+        } catch(Throwable e) {
+            System.err.println("Erreur au démarrage de l'applet/proglet");
+        }
+        }
+        /** Arrête la proglet. */
+        public void stop() {
+        try {
+        if (getPane() != null && getPane() instanceof Applet)
+            ((Applet) getPane()).stop();
+        } catch(Throwable e) {
+            System.err.println("Erreur à l'arrêt de l'applet/proglet");
+        }
+        if (popupframe != null)
+            popupframe.setVisible(false);
+        }
+    }
+}
Index: src/org/javascool/core/JvsBeautifier.java
===================================================================
--- src/org/javascool/core/JvsBeautifier.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/JvsBeautifier.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,134 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2009.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.core;
+
+/** Normalise la mise en page d'un source Jvs. */
+public class JvsBeautifier {
+  /** Reformate un morceau de code Jvs.
+   * <p>- C'est un mécanisme restritif un peu fragile destiné au sous-langage Jvs de Java.</p>
+   * @param text Le source à reformate.
+   * @return Le source reformaté.
+   */
+  public static String run(String text) {
+    char f[] = text.trim().replace((char) 160, ' ').toCharArray();
+    String g = "", ln = "\n";
+    int par = 0;
+    for(int i = 0, j; i < f.length;) {
+      // Escapes /* comments
+      if((f[i] == '/') && (i < f.length - 1) && (f[i + 1] == '*')) {
+        g += f[i++];
+        while(i < f.length && !(f[i - 1] == '*' && f[i] == '/'))
+          g += f[i++];
+        if(i < f.length)
+          g += f[i++] + ln;
+        // Escapes // comments
+      } else if((f[i] == '/') && (i < f.length - 1) && (f[i + 1] == '/')) {
+        while(i < f.length && f[i] != '\n')
+          g += f[i++];
+        g += ln;
+        i++;
+        // Escapes " chars
+      } else if(f[i] == '"') {
+        g += f[i++];
+        while(i < f.length && (f[i - 1] == '\\' || f[i] != '"') && f[i] != '\n')
+          g += f[i++];
+        if(i < f.length)
+          g += f[i++];
+        // Escapes @ pragma
+      } else if(f[i] == '@') {
+        while(i < f.length && f[i] != '\n')
+          g += f[i++];
+        g += ln;
+        i++;
+        // Normalizes spaces
+      } else if(Character.isWhitespace(f[i])) {
+        g += ' ';
+        i++;
+        while(i < f.length && Character.isWhitespace(f[i]))
+          i++;
+      } else {
+        char c0 = g.length() == 0 ? ' ' : g.charAt(g.length() - 1);
+        // Counts (parenthesies)
+        if(f[i] == '(')
+          par++;
+        if(f[i] == ')')
+          par--;
+        // Normalize spaces around operators
+        if(isOperator(f[i])) {
+          if(!(Character.isWhitespace(c0) || isOperator(c0)))
+            g += ' ';
+          g += f[i];
+          if((i < f.length - 1) && !(Character.isWhitespace(f[i + 1]) || isOperator(f[i + 1])))
+            g += ' ';
+        } else if(f[i] == '.') {
+          if(g.length() > 0 && Character.isWhitespace(c0))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          while(i < f.length - 1 && Character.isWhitespace(f[i + 1]))
+            i++;
+          // Normalize spaces around punctuation
+        } else if((f[i] == ',') || (f[i] == ';') || (f[i] == ')')) {
+          if(g.length() > 0 && Character.isWhitespace(c0))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          if((par > 0) && (f[i] != ')'))
+            if((i < f.length - 1) && !Character.isWhitespace(f[i + 1]))
+              g += ' ';
+          if((f[i] == ')') && (i < f.length - 1) && (f[i + 1] == '{'))
+            g += ' ';
+        } else if(f[i] == '(') {
+          if(g.length() > 0 && Character.isWhitespace(c0) && (g.length() > 1) && Character.isLetterOrDigit(g.charAt(g.length() - 2)))
+            g = g.substring(0, g.length() - 1);
+          g += f[i];
+          while(i < f.length - 1 && Character.isWhitespace(f[i + 1]))
+            i++;
+        } else if(f[i] == '}') {
+          for(int n = 0; n < 3; n++)
+            if(g.length() > 0 && Character.isWhitespace(g.charAt(g.length() - 1)))
+              g = g.substring(0, g.length() - 1);
+          g += f[i];
+        } else
+          g += f[i];
+        // Reformats {blocks}
+        if((f[i] == '{') || (f[i] == '}') || ((f[i] == ';') && (par == 0))) {
+          if(f[i] == '{')
+            ln += "   ";
+          if(ln.length() >= 3 && f[i] == '}')
+            ln = ln.substring(0, ln.length() - 3);
+          g += ln;
+          if(ln.length() == 1)
+            g += "\n";
+          i++;
+          while(i < f.length && Character.isWhitespace(f[i]))
+            i++;
+        } else
+          i++;
+      }
+    }
+    return "\n" + g.
+           replaceAll("\\}\\s*else\\s*(\\{|if)", "} else $1").
+           replaceAll("(while|if|for|return)\\s*([^a-z_0-9_])", "$1 $2");
+  }
+  private static boolean isOperator(char c) {
+    switch(c) {
+    case '+':
+    case '-':
+    case '*':
+    case '/':
+    case '%':
+    case '&':
+    case '|':
+    case '^':
+    case '=':
+    case '!':
+    case '<':
+    case '>':
+    case ':':
+      return true;
+    default:
+      return false;
+    }
+  }
+}
Index: src/org/javascool/core/Exec.java
===================================================================
--- src/org/javascool/core/Exec.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Exec.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,118 @@
+/*******************************************************************************
+* Thierry.Vieville@sophia.inria.fr, Copyright (C) 2010.  All rights reserved. *
+*******************************************************************************/
+
+package org.javascool.core;
+
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import java.io.File;
+import org.javascool.macros.Macros;
+import java.io.BufferedInputStream;
+import java.io.FileOutputStream;
+import java.net.URL;
+
+/** Exécute une commande du système d'exploitation.
+ * @see <a href="Exec.java.html">code source</a>
+ * @serial exclude
+ */
+public class Exec {
+  // @factory
+  private Exec() {}
+
+  /** Execute la commande et renvoie le résultat.
+   * @param command La commande avec ses arguments séparés par des tabulations (caractère "\t") ou, sans cela, des espaces (caractère " ").
+   * @param timeout Temporisation maximale avant la fin de la commande.  Valeur par défaut 10.
+   * <p>Si 0, l'attente est indéfinie.</p>
+   * <p>Si -1, la commande est lancée en arrière plan et la fonction revient tout de suite, sans résultat.</p>
+   * @return Le résultat: ce que la commande écrit en sortie.
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'exécution.
+   * @throws IllegalStateException Si le statut de retour de la commande n'est pas 0 (donc a un numéro d'erreur) ou si la temporisation est dépassée.
+   */
+  public static String run(String command, int timeout) {
+    try { 
+      Process process = exec(command);
+      if (timeout == -1)
+        return "";
+      StringBuffer output = new StringBuffer();
+      long time = timeout > 0 ? System.currentTimeMillis() + 1000 * timeout : 0;
+      InputStreamReader stdout = new InputStreamReader(process.getInputStream());
+      InputStreamReader stderr = new InputStreamReader(process.getErrorStream());
+      for(boolean waitfor = true; waitfor;) {
+        waitfor = false;
+        Thread.yield();
+        while(stdout.ready()) {
+          waitfor = true;
+          output.append((char) stdout.read());
+        }
+        while(stderr.ready()) {
+          waitfor = true;
+          output.append((char) stderr.read());
+        }
+        if(!waitfor) {
+          try {
+            process.exitValue();
+          } catch(IllegalThreadStateException e1) {
+            try {
+              Thread.sleep(100);
+            } catch(Exception e2) {}
+            waitfor = true;
+          }
+        }
+        if((time > 0) && (System.currentTimeMillis() > time)) throw new IllegalStateException("Command {" + command + "} timeout (>" + timeout + "s) output=[" + output + "]\n");
+      }
+      stdout.close();
+      stderr.close();
+      // Terminates the process
+      process.destroy();
+      try {
+        process.waitFor();
+      } catch(Exception e) {}
+      Thread.yield();
+      if(process.exitValue() != 0) throw new IllegalStateException("Command {" + command + "} error #" + process.exitValue() + " output=[\n" + output + "\n]\n");
+      return output.toString();
+    } catch(IOException e) { throw new RuntimeException(e + " when executing: " + command);
+    }
+  }
+  /**
+   * @see #run(String, int)
+   */
+  public static String run(String command) {
+    return run(command, 10);
+  }
+  // Lance une commande en arrière plan
+  private static Process exec(String command) throws IOException  {
+    return Runtime.getRuntime().exec(command.trim().split((command.indexOf('\t') == -1) ? " " : "\t"));
+  }
+  /** Démarre un nouveau programme java en place de celui là.
+   * @param jar La jarre contenant le programme Java à lancé à la place de celui là.
+   * @return La valeur true si le programme a pu se lancer, sinon la valeur false.
+   */
+  public static boolean start(String jar) {
+     try {
+       String command = System.getProperty("java.home")+File.separator+"bin"+File.separator+"java\t-jar\t"+getLocal(jar);
+       exec(command);   
+       return true;
+     } catch(IOException e) {
+       System.err.println("Impossible de lancer le jar '"+jar+"' :"+e);
+       return false;
+     }
+  }
+  // Fait une copie locale d'une jarre globale
+  private static String getLocal(String location) throws IOException  {
+     URL url = Macros.getResourceURL(location, true);
+     File file = File.createTempFile(new File(url.getFile()).getName().replaceFirst("\\.jar$", "")+"-", ".jar"); 
+     {
+       BufferedInputStream i = new BufferedInputStream(url.openStream(), 2048);
+       FileOutputStream o = new FileOutputStream(file);
+       byte data[] = new byte[2048];
+       for(int c; (c = i.read(data, 0, 2048)) != -1;)
+         o.write(data, 0, c);
+       i.close();
+       o.close();
+     }
+     return file.getCanonicalPath();
+  }
+}
Index: src/org/javascool/core/Jvs2Java.java
===================================================================
--- src/org/javascool/core/Jvs2Java.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Jvs2Java.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,131 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+package org.javascool.core;
+
+// Used to report a throwable
+import java.lang.reflect.InvocationTargetException;
+
+/** Implémente le mécanisme de base de traduction d'un code Jvs en code Java standard.
+ * <p>Les erreurs de traduction sont affichées dans la console.</p>
+ *
+ * @see <a href="Jvs2Java.java.html">source code</a>
+ * @serial exclude
+ */
+public class Jvs2Java extends Translator {
+  // @bean
+  public Jvs2Java() {}
+
+  /** Définit un mécanisme spécifique de traduction en plus du mécanisme standard.
+   * @param progletTranslator Le mécanisme de traduction spécifique d'une proglet donnée.
+   * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletTranslator(..)</tt>.
+   */
+  public Jvs2Java setProgletTranslator(Translator progletTranslator) {
+    // @bean-parameter(Translator, progletTranslator, w);
+    this.progletTranslator = progletTranslator;
+    return this;
+  }
+  private Translator progletTranslator = null;
+
+  /** Définit le nom complet du package de la proglet pour ce mécanismes de traduction.
+   * @param progletPackageName Le nom complet du package de la proglet.
+   * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletPackageName(..)</tt>.
+   */
+  public Jvs2Java setProgletPackageName(String progletPackageName) {
+    // @bean-parameter(String, progletPackageName, w);
+    this.progletPackageName = progletPackageName;
+    return this;
+  }
+  private String progletPackageName = null;
+
+  @Override
+  public String translate(String jvsCode) {
+    String text = jvsCode.replace((char) 160, ' ');
+    // Ici on ajoute
+    if(!text.replaceAll("[ \n\r\t]+", " ").matches(".*void[ ]+main[ ]*\\([ ]*\\).*")) {
+      if(text.replaceAll("[ \n\r\t]+", " ").matches(".*main[ ]*\\([ ]*\\).*")) {
+        System.out.println("Attention: il faut mettre \"void\" devant \"main()\" pour que le programme puisque se compiler");
+        text = text.replaceFirst("main[ ]*\\([ ]*\\)", "void main()");
+      } else {
+        System.out.println("Attention: il faut un block \"void main()\" pour que le programme puisque se compiler");
+        text = "\nvoid main() {\n" + text + "\n}\n";
+      }
+    }
+    String[] lines = text.split("\n");
+    StringBuilder head = new StringBuilder();
+    StringBuilder body = new StringBuilder();
+    // Here is the translation loop
+    {
+      int i = 1;
+      // Copies the user's code
+      for(String line : lines) {
+        if(line.matches("^\\s*(import|package)[^;]*;\\s*$")) {
+          head.append(line);
+          body.append("//").append(line).append("\n");
+          if(line.matches("^\\s*package[^;]*;\\s*$"))
+            System.out.println("Attention: on ne peut normalement pas définir de package Java en JavaScool\n le programme risque de ne pas s'exécuter correctement");
+        } else
+          body.append(line).append("\n");
+        i++;
+      }
+      // Imports proglet's static methods
+      head.append("import static java.lang.Math.*;");
+      head.append("import static org.javascool.macros.Macros.*;");
+      head.append("import static org.javascool.macros.Stdin.*;");
+      head.append("import static org.javascool.macros.Stdout.*;");
+      if(progletPackageName != null)
+        head.append("import static ").append(progletPackageName).append(".Functions.*;");
+      if(progletTranslator != null)
+        head.append(progletTranslator.getImports());
+      // Declares the proglet's core as a Runnable in the Applet
+      uid++;
+      head.append("public class JvsToJavaTranslated").append(uid).append(" implements Runnable{");
+      head.append("  private static final long serialVersionUID = ").append(uid).append("L;");
+      head.append("  public void run() {");
+      head.append("   try{ main(); } catch(Throwable e) { ");
+      head.append("    if (e.toString().matches(\".*Interrupted.*\"))System.out.println(\"\\n-------------------\\nProggramme arrêté !\\n-------------------\\n\");");
+      head.append("    else System.out.println(\"\\n-------------------\\nErreur lors de l'exécution de la proglet\\n\"+org.javascool.core.Jvs2Java.report(e)+\"\\n-------------------\\n\");}");
+      head.append("}");
+    }
+    String finalBody = body.toString().
+                       replaceAll("(while.*\\{)", "$1 sleep(1);");
+    if(progletTranslator != null)
+        finalBody = progletTranslator.translate(finalBody);
+    System.err.println(
+                "\n-------------------\nCode java généré\n-------------------\n" +
+                head.toString().replaceAll("([{;])", "$1\n") + "\n" + finalBody + "}" +
+                "\n----------------------------------------------------------\n");
+    return head.toString() + finalBody + "}";
+  }
+  /** Renvoie le nom de la dernière classe Java générée lors de la traduction. */
+  public String getClassName() {
+    return "JvsToJavaTranslated" + uid;
+  }
+  // Counter used to increment the serialVersionUID in order to reload the different versions of the class
+  private static int uid = 0;
+
+  /** Rapporte une erreur survenue lors de l'exécution d'un prograamme Jvs.
+   * @param error L'erreur ou exception à rapporter.
+   * @return Le rapport d'erreur.
+   */
+  public static String report(Throwable error) {
+    if(error instanceof InvocationTargetException)
+      return report(error.getCause());
+    String s = error.toString()+"\n";
+    for(int i = 0; i < 4 && i < error.getStackTrace().length; i++) {
+      String s_i = "" + error.getStackTrace()[i];
+      if (s_i.startsWith("JvsToJavaTranslated"))
+	s += s_i.replaceFirst("JvsToJavaTranslated[0-9]*", "") + "\n";
+    }
+    return s;
+  }
+
+  /** Lanceur de la conversion Jvs en Java.
+   * @param usage <tt>java org.javascool.core.Jvs2Java input-file [output-file]</tt>
+   */
+  public static void main(String[] usage) {
+    // @main
+    if(usage.length > 0)
+      org.javascool.tools.FileManager.save(usage.length > 1 ? usage[1] : "stdout:", new Jvs2Java().translate(org.javascool.tools.FileManager.load(usage[0])));
+  }
+}
Index: src/org/javascool/core/Java2Class.java
===================================================================
--- src/org/javascool/core/Java2Class.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Java2Class.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,202 @@
+/**************************************************************
+* Philippe VIENNE, Copyright (C) 2011.  All rights reserved. *
+**************************************************************/
+package org.javascool.core;
+
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Pattern;
+import javax.tools.Diagnostic;
+import javax.tools.DiagnosticCollector;
+import javax.tools.JavaCompiler;
+import javax.tools.JavaFileObject;
+import javax.tools.StandardJavaFileManager;
+import javax.tools.ToolProvider;
+
+/** Définit le mécanisme de compilation en ligne d'un code Java et du chargement de la classe obtenue.
+ * <p>Note: utilise un sous ensemble du <tt>tools.jar</tt> de la JDK appelé ici <tt>javac.jar</tt> qui doit être dans le CLASSPATH.</p>
+ *
+ * @see <a href="Java2Class.java.html">code source</a>
+ * @serial exclude
+ */
+public class Java2Class {
+  // @factory
+  private Java2Class() {}
+
+  /** Compile dans le système de fichier local, un code source Java.
+   * <p>Les fichiers <tt>.class</tt> sont générés sur place.</p>
+   * <p>Les erreurs de compilation sont affichées dans la console.</p>
+   * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
+   * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
+   * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
+   *
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
+   */
+  public static boolean compile(String javaFile, boolean allErrors) {
+    String javaFiles[] = { javaFile };
+    return compile(javaFiles, allErrors);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFile) {
+    return compile(javaFile, false);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFiles[]) {
+    return compile(javaFiles, false);
+  }
+  /**
+   * @see #compile(String, boolean)
+   */
+  public static boolean compile(String javaFiles[], boolean allErrors) {
+    if(javaFiles.length == 0)
+      return false;
+    return compile2(javaFiles, allErrors);
+  }
+
+  // Implementation using the javac compiler api : il n'est plus utilisé (donc plus maintenu !) avec l'arrivée dela jre 76
+  private static boolean compile1(String javaFiles[], boolean allErrors) {
+    // Initialisation des objets dy compilateur// The compiler tool
+    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); // The compiler tool
+    if (compiler == null) {
+      System.err.println("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)");
+      throw new IllegalStateException("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)");
+    }
+    DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>(); // The diagnostic colector
+    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.FRENCH, null); // The file manager
+    // Mise en place des fichiers
+    List<File> sourceFileList = new ArrayList<File>();
+    for(String javaFile : javaFiles)
+      sourceFileList.add(new File(javaFile));
+    Iterable< ? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(sourceFileList);
+    // Lancement de la compilation
+    JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits);
+    task.call();
+    try {
+      fileManager.close();
+    } catch(IOException e) {
+      System.err.println("Erreur à la fermeture du file-manager du compilateur : " + e);
+    }
+    // Gestion des erreurs
+    for(Diagnostic diagnostic : diagnostics.getDiagnostics()) {
+      String javaDiagnostic = diagnostic.getMessage(Locale.FRENCH);
+      String jvsDiagnostic = javaFiles.length > 1 ? javaDiagnostic : javaDiagnostic.split(" ", 2)[1];
+      if(jvsDiagnostic.equals("not a statement"))
+	jvsDiagnostic = "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)";
+      else if(jvsDiagnostic.equals("';' expected"))
+	jvsDiagnostic = "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)";
+      else if(jvsDiagnostic.startsWith("cannot find symbol"))
+	jvsDiagnostic = "Il y a un symbole non-défini à cette ligne: " +
+	  jvsDiagnostic.replaceFirst("cannot[^:]*:\\s*([^\\n]*)[^:]*:\\s*(.*)", "«$1»");
+      else if(jvsDiagnostic.matches(".*\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)"))
+	jvsDiagnostic = jvsDiagnostic.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
+						 "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
+      else if(jvsDiagnostic.matches("package org\\.javascool\\.proglets\\.[A-Za-z0-9_]+ does not exist"))
+	jvsDiagnostic = jvsDiagnostic.replaceAll("package org\\.javascool\\.proglets\\.([A-Za-z0-9_]+) does not exist",
+						 "La proglet $1 n'existe pas");
+      else
+	jvsDiagnostic = "Erreur Java : «" + jvsDiagnostic + "»";
+      int line = (int) diagnostic.getLineNumber();
+      String source = new File(diagnostic.getSource().toString()).getParentFile().getName() + "/" + new File(diagnostic.getSource().toString()).getName();
+      String where = javaFiles.length == 1 ? "" : " de " + source + "";
+      System.out.println("-------------------\nErreur lors de la compilation à la ligne " + line + where + ".\n" + jvsDiagnostic + "\n-------------------");
+      System.err.println("Erreur à la compilation: fichier="+source+" ligne ="+line +" erreur="+javaDiagnostic);
+      // En fait ici on choisit d'arrêter à la 1ère erreur pour pas embrouiller l'apprennant
+      if(diagnostic.getKind().equals(Diagnostic.Kind.ERROR) && !allErrors)
+	return false;
+    }
+    return true;
+  }
+  
+  private static boolean compile2(String javaFiles[], boolean allErrors) {
+    // Appel du compilateur par sa méthode main
+    int options = 2;
+    String args[] = new String[options + javaFiles.length];
+    args[0] = "-g";
+    args[1] = "-nowarn";
+    System.arraycopy(javaFiles, 0, args, options, javaFiles.length);
+    StringWriter out = new StringWriter();
+    Method javac;
+    try {
+      javac = Class.forName("com.sun.tools.javac.Main").
+	getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter"));
+    } catch(Exception e) {
+      throw new IllegalStateException("Impossible d'accéder au compilateur javac : "+ e);
+    }   
+    try {
+      javac.invoke(null, (Object) args, new PrintWriter(out));
+    } catch(Exception e) {
+      throw new IllegalStateException("Erreur système lors du lancement du compilateur javac : "+ e);
+    }   
+    // Traitement du message de sortie
+    {
+      String sout = out.toString().trim();
+      // Coupure à la première erreur
+      if (sout.indexOf("^") != -1 && !allErrors) sout = sout.substring(0, sout.indexOf("^") + 1);
+      if (javaFiles.length > 1) {
+	// Remplacement des chemins des sources par leur simple nom
+	for(String javaFile : javaFiles)
+	  sout = sout.replaceAll(Pattern.quote(new File(javaFile).getParent()+File.separator), "\n");
+	// Explicitation du numéro de ligne
+	for(String javaFile : javaFiles)
+	  sout = sout.replaceAll("("+Pattern.quote(new File(javaFile).getName())+"):([0-9]+):", "$1 : erreur de syntaxe ligne $2 :\n ");
+      } else {
+	sout = sout.replaceAll("("+Pattern.quote(new File(javaFiles[0]).getPath())+"):([0-9]+):", "\n Erreur de syntaxe ligne $2 :\n ");
+        sout = sout.replaceAll(Pattern.quote(new File(javaFiles[0]).getName().replaceFirst("java$", "")), "");
+      }
+      // Passage en français des principaux diagnostics
+      sout = sout.replaceAll("not a statement", 
+			     "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)");
+      sout = sout.replaceAll("';' expected", 
+			     "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)");
+      sout = sout.replaceAll("cannot find symbol\\s*symbol\\s*:\\s*([^\\n]*)[^:]*:\\s*(.*)", 
+			     "Il y a un symbole non-défini à cette ligne : «$1» (utilisez-vous la bonne proglet ?)");
+      sout = sout.replaceAll("illegal start of expression", 
+			     "($0) L'instruction (ou la précédente) est tronquée ou mal écrite");
+      sout = sout.replaceAll("class, interface, or enum expected", 
+			     "($0) Il y a probablement une erreur dans les accolades (peut-être trop de '}')");
+      sout = sout.replaceAll("'.class' expected", 
+			     "($0) Il manque des accolades ou des parenthèses pour définir l'instruction");
+      sout = sout.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
+			     "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
+      // Elimination des notes de warning de fin de compilation
+      if (sout.indexOf("Note:") != -1) 
+	sout = sout.substring(0, sout.indexOf("Note:")).trim();
+      // Impression du message d'erreur si il existe et retour du statut
+      if (sout.length() > 0) System.out.println(sout);
+	   return sout.length() == 0;
+    }
+  }
+
+  /** Charge dynamiquement une classe Java qui implémente un Runnable, pour son e×écution au cours d'une session.
+   * @param path Le chemin vers la classe Java à charger. La classe ne doit pas appartenir à un package, c'est-à-dire au package "default".
+   * @return Une instanciation de cette classe Java.
+   *
+   * @throws IllegalArgumentException Si la classe n'est pas un Runnable.
+   * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors du chargement.
+   */
+  public static Runnable load(String path) {
+    try {
+      File javaClass = new File(path).getAbsoluteFile();
+      URL[] urls = new URL[] { new URL("file:" + javaClass.getParent() + File.separator) };
+      Class< ? > j_class = new URLClassLoader(urls).loadClass(javaClass.getName().replaceAll("\\.java", ""));
+      Object o = j_class.newInstance();
+      if(!(o instanceof Runnable))
+         throw new IllegalArgumentException("Erreur: la classe de "+javaClass+" qui n'est pas un Runnable");
+      return (Runnable) o;
+    } catch(Throwable e) { throw new RuntimeException("Erreur: impossible de charger la classe de : "+path);
+    }
+  }
+}
+
Index: src/org/javascool/core/Translator.java
===================================================================
--- src/org/javascool/core/Translator.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/Translator.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,28 @@
+package org.javascool.core;
+
+/** Définit une traduction d'un code Jvs en code Java standard.
+ * <p>Cette classe permet de définir des variantes de langage pour une proglet donnée.</p>
+ *
+ * @see <a href="Translator.java.html">code source</a>
+ * @serial exclude
+ */
+public class Translator {
+  /** Renvoie les déclarations d'import spécifiques à cette proglet.
+   * <p>Ce sont les déclarations d'import spécifiques dont l'utilisateur a besoin pour que son code Jvs puisse se compiler.</p>
+   * <p>- Par exemple: <tt>"import javax.swing.JPanel;import static org.javascool.proglets.maProglet.*;"</tt></p>
+   * <p>Note: tous les imports liés aux fonctions de la proglet à l'usage des macros de JavaScool etc.. sont automatiquement prises en charge.</p>
+   * @return Renvoie les imports en syntaxe Java (par défaut la chaîne vide).
+   */
+  public String getImports() {
+    return "";
+  }
+  /** Transforme globalement le code pour passer des constructions spécifiques à Jvs à du java standard.
+   * <p>Ce sont souvent des expression régulières appliquées à la chaîne, tout est ici de la responsabilité du concepteur de la proglet.</p>
+   * <p>Note: toutes les traductions standard du paassage de Jvs à Java sont automatiquement prises en charges.</p>
+   * @param code Le code Jvs en entrée.
+   * @return Le code transformé en Java pour ce qui est spécifique de cette proglet (par défaut la chaîne en entrée).</p>
+   */
+  public String translate(String code) {
+    return code;
+  }
+}
Index: src/org/javascool/core/package.html
===================================================================
--- src/org/javascool/core/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/core/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,5 @@
+<body>Ce package contient les mécanismes du moteur de JavaScool.
+<p>Le moteur de JavaScool fonctionne ainsi:
+<p><img src="http://javascool.gforge.inria.fr/v4/documents/javadoc/javascool-workflow.png" alt="Cycle de vie d'un code Jvs and Javascool" width="100%"/></p>
+</p>
+</body>
Index: src/org/javascool/About.java
===================================================================
--- src/org/javascool/About.java	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/About.java	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,43 @@
+package org.javascool;
+
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import javax.swing.JLabel;
+import org.javascool.macros.Macros;
+
+/** Définit le panneau de "about" de javascool et son bouton d'ouverture.
+ */
+public class About {
+
+  /** Titre de l'application. */
+  public static final String title = "Java's Cool 4";
+  /** Logode l'application. */
+  public static final String logo = "org/javascool/widgets/icons/logo.png";
+
+  /** Numéro de révision de l'application.*/
+  public static final String revision = "4.0.973"; // @revision automatiquement mis à jour par ant -f work/build.xml classes
+
+
+  /** Affiche le message de "about". */
+  public static void showAboutMessage() {
+    Macros.message(title + " ("+revision+") est un logiciel conçu par : <br/><center>"
+                   + "Philippe VIENNE<br/>"
+                   + "Guillaume MATHERON<br/>"
+                   + " et Inria<br/>"
+                   + "</center>"
+		   + "en collaboration avec David Pichardie, Philippe Lucaud, etc.. et le conseil de Robert Cabane<br/><br/>"
+                   + "Il est distribué sous les conditions de la licence CeCILL et GNU GPL V3<br/>", true);
+  }
+
+  /** Renvoie une bouton (sous forme de logo) qui affiche le panneau de about lors de son clic. */
+  public static JLabel getAboutMessage()  {
+        JLabel logoLabel = new JLabel(Macros.getIcon(logo));
+        logoLabel.addMouseListener(new MouseAdapter() {
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                showAboutMessage();
+            }
+        });
+        return logoLabel;
+  }
+}
Index: src/org/javascool/package.html
===================================================================
--- src/org/javascool/package.html	(.../Users/philien/Workspace/Java's Cool 4.1/src)	(revision 0)
+++ src/org/javascool/package.html	(.../https://javascool.googlecode.com/svn/work/src)	(revision 1009)
@@ -0,0 +1,15 @@
+<body>Bienvenue dans la liasse des fichiers sources de JavaS'Cool, version 4.
+
+ <p>Java's Cool (alias Javascool) est un logiciel conçu pour l'apprentissage des bases de la programmation.</p>
+
+ <p>Cette liasse se décompose en trois blocs: <ol>
+   <li>L'application "apprenant" qui permet de manipuler des «proglets» (<a href="Core.html">org.javascool.Core</a>): <ul>
+   <li>On peut directement lancer <a href="http://javascool.gforge.inria.fr/v4/javascool-proglets.jar">javascool-proglets.jar</a> pour en profiter.</li></ul></li>
+   <li>L'application "formateur" qui permet de construire des «proglets» (<a href="Builder.html">org.javascool.Builder</a>): <ul>
+   <li>On peut <i>télécharger</i> <a href="http://javascool.gforge.inria.fr/v4/javascool-builder.jar">javascool-builder.jar</a> et le lancer dans le répertoire oqui contient les dossiers avec les «proglets» afin de les compiler.</li></ul></li>
+   <li>Les fichiers sources du <a href="http://javascool.fr/v4">site web</a> qui sont générés et publiés à partir d'<a href="http://code.google.com/p/javascool/source/browse/web/package.txt">ici</a>.</li>
+ </ol></p>
+
+ <p>La <a href="http://code.google.com/p/javascool/source/browse">liasse des fichiers</a> est <a href="http://code.google.com/p/javascool/source/browse/package.txt">décrite ici</a>.</p>
+
+</body>
